+====================================================================================================
+====================================================================================================
*przy tworzeniu jakiegokolwiek folderu dla projektu django musisz utworzyć wewnątrz tego folderu 
 pusty plik _init__.py
*we view.py przy tworzeniu funkcji związanych z logowaniem itp NIE WOLNO używać nazw funkcji takich jak:
		*def login()
		*def logout()
		*def authenticate()
*sprawdzić 
	permissions
	has_role
	https://django-role-permissions.readthedocs.io/en/stable/utils.html
	@allowed_users(allowed_roles=['Admin', 'Staff', 'Lite Scan'])
	https://coderbook.com/@marcus/how-to-restrict-access-with-django-permissions/
	https://www.youtube.com/watch?v=xv_bwpA_aEA&list=PL-51WBLyFTg2vW-_6XBoUpE7vpmoR3ztO - ivy
=====================================================================================================
	2.POSTMAN:
		*PODSTAWY:
			**służy do testowania żądań w API
			**ustawiasz TYP ŻĄDANIA, uruchamiasz swój serwer, wpisujesz śćieżkę i klikasz 'SEND'
			**dla żądania POST wpisujesz argumenty do serializera w dziale danych wysyłanych w sekcji 
			  'BODY' we 'form-data' 
			**w przypadku ZEZWOLEŃ 'PERMISSIONS' musisz w sekcji 'Headers' dodać zmienną odpowiedzialną 
			  za autoryzacji i przypisać jej token wgschematu: {'Authorization': 'Token wartość_tokena')
						KEY:				VALUE:
						Authorization   	8a09c71f5ba4bda0e8a7c449164d8b58d85197f7
			**przy żądaniu 'POST' zarówno w ścieżka w URLS.PY jak i w postmanie musi byc BEZ slasha na 
			  końcu!!! Inaczej ścieżka wywoływana ścieżka będzie pokazywać błędy:
				**w URLS.PY:
						urlpatterns = [
							path("create", api_create_blog_view, name="create"),    
						]	
				**w POSTMAN'ie:
						http://127.0.0.1:8000/api/blog/create
		*SESJE dla FORMULARZY:
			**wszystkie formularze zbudowane w django (a nie te oparte o djangorestframework) wymagają
			  sporządzenia sesji czyli użycia zmiennej csrf_token
    		**wysyłasz POSTMAN'em żądanie GET na stronę logowania -> kopiujesz csrftoken z odebranych
			  danych z sekcji 'cookies' 
			**tworzysz w POSTMAN'ie żądanie POST na stronę logowania -> w danych do wysłania w sekcji 
			  'Headers' tworzysz zmienną: 'X-CSRFToken' i dajesz jej wartość w postaci skopiowanego
			  csrftoken'u z poprzedniego punktu. Wysyłasz żądanie. 		
============================================================================================================
	1. MODELOWE PODEŚCIE DO API:
		*W URLS.PY
			**musisz pamiętać że ścieżka odwołująca się do funkcji we views wysyłającej żądanie POST 
			  nie może kończyć się slashem !!! (inaczej nie zadziała):
			**również przy wywoływaniu w postmanie wywołuj tę ścieżkę (create) bez slasha na końcu!!!
							urlpatterns = [
								path("<slug:slug>/", api_detail_blog_view, name="detail"),
								path("<slug:slug>/update/", api_update_blog_view, name="update"), 
								path("<slug:slug>/delete/", api_delete_blog_view, name="delete"),
								path("create", api_create_blog_view, name="create"),    
							]
		*W SERIALIZERS.PY:
							from rest_framework import serializers
							from blog.models import BlogPost
							class BlogPostSerializer(serializers.ModelSerializer):
								class Meta:
									model = BlogPost
									fields = ['title', 'body', 'image', 'date_updated' ]
		*WE VIEWS.PY:									
							from rest_framework import status
							from rest_framework.response import Response
							from rest_framework.decorators import api_view

							from .serializers import BlogPostSerializer
							from blog.models import BlogPost, Account
							from django.contrib.auth.decorators import login_required
							
							from rest_framework.permissions import IsAuthenticated
							from rest_framework.pagination import PageNumberPagination
							from rest_framework.filters import SearchFilter, OrderingFilter
							from rest_framework.generics import ListAPIView
							from rest_framework.authentication import TokenAuthentication
							class ApiBlogListView(ListAPIView):
								queryset = BlogPost.objects.all()
								serializer_class = BlogPostSerializer
								authentication_classes = (TokenAuthentication,)
								permission_classes = (IsAuthenticated,)
								pagination_class = PageNumberPagination
								page_size = 2
								filter_backends = (SearchFilter, OrderingFilter)
								search_fields = ('^title','body', '=author__username','author__email')
							
							@api_view(['GET',])
							def api_detail_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="GET":
									serializer = BlogPostSerializer(blog_post)
									return Response(serializer.data, status=status.HTTP_200_OK)
							
							@login_required(login_url='login')
							@api_view(['PUT',])
							def api_update_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="PUT":
									serializer = BlogPostSerializer(blog_post, data=request.data)
									data={}
									if serializer.is_valid():
										serializer.save()
										data["success"] = "update successful"
										return Response(data=data)
									return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
							
							@login_required(login_url='login')
							@api_view(['DELETE',])
							def api_delete_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="DELETE":
									operation=blog_post.delete()
									data={}
									if operation:
										data["success"] = "delete successful"
									else:
										data["failure"] = "delete failed"
									return Response(data=data)

							@login_required(login_url='login')
							@api_view(['POST',])
							def api_create_blog_view(request):
								account = Account.objects.get(pk=1)
								blog_post = BlogPost(author=account.user)
								if request.method == 'POST':
									serializer = BlogPostSerializer(blog_post, data = request.data )
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status = status.HTTP_201_CREATED)
									return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

============================================================================================================
	VIEWSETs i ROUTERs:


============================================================================================================
	PAGINATION oraz WYSZUKIWARKA SEARCHFILTER (FILTERING) w LISTVIEW:
		*https://www.django-rest-framework.org/api-guide/pagination/
		*https://www.django-rest-framework.org/api-guide/filtering/#searchfilter
		*w SETTINGS.PY 
			*ustawiasz domyślną klasę dla wszystkich klas zwracających listę dla żądania 'GET' (zamiast 
			 tego możesz wszystko skonfigurować w class-based-views we views.py (oprócz PAGE_SIZE))
						REST_FRAMEWORK = {
							...
							'DEFAULT_PAGINATION_CLASS':'rest_framework.pagination.PageNumberPagination',
							'PAGE_SIZE':2,
		*WE VIEWS.PY:
			*pagination i searchfilter najłatwiej zrobic tworząc dla GET LISTa class-based-views.
			*w ramach konfiguracji PAGINATION konfigurujesz pola pagination_class odpowiadajce za 
			 pagination oraz page_size odpowiadające za ilość obiektów wyświetlonych w liście, 
			*w ramach konfiguracji WYSZUKIWARKI SEARCHFIELDS konfigurujesz pola filter_backends (do 
			 którego przypisujesz krotkę z klas SearchFilter i OrderingFilter) oraz search_fields
			 gdzie wpisujesz pola po których ma być wyszukiwany dany obiekt
				**pola muszą być związane z klasą w pliku serializers.py
				**pola muszą być typu TextField albo CharField - jeżeli są instancjami obiektów to 
				  poprzez podwójny podkreślnik '__' można wypisać ich pola 
				**można podać tez przed polami znaki: '^','='.'$' oznaczających '^'(rozpoczynanie
				  wyszukiwania, '='(dokładne dopasowanie),'$'(wyszukiwanie po regexie)
						from rest_framework.permissions import IsAuthenticated
						from rest_framework.pagination import PageNumberPagination
						from rest_framework.filters import SearchFilter, OrderingFilter
						from rest_framework.generics import ListAPIView
						from rest_framework.authentication import TokenAuthentication
						class ApiBlogListView(ListAPIView):
							queryset = BlogPost.objects.all()
							serializer_class = BlogPostSerializer
							authentication_classes = (TokenAuthentication,)
							permission_classes = (IsAuthenticated,)
							pagination_class = PageNumberPagination
							page_size = 2
							filter_backends = (SearchFilter, OrderingFilter)
							search_fields = ('^title','body', '=author__username','author__email')
				*na tej podstawie możemy stworzyć ścieżkę do API składającą się z:
					**ścieżki podstawowej do listy (oraz zmiennych po znaku zapytania):
								http://127.0.0.1:8000/api/blog/list
					**zmiennej page (od pagination)	
								http://127.0.0.1:8000/api/blog/list?page=2
					**zmiennej search (od searchfilter) używanej z '+' jako spacja:
								http://127.0.0.1:8000/api/blog/list?page=2&search=body+of+my
					**zmiennej ordering odpowiedzialnej za wyświetlenie listy w danej kolejności:
								http://127.0.0.1:8000/api/blog/list?search=body+of&ordering=-date_uptaded
			*poprzez żądanie 'GET' zostanie zwrócona słownik JSON zawierający klucze: z ilością 
			 wszystkich obiektów -'count', ściężką do następnej/poprzedniej strony -'next'/'previous'
			 oraz wszystkimi wynikami -'results':
						{
							"count": 3,
							"next": "http://127.0.0.1:8000/api/blog/list?page=2",
							"previous": null,
							"results": [
								{
									"title": "my_new_title",
									"body": "is body of my new",
									"image": "http://127.0.0.1:8000/blog_images/331050936_s_MbFrqNA.jpg",
									"date_updated": "2022-04-21T13:51:09.898767Z",
									"username": "marek"
								},
								{
									"title": "my_title",
									"body": "thi is body of my new title",
									"image": "http://127.0.0.1:8000/blog_images/331050936_s_Q2kMpcx.jpg",
									"date_updated": "2022-04-21T14:03:06.990520Z",
									"username": "marek"
								}
							]
						}
		*W URLS.PY:
			*dodajesz scieżkę do zwracania całej listy:
						from .views import ApiBlogListView
						urlpatterns = [
							...
							path("list", ApiBlogListView.as_view(), name = "list"),
						]

========================================================================================================
	AUTHENTICATION & PERMISSIONS & RESTRICTED ROUTE:
		*PODSTAWY:
			*https://www.django-rest-framework.org/api-guide/permissions/#setting-the-permission-policy
			*w przypadku nieautoryzowanego dostępu są 2 błędy pasujące do tego typu działania:
				HTTP 401 Unauthorized
				HTTP 403 Permission Denied
		*WERYFIKACJA poprzez RESTRICTED ROUTE:
			**zamiast authentyfikacji i nadania zezwoleń przez @permission_classes(IsAuthenticated, )
			  możesz udekorować funkcje nad dekoratorem żądania '@api_view' do dodatkowej weryfikacji,
			  czyli: '@login_required(login='loginPage'):
							from rest_framework import status
							from rest_framework.response import Response
							from rest_framework.decorators import api_view
							from django.contrib.auth.decorators import login_required
							
							@login_required(login_url='login')
							@api_view(['GET',])
							def api_detail_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="GET":
									serializer = BlogPostSerializer(blog_post)
									return Response(serializer.data, status=status.HTTP_200_OK)
		*DZIAŁANIE we VIEWS.PY - authentykacje i zezwolenia (permissions) można zrobic na 3 sposoby:
			***wpisując w settings.py ogólną authentykacji / permission dla wszystkich funkcji:
						REST_FRAMEWORK = {
							'DEFAULT_AUTHENTICATION_CLASSES': [
								'rest_framework.authentication.BasicAuthentication',
								'rest_framework.authentication.SessionAuthentication',
							],
							'DEFAULT_PERMISSION_CLASSES': [						#NIE podawaj domyślnej 
								'rest_framework.permissions.IsAuthenticated',	#klasy ZEZWOLEN bo do
								]												#każdej funkcji będziesz 
							}													#musiał podawać token do 
						}														#autoryzacji:
			***w function-basedview poprzez dekoratory(@authentication_classes i @permission_classes)
						from rest_framework.decorators import (api_view, permission_classes, 
															   authentication_classes)
						from rest_framework.authentication import (SessionAuthentication, 
																   BasicAuthentication)
						from rest_framework.permissions import IsAuthenticated
						@api_view(['GET'])
						@authentication_classes([SessionAuthentication, BasicAuthentication])
																	#sprawdza albo jedną albo drugą
						@permission_classes([IsAuthenticated])
						def example_view(request, format=None):
							...
			***w class-based-views przesłaniając pola authentication_classes i permission_classes:
						from rest_framework.authentication import (SessionAuthentication, 
																   BasicAuthentication)
						from rest_framework.permissions import IsAuthenticated
						class ExampleView(APIView):
							authentication_classes = [SessionAuthentication, BasicAuthentication]
																	#sprawdza albo jedną albo drugą
							permission_classes = [IsAuthenticated]				
							...
		*RODZAJE AUTHENTYFIKACJI (BasicAuthentication, TokenAuthentication, SessionAuthentication):
			*BasiAuthentication 
					**(wraz z zezwoleniem permission_classes = IsAuthenticated)
					**używane tylko podczas produkcji - nie wolno stosować go już w deployment'cie
					**potrzebna jest podstawowa weryfikacja (username i password)			
			*SessionAuthentication 
					**(wraz z zezwoleniem permission_classes = IsAuthenticated)
					**zalecane dla aplikacji webowych typu AJAX, korzysta z domyślnego Django session 
					  backend wykorzystuję się zazwyczaj z BasicAuthentication	
						authentication_classes = [SessionAuthentication, BasicAuthentication]
					**musisz dodać do urls:
						path('auth/', include('rest_framework.urls'))
			*TokenAuthentication:
					**(wraz z zezwoleniem permission_classes = IsAuthenticated)
					**zalecane dla aplikacji natywnych tj na konkretny system, np: android, ios
				*W SETTINGS.PY:
					*instalacja pipem 'rest_framework.authtoken' i migracja tego:
							pip install django-rest-authtoken
							python manage.py migrate
					*do INSTALLED_APPS dodajesz 
							INSTALLED_APPS = [
								...
								'rest_framework.authtoken',
							]			
					*od teraz pojawi ci się dodatkowy klasa/model w adminie o nazwie 'Token'
				*W MODELS.PY:
					*żeby Token tworzył się automatycznie podczas tworzenia użytkownika towrzysz sygnał 
					 do utworzenia Tokenu (klasa Token z rest_framework.authtoken.models) przy tworzeniu 
					 konta użytkownika (User / klasa Account wskazana w zmiennej settings.AUTH_USER_MODEL). 
					 Dla klasy Token podajesz argument w postaci tego kto jest właścicielem tokenu:
							from django.conf import settings
							from django.db.models.signals import post_save
							from django.dispatch import receiver
							from rest_framework.authtoken.models import Token

							@receiver(post_save, sender = settings.AUTH_USER_MODEL)
							def create_auth_token(sender, instance=None, created=False, **kwargs):
								if created:
									Token.objects.create(user=instance)
				*W URLS.PY:
					*importujesz funkcje obtain_auth_token z rest_framework.authtoken.views która zwraca 
					 z tabeli Token: auth_token danego użytkownika.
					*dla ścieżki 'my_obtain' i żądania 'POST' zostaje wywołana funkcja: obtain_auth_token 
					 która pobiera z requesta 2 parametry: 'username' i 'password' (mimo tego że w 
					 models.py dla klasy dziedziczącej po AbstractBaseUser w zmiennej USERNAME_FIELD 
					 podałeś 'email' to przy metodzie obtain_auth_token musisz podać w parametrach 
					 nazwę 'username' (zamiast 'email'). 
							from django.urls import path
							from rest_framework.authtoken.views import obtain_auth_token
							urlpatterns = [
								path('my_obtain', obtain_auth_token, name = 'my_obtain'),
							]							
				*WE VIEWS.PY:
							from rest_framework import status
							from rest_framework.response import Response
							from .serializers import BlogPostSerializer
							
							from rest_framework.decorators import api_view, permission_classes
							from rest_framework.permissions import IsAuthenticated
							
							@api_view(['PUT',])
							@permission_classes((IsAuthenticated, ))
							def api_update_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								user = request.user
								if blog_post.author != user:
									return Response({'response':"You don't have permission to edit that"}) 
								if request.method =="PUT":
									serializer = BlogPostSerializer(blog_post, data=request.data)
									data={}
									if serializer.is_valid():
										serializer.save()
										data["success"] = "update successful"
										return Response(data=data)
									return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
					*możesz pobierać Token:
							account = Account.objects.get(id=1)
							data={}
							data['token'] = Token.object.get(user=account).key
					*możesz nadawać funkcjom ZEZWOLENIA ('PERMISSIONS'):
						*przed funkcjom dodajesz dekorator: 
							@permission_classes((IsAuthenticated, ))
						*jeżeli zależy Tobie żeby oprócz tego żeby użytkownik miał autoryzacje (był 
						 zalogowany) to jeszcze był autorem utworzone obiektu to dodajesz:
							user = request.user
							if blog_post.author != user:
								return Response({'response':"You don't have permission to edit that"}) 
					*(w POSTMANIE dla POST w Headers podajesz parametr:
					 {'Authorization': 'Token wartość_klucza'})
=====================================================================================================
	1.SERIALIZERS.PY:
		0*PODSTAWY
		1*RODZAJE:
			A) Z ROZWINIĘCIEM KAŻDEGO POLA i MOŻLIWOŚĆIĄ NAŁOŻENIA OGRANICZEŃ NA POLA
						from rest_framework import serializers
						from blog.models import BlogPost
						class BlogPostSerializer(serializers.Serializer):
							title = serializers.CharField(max_length=50)
							body = serializers.CharField(max_length=200)
							image = serializers.ImageField()
							date_updated = serializers.DateTimeField(read_only=True)
			B) Z KLASĄ WEWNĄTRZNĄ i MOŻLIWOŚCIĄ NAŁOŻENIA OGRANICZEŃ NA POLA:
						from rest_framework import serializers
						from blog.models import BlogPost
						class BlogPostSerializer(serializers.ModelSerializer):
							date_updated = serializers.DateTimeField(read_only=True)
							class Meta:
								model = BlogPost
								fields = ['title', 'body', 'image', 'date_updated' ]
		2*METODY TWORZENIA:
			*https://www.django-rest-framework.org/api-guide/serializers/#saving-instances
			*we views.py podczas zapisywania obiektu serializatora zostanie wywołana metoda save() 
			 która jeżeli nie będzie przesłonieta wywoła metodę create lub update. (jeżeli w argumencie
			 serializatora podasz instancje obiektu bazowego dla serializatorem to zostanie wywołana 
			 metoda update a jeżeli nie to metoda create):
				**we views.py:
						serializer = BlogPostSerializer(data=request.data)				#metoda create
						blog1 = BlogPost(title=...)
						serializer = BlogPostSerializer(blog1, data=request.data)		#metoda update
						if serializer.is_valid():
							serializer.save()		#wywołanie save() i tym samym albo create albo update
			*wewnątrz serializatora by uzyskać dane używasz validated_data['my_field'] albo 
			 self.validated_data['my_field'] albo request.POST.get(). Następnie zapisujesz obiekt 
			 utworzony lub update'towany i go zwracasz.
				**w serializers.py:
						class BlogPostSerializer(serializers.ModelSerializer):
							class Meta:
								model = BlogPost
								fields = ['title','body']				#'__all__'
							def create(self, validated_data):							
								b1 = BlogPost(
									title= validated_data['title'], 
									body= validated_data['body'],
									)
								b1.save()
								return b1
							def update(self, instance, validated_data): 
								instance.title = validated_data['title']
								instance.body = validated_data['body'])
								instance.save()
								return instance
			*metode save() też można przesłonić:
							def save(self):
								b1 = BlogPost(
									title= self.validated_data['title'], 
									body= self.validated_data['body'],
									)
								b1.save()
								return b1
		3*METODY WALIDACJI:
			*dla danych przychodzących (żądania PUT i POST) możesz zrobić własną walidacje w 
			 serializerze i podnieść wyjątek ValidationError
			*dla metody 'validate' zwracasz słownik 'data' a dla 'validate_<my_filed>' wartość pola:
				**w serializers.py:
							def validate(self, data):
								if data['start'] > data['finish']:
									raise serializers.ValidationError("finish must occur after start")
								return data
							def validate_title(self, value)
								if 'django' not in value.lower():
									raise serializers.ValidationError("Blog post is not about Django")
								return value				
			*uruchamiane podczas wywoływania metody 'is_valid()' we views.py:
				**we views.py:
							if serializer.is_valid():		#walidacja
								serializer.save()			#zapisanie danych pryzychodzących jako obiekt 
		4*serializers.SerializerMethodField()
			*pozwala na serializację danych które są w klasie serializowanej instancjami innych klas
			 (konkretnie chodzi o pola innych klas)
			*najpierw w klasie serializowanej dodajesz metodę która będzie przyjmować obiekt klasy
			 serializowanej. Wewnątrz pobierasz dane z bazy danych (pola z klasy będacej polem w klasie 
			 serializowanej) (def get_username_from_author)
			*następnie tworzysz pole dla Serilizera (username) i przypisujesz mu metodę 
			 serializers.SerializerMethodField() do której podajesz w arg w cudzysłowiach nazwę tej metody,
			 którą utworzyłeś przed chwilą (get_username_from_author)
			*na końcu dodajesz nazwę pola ('username') w klasie Meta w polu fields: 
				**w serializers.py:
						from rest_framework import serializers
						from blog.models import BlogPost
						class BlogPostSerializer(serializers.ModelSerializer):
							username = serializers.SerializerMethodField('get_username_from_author')
							class Meta:
								model = BlogPost
								fields = ['title', 'body', 'image', 'date_updated', 'username']
							def get_username_from_author(self, blog_post):
								username = blog_post.author.username
								return username


========================================================================================================

=====================================================================================================
	2.REJESTRACJA USERA POPRZEZ API:
		*W SERIALIZERS.PY:
			*dla password i password2 musisz zrobić ograniczenie 'write_only=True' możesz to zrobić 
			 nad klasą Meta lub w klasie Meta:
							password2 = serializers.CharField(style={'input_type': 'password'}, 
															  write_only=True)
							class Meta:
								...
								extra_kwargs ={'password': {'write_only': True}}
			*przeciążasz metodę save() w której pobierasz dane z słownika 'validated_data' (słownik 
			 validated_data traktujesz jak cleaned_Data we forms.ModelForm) i na podstawie tych danych 
			 tworzysz usera, przypisujesz mu hasło ('set_password(password)') i zapisujesz tego usera w 
			 bazie danych (wraz ze zwróceniem go):
							from rest_framework import serializers
							from account.models import Account

							class RegistrationSerializer(serializers.ModelSerializer):
								password2 = serializers.CharField(style={'input_type': 'password'}, 
																  write_only=True)    #nadawanie ograniczeń
								class Meta:
									model=Account
									fields = ['email','username','password','password2']
									extra_kwargs ={                                   #nadawanie ograniczeń                             
										'password': {'write_only': True}
									}
								def save(self):
									account = Account(
										email=self.validated_data['email'],                                     
										username = self.validated_data['username'],
									)
									password = self.validated_data['password']
									password2 = self.validated_data['password2']
									if password !=password2:
										raise serializers.ValidationError(
																  {'password': 'Password must match'})
									account.set_password(password)
									account.save()
									return account
		*WE VIEWS.PY:
			*tworzysz api_view(['POST',]) a wewnątrz obiekt serializera któemu przypisujesz dane pobrane 
			 z requesta. Sprawdzasz metodą is_valid() serializera i w metodzie Response zwracasz status 
			 i słownik (albo z błędami albo z przypisanymi danymi):
							from .serializers import RegistrationSerializer
							from rest_framework import status
							from rest_framework.response import Response
							from rest_framework.decorators import api_view

							@api_view(['POST',])
							def registration_view(request):
								serializer = RegistrationSerializer(data=request.data)
								data={}
								if serializer.is_valid():
									account = serializer.save()
									data['response'] = "succesfully registersa new user"
									data['email'] = account.email
									data['username'] = account.username
									s = status.HTTP_201_CREATED
								else:
									data = serializer.errors
									s = status.HTTP_400_BAD_REQUEST
								return Response(data=data, status = s)
		*W URLS.PY:
			*dla żądania POST ścieżka nie może kończyć się slashem (zarówno w urls.py i w postmanie)
							from django.urls import path
							from account.api.views import registration_view
							urlpatterns = [
								path('register', registration_view, name = 'register'),
							]
												
========================================================================================================
*logowanie - zmieniasz z funkcji obtain_auth_token na swoją własną:
		*W URLS.PY:

						from rest_framework.authtoken.views import obtain_auth_token
						urlpatterns = [
							path('my_obtain', obtain_auth_token, name = 'my_obtain'),		#login 1
							path('login', ObtainAuthTokenView.as_view(), name = 'login'),	#login 2
						]
		*WE VIEWS.PY:
			*dla funkcji obtain_auth_token z rest_framework.authtoken.views musisałeś podać w żadaniu 
			 POST parametr o kluczu 'username' ale teraz możesz podać parametr przez siebie ustalony 
			 czyli 'email'
			*GET_OR CREATE() - tworzy token jeżeli user jakims sposobem nie ma tokenu
						from rest_framework.views import APIView
						from django.contrib.auth import authenticate
						class ObtainAuthTokenView(APIView):
							authentication_classes = []
							permission_classes = []
							def post(self, request):
								data = {}
								email = request.POST.get('email') 			#dla obtain_auth_token
																			#musiało by być 'username'
								password = request.POST.get('password')  
								account = authenticate(email=email, password = password) 
								if account:
									token=Token.objects.get_or_create(user=account)   
									data['response'] = 'Succesfully authenticated'
									data['pk'] = account.pk
									data['email'] = email
									data['token'] = token.key
								else:
									data['response'] = 'Error'
									data['error_message'] = 'Invalid credentials'
								return Response(data=data)
									
========================================================================================================
	PODSUMOWANIE SPRAW ZWIĄZANYCH Z UŻYTKOWNIKIEM/PROFILEM:
		*PODSTAWY:
			*musisz podać w SETTINGS.PY w zmiennej REST_FRAMEWORK klucz 'DEFAULT_AUTHENTICATION_CLASSES' 
			 domyślnej klasy używanej do authentykacji przy funkcjcach 'DETAIL', 'UPDATE', 'DELETE' 
			 które wymagają zezwolenia (permissions)
			*dla użytkownika nie ma LISTVIEW tylko logowanie (albo po funkcji obtain_auth_token z 
			 rest-framework.auth_token.views albo po zbudowanej przez siebie class-base-views 
			 dziedziczącym po APIView)
			*przy logowaniu nie korzystasz z serializera gdyż nie chcesz tych danych ani zapisać ani 
			 zwrócić w formie która jest podana w serializerze AccountPropertiesSerializer (chcesz zwrócić 
			 token a w przypadku nieudanego logowania zwrócić swoje typy błędów)
			*masz 3 typy serializerów -> wszystkie dotycza klasy Account ALE jeden jest tylko do 
			 rejestracji, drugi pozwala na zwrócenie lub modyfikacje pól email i username (bez 
			 możliwości modyfikacji hasła) a trzeci odpowiada tylko za modyfikacje hasła:. 
			*przy logowaniu i rejestracji nie wymaga się się ZEZWOLEŃ (perrminssion - dekoratora
			 @permission_classes((IsAuthenticated,))	)
		*W SETTINGS.PY:
							INSTALLED_APPS = [
								...
								'rest_framework.authtoken',
							]
							REST_FRAMEWORK = {
								'DEFAULT_AUTHENTICATION_CLASSES': [
									'rest_framework.authentication.TokenAuthentication',
								]
							}
		*W SERIALIZERS.PY:
					from rest_framework import serializers
					from account.models import Account
				#zwrócenie danych usera i update Account'a bez update'u hasła
					class AccountPropertiesSerializer(serializers.ModelSerializer):
						class Meta:
							model = Account
							fields = ['pk', 'email', 'username']
				#update hasła
					class ChangePasswordSerializer(serializers.Serializer):
						old_password = serializers.CharField(required=True)
						new_password = serializers.CharField(required=True)
						confirm_new_password = serializers.CharField(required=True)	
				#rejestracja Account'a
					class RegistrationSerializer(serializers.ModelSerializer):
						password2 = serializers.CharField(style={'input_type': 'password'}, write_only=True)  
						class Meta:
							model=Account
							fields = ['email','username','password','password2']
							extra_kwargs ={                                                                     
								'password': {'write_only': True}
							}
						def save(self):
							account = Account(
								email=self.validated_data['email'],      
								username = self.validated_data['username'],
							)
							password = self.validated_data['password']
							password2 = self.validated_data['password2']
							if password !=password2:
								raise serializers.ValidationError({'password': 'Password must match'})
							account.set_password(password)
							account.save()
							return account
		*WE VIEWS.PY:
					from django.shortcuts import render, redirect
					from account.models import Account

					from rest_framework import status
					from rest_framework.response import Response 

					from rest_framework.authtoken.models import Token
					from .serializers import RegistrationSerializer, AccountPropertiesSerializer
					from rest_framework.decorators import api_view, permission_classes
					from rest_framework.permissions import IsAuthenticated

					from rest_framework.views import APIView
					from rest_framework.generics import UpdateAPIView
					from django.contrib.auth import authenticate

					##LOGOWANIE
					class ObtainAuthTokenView(APIView):
						authentication_classes = []
						permission_classes = []
						def post(self, request):
							data = {}
							email = request.POST.get('email') 
							password = request.POST.get('password')  
							account = authenticate(email=email, password = password) 
							if account:
								token=Token.objects.get_or_create(user=account)        
								data['response'] = 'Succesfully authenticated'
								data['pk'] = account.pk
								data['email'] = email
								data['token'] = token[0].key
							else:
								data['response'] = 'Error'
								data['error_message'] = 'Invalid credentials'
							return Response(data=data)

					#REJESTRACJA:
					@api_view(['POST',])
					def registration_view(request):
						serializer = RegistrationSerializer(data=request.data)
						data={}
						if serializer.is_valid():
							account = serializer.save()
							data['response'] = "succesfully register a new user"
							data['email'] = account.email
							data['username'] = account.username
							s = status.HTTP_201_CREATED
							data['token'] = Token.objects.get(user=account).key
						else:
							data = serializer.errors
							s = status.HTTP_400_BAD_REQUEST
						return Response(data=data, status = s)

					#DETAIL DLA USERA:
					@api_view(['GET',])
					@permission_classes((IsAuthenticated,))
					def account_properties_view(request):
						try:
							account=request.user
						except Account.DoesNotExist:
							return Response(status=status.HTTP_404_NOT_FOUND)
						if request.method == 'GET':
							serializer = AccountPropertiesSerializer(account)
							return Response(serializer.data)

					#UPDATE DLA USERA:
					@api_view(['PUT',])
					@permission_classes((IsAuthenticated,))
					def account_update_view(request):
						try:
							account=request.user
						except Account.DoesNotExist:
							return Response(status=status.HTTP_404_NOT_FOUND)
						if request.method == 'PUT':
							serializer = AccountPropertiesSerializer(account, data = request.data)
							data ={} 
							if serializer.is_valid():
								serializer.save()
								data['response'] = "Account update success"
								return Response(data=data)
							return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)

					#DELETE DLA USERA:
					@api_view(['DELETE',])
					@permission_classes((IsAuthenticated,))
					def account_delete_view(request):
						try:
							account=request.user
						except Account.DoesNotExist:
							return Response(status=status.HTTP_404_NOT_FOUND)
						if request.method == 'DELETE':
							operation=account.delete()
							data={}
							if operation:
								data["success"] = "delete successful"
							else:
								data["failure"] = "delete failed"
							return Response(data=data)
					
					#ZMIANA HASŁA
					class ChangePasswordView(UpdateAPIView):
						serializer_class = ChangePasswordSerializer
						model = Account
						permission_classes = (IsAuthenticated,)
						authentication_classes = (TokenAuthentication,)
						def get_object(self, queryset=None):
							obj = self.request.user
							return obj
						def update(self, request, *args, **kwargs):
							self.object = self.get_object()
							serializer = self.get_serializer(data=request.data)
							if serializer.is_valid():
								#check old password
								if not self.object.check_password(serializer.data.get("old_password")):
									return Response({"old_password":["Wrong password. "]}, 
													  status = status.HTTP_400_BAD_REQUEST)
								#confirm the new passwords match
								new_password = serializer.data.get("new_password")
								confirm_new_password = serializer.data.get("confirm_new_password")
								if new_password != confirm_new_password:
									return Response({"new_password": ["New passwords must be the same "]}, 
													  status = status.HTTP_400_BAD_REQUEST)
								#set_password also hashes the password that the user will get
								self.object.set_password(serializer.data.get("new_password"))
								self.object.save()
								return Response({"reponse":"succesfully changed password"},
												  status = status.HTTP_200_OK)
							return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
						
					#SPRAWDZENIE CZY KONTO ISTNIEJE (dla ewentualnego wybrania zapomniałem hasła)
					@api_view(['GET',])
					@permission_classes([])
					def does_account_exist_view(request):
						email = request.GET['email']
						data={}
						try:
							email=email.lower()
							account = Account.objects.get(email=email)
							data['response'] = email
						except Account.DoesNotExist:
							data['response'] = "Account does not exist"
						return Response(data=data)

		*W URLS.PY:
					from django.urls import path
					from rest_framework.authtoken.views import obtain_auth_token
					from account.api.views import (registration_view, 
												   account_update_view, 
												   account_properties_view, 
												   account_delete_view, 
												   ObtainAuthTokenView)
					urlpatterns = [
						path('my_obtain', obtain_auth_token, name = 'my_obtain'),			#login 1
						path('login', ObtainAuthTokenView.as_view(), name = 'login'),		#login 2
						path('register', registration_view, name = 'register'),				#rejestracja
						path('properties', account_properties_view, name = 'properties'),	#detail usera
						path('properties/update', account_update_view, name = 'update'),	#update usera
						path('properties/delete', account_delete_view, name = 'delete'),	#delete usera
																							#zmiana hasła
						path('change_password', ChangePasswordView.as_view(), name="change_password"),
																							#czy istnieje
						path('check_if_account_exists', does_account_exist_view, name="if_account_exist"),
					]
		
========================================================================================================



*BLOG SERIALIZER:
W SERIALIZERS.PY:
			***def validate(self, blog_post) --> 
					MIN_TITLE_LENGTH = 5
					MIN_BODY_LENGTH = 50
					class BlogPostUpdateSerializer(serializers.ModelSerializer):
						class Meta:
							model = BlogPost
							fields = ['title','body','image']
						def validate(self, blog_post):
							try:
								title = blog_post['title']
								if len(title) < MIN_TITLE_LENGTH:
									raise serializers.ValidationError({'response':"Enter a title longer than: " + str(MIN_TITLE_LENGTH)})
								body = blog_post['body']
								if len(body) < MIN_BODY_LENGTH:
									raise serializers.ValidationError({'response':"Enter a body longer than: " + str(MIN_BODY_LENGTH)})
							excpet KeyError:
								pass
							return blog_post
							
		**w metodzie validate, działasz na instancji, czyli durigm argumencie funkcji ((blog_post['title']))
		  a w metodzie save(), działasz na validated_data ((self.validated_data['title']))
WE VIEWS.PY:
			***partial=True oznacza że możesz wpisać część danych 
					serializer = BlogPostUpdateSerializer(blog_post, data=request.data, partial=True)
					

	
	