SPIS TREŚCI:
====================================================
8)DEPLOYING
====================================================
7)DJANGO REST FRAMEWORK - REJESTRACJA/LOGOWANIE/PROFIL:	
	3.PODSUMOWANIE SPRAW ZWIĄZANYCH Z UŻYTKOWNIKIEM/PROFILEM
	2.LOGOWANIE - zmieniasz z funkcji obtain_auth_token na swoją własną
	1.REJESTRACJA USERA POPRZEZ API
====================================================
6)DJANGO REST FRAMEWORK - PODSTAWY:
	7.MODELOWE PODEŚCIE DO API
	6.PAGINATION oraz WYSZUKIWARKA SEARCHFILTER (FILTERING) w LISTVIEW
	5.AUTHENTICATION & PERMISSIONS & RESTRICTED ROUTE
		*PODSTAWY:
		*WERYFIKACJA poprzez RESTRICTED ROUTE
		*DZIAŁANIE we VIEWS.PY 
		*RODZAJE AUTHENTYFIKACJI (BasicAuthentication, TokenAuthentication, SessionAuthentication)
	4.DOSTĘPNOŚĆ CORS-HEADERS
	3.OGÓLNE DZIAŁANIE we VIEWS.PY 
		0**PODSTAWY:
		1**OPCJA PIERWSZA - BEZ WYKORZYSTANIA rest_framework'a
			*OPCJA 1.1 - serializujesz poprzez metodę serialize() 
			*OPCJA 1.2 - serializator w pliku serializers.py
		2**OPCJA DRUGA - WYKORZYSTUJESZ FUNCTION-BASED-VIEWS w rest_framework'u
			*OPCJA 2.1 - serializujesz poprzez metode serialize()
			*OPCJA 2.2 (POWSZECHNIE UŻYWANA)- serializator w serializers.py
		3**OPCJA TRZECIA - CLASS-BASED-VIEWS w rest_framework'u
			*OPCJA 3.1 - APIView
			*OPCJA 3.2 -  GenericAPIView CLASS-BASED-VIEWS and MIXINS
			*OPCJA 3.3 - OSOBNE GENERICS CLASS-BASED-VIEWS
		4**OPCJA CZWARTA - VIEWSETS & ROUTERS w rest_framework'u
			*OPCJA 4.1 - ViewSet
			*OPCJA 4.2 - GenericViewSet & mixins
			*OPCJA 4.3 - ModelViewSet 
	2.SERIALIZERS.PY
		1*RODZAJE
		2*METODY TWORZENIA
		3*METODY WALIDACJI
		4*serializers.SerializerMethodField()
	1.INSTALACJE
	0*POSTMAN
====================================================
5)TESTY
	0)PODSTAWY:
	1)Testowanie pliku models.py
	2)Testowanie pliku VIEWS.PY
	3)Testowanie haseł i SECRET_KEY - validate_password 
	4)Rzeczy dodatkowe odróżniające od zwykłych testów
====================================================
4)RÓŻNE FORMY FORMULARZY
	0*Formularz WIELOKROTNEGO WYBORU 
	1*Formularz JEDNOKROTNEGO WYBORU (formularz budowany od podstaw w HTMLu, przekierowujący na inną 
	2*Wiele tych samych formularzy na jednej stronie (FORMSET we form)
====================================================
3)ROZSZERZENIE KLASY MODELS
	A) models.Manger, models.QuerySet
	B) VALIDATORS:
====================================================
2)STRONA ADMINISTRATORA 
====================================================
1)DEBUGOWANIE CAŁEGO PROJEKTU
====================================================
===========================================================================================================
===========================================================================================================
===========================================================================================================


===========================================================================================================
8)DEPLOYING:
	1* DEPLOYING (CODING ENTREPRENEURS):
		a)I część PRZYGOTOWANIA DO DEPLOYingu:
				*musisz stworzyć plik .env na poziomie pliku manage.py, gdzie 
				 zapiszesz zmienne które staną się zmiennymi środowiskowymi dla 
				 serwera i których nie będziesz chciał wysyłac na repozytorium 
				 (np: SECRET_KEY, API_KEY) (wszystkie te zmienne zamiast wpliku .env
				 mógłbyś wpisać w pliku settings.py ale wtedy zmienne te będą 
				 wysyłane na repozytorium a nie powinny
						SECRET_KEY = 'django-insecure-$2f8b8_2!-91h6ip-!of1(k3zp9@^+ko$=+*l&(0juq#f@*g9j'
						DEBUG = 1
						ALLOWED_HOSTS =['127.0.0.1', 'localhost']			
			*w pliku settings.py - pobierasz zmienne środowiskowe które są zawarte 
			 w pliku '.env':
						SECRET_KEY = os.environ.get('SECRET_KEY')
						DEBUG = str(os.environ.get('DEBUG')) == "1"	
						ALLOWED_HOSTS =[]
						if not DEBUG:
							ALLOWED_HOSTS += [os.environ.get('ALLOWED_HOSTS')]
			*INSTALACJA django-dotenv
						pip install django-dotenv	/	pip install python-dotenv
			*w pliku manage.py - odczytanie pliku .env 
						import dotenv
						def main():
							dotenv.read_dotenv()
							...
		b)II część PRZYGOTOWANIA DO DEPLOYingu:
			*https://www.codingforentrepreneurs.com/blog/prepare-django-for-digital-ocean-app-platform
			*wytłumaczenie - https://www.youtube.com/watch?v=M9aCNYM_4vQ
		
					
===========================================================================================================
7)DJANGO REST FRAMEWORK - REJESTRACJA/LOGOWANIE/PROFIL:	
	3.PODSUMOWANIE SPRAW ZWIĄZANYCH Z UŻYTKOWNIKIEM/PROFILEM:
		*PODSTAWY:
			*musisz podać w SETTINGS.PY w zmiennej REST_FRAMEWORK klucz 'DEFAULT_AUTHENTICATION_CLASSES' 
			 domyślnej klasy używanej do authentykacji przy funkcjcach 'DETAIL', 'UPDATE', 'DELETE' 
			 które wymagają zezwolenia (permissions)
			*dla użytkownika nie ma LISTVIEW tylko logowanie (albo po funkcji obtain_auth_token z 
			 rest-framework.auth_token.views albo po zbudowanej przez siebie class-base-views 
			 dziedziczącym po APIView)
			*przy logowaniu nie korzystasz z serializera gdyż nie chcesz tych danych ani zapisać ani 
			 zwrócić w formie która jest podana w serializerze AccountPropertiesSerializer (chcesz zwrócić 
			 token a w przypadku nieudanego logowania zwrócić swoje typy błędów)
			*masz 3 typy serializerów -> wszystkie dotycza klasy Account ALE jeden jest tylko do 
			 rejestracji, drugi pozwala na zwrócenie lub modyfikacje pól email i username (bez 
			 możliwości modyfikacji hasła) a trzeci odpowiada tylko za modyfikacje hasła:. 
			*przy logowaniu i rejestracji nie wymaga się się ZEZWOLEŃ (perrminssion - dekoratora
			 @permission_classes((IsAuthenticated,))	)
		*W SETTINGS.PY:
							INSTALLED_APPS = [
								...
								'rest_framework.authtoken',
							]
							REST_FRAMEWORK = {
								'DEFAULT_AUTHENTICATION_CLASSES': [
									'rest_framework.authentication.TokenAuthentication',
								]
							}
		*W SERIALIZERS.PY:
					from rest_framework import serializers
					from account.models import Account
				#zwrócenie danych usera i update Account'a bez update'u hasła
					class AccountPropertiesSerializer(serializers.ModelSerializer):
						class Meta:
							model = Account
							fields = ['pk', 'email', 'username']
				#update hasła
					class ChangePasswordSerializer(serializers.Serializer):
						old_password = serializers.CharField(required=True)
						new_password = serializers.CharField(required=True)
						confirm_new_password = serializers.CharField(required=True)	
				#rejestracja Account'a
					class RegistrationSerializer(serializers.ModelSerializer):
						password2 = serializers.CharField(style={'input_type': 'password'}, write_only=True)  
						class Meta:
							model=Account
							fields = ['email','username','password','password2']
							extra_kwargs ={                                                                     
								'password': {'write_only': True}
							}
						def save(self):
							account = Account(
								email=self.validated_data['email'],      
								username = self.validated_data['username'],
							)
							password = self.validated_data['password']
							password2 = self.validated_data['password2']
							if password !=password2:
								raise serializers.ValidationError({'password': 'Password must match'})
							account.set_password(password)
							account.save()
							return account
		*WE VIEWS.PY:
					from django.shortcuts import render, redirect
					from account.models import Account

					from rest_framework import status
					from rest_framework.response import Response 

					from rest_framework.authtoken.models import Token
					from .serializers import RegistrationSerializer, AccountPropertiesSerializer
					from rest_framework.decorators import api_view, permission_classes
					from rest_framework.permissions import IsAuthenticated

					from rest_framework.views import APIView
					from rest_framework.generics import UpdateAPIView
					from django.contrib.auth import authenticate

					##LOGOWANIE
					class ObtainAuthTokenView(APIView):
						authentication_classes = []
						permission_classes = []
						def post(self, request):
							data = {}
							email = request.POST.get('email') 
							password = request.POST.get('password')  
							account = authenticate(email=email, password = password) 
							if account:
								token=Token.objects.get_or_create(user=account)        
								data['response'] = 'Succesfully authenticated'
								data['pk'] = account.pk
								data['email'] = email
								data['token'] = token[0].key
							else:
								data['response'] = 'Error'
								data['error_message'] = 'Invalid credentials'
							return Response(data=data)

					#REJESTRACJA:
					@api_view(['POST',])
					def registration_view(request):
						serializer = RegistrationSerializer(data=request.data)
						data={}
						if serializer.is_valid():
							account = serializer.save()
							data['response'] = "succesfully register a new user"
							data['email'] = account.email
							data['username'] = account.username
							s = status.HTTP_201_CREATED
							data['token'] = Token.objects.get(user=account).key
						else:
							data = serializer.errors
							s = status.HTTP_400_BAD_REQUEST
						return Response(data=data, status = s)

					#DETAIL DLA USERA:
					@api_view(['GET',])
					@permission_classes((IsAuthenticated,))
					def account_properties_view(request):
						try:
							account=request.user
						except Account.DoesNotExist:
							return Response(status=status.HTTP_404_NOT_FOUND)
						if request.method == 'GET':
							serializer = AccountPropertiesSerializer(account)
							return Response(serializer.data)

					#UPDATE DLA USERA:
					@api_view(['PUT',])
					@permission_classes((IsAuthenticated,))
					def account_update_view(request):
						try:
							account=request.user
						except Account.DoesNotExist:
							return Response(status=status.HTTP_404_NOT_FOUND)
						if request.method == 'PUT':
							serializer = AccountPropertiesSerializer(account, data = request.data)
							data ={} 
							if serializer.is_valid():
								serializer.save()
								data['response'] = "Account update success"
								return Response(data=data)
							return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)

					#DELETE DLA USERA:
					@api_view(['DELETE',])
					@permission_classes((IsAuthenticated,))
					def account_delete_view(request):
						try:
							account=request.user
						except Account.DoesNotExist:
							return Response(status=status.HTTP_404_NOT_FOUND)
						if request.method == 'DELETE':
							operation=account.delete()
							data={}
							if operation:
								data["success"] = "delete successful"
							else:
								data["failure"] = "delete failed"
							return Response(data=data)
					
					#ZMIANA HASŁA
					class ChangePasswordView(UpdateAPIView):
						serializer_class = ChangePasswordSerializer
						model = Account
						permission_classes = (IsAuthenticated,)
						authentication_classes = (TokenAuthentication,)
						def get_object(self, queryset=None):
							obj = self.request.user
							return obj
						def update(self, request, *args, **kwargs):
							self.object = self.get_object()
							serializer = self.get_serializer(data=request.data)
							if serializer.is_valid():
								#check old password
								if not self.object.check_password(serializer.data.get("old_password")):
									return Response({"old_password":["Wrong password. "]}, 
													  status = status.HTTP_400_BAD_REQUEST)
								#confirm the new passwords match
								new_password = serializer.data.get("new_password")
								confirm_new_password = serializer.data.get("confirm_new_password")
								if new_password != confirm_new_password:
									return Response({"new_password": ["New passwords must be the same "]}, 
													  status = status.HTTP_400_BAD_REQUEST)
								#set_password also hashes the password that the user will get
								self.object.set_password(serializer.data.get("new_password"))
								self.object.save()
								return Response({"reponse":"succesfully changed password"},
												  status = status.HTTP_200_OK)
							return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
						
					#SPRAWDZENIE CZY KONTO ISTNIEJE (dla ewentualnego wybrania zapomniałem hasła)
					@api_view(['GET',])
					@permission_classes([])
					def does_account_exist_view(request):
						email = request.GET['email']
						data={}
						try:
							email=email.lower()
							account = Account.objects.get(email=email)
							data['response'] = email
						except Account.DoesNotExist:
							data['response'] = "Account does not exist"
						return Response(data=data)

		*W URLS.PY:
					from django.urls import path
					from rest_framework.authtoken.views import obtain_auth_token
					from account.api.views import (registration_view, 
												   account_update_view, 
												   account_properties_view, 
												   account_delete_view, 
												   ObtainAuthTokenView)
					urlpatterns = [
						path('my_obtain', obtain_auth_token, name = 'my_obtain'),			#login 1
						path('login', ObtainAuthTokenView.as_view(), name = 'login'),		#login 2
						path('register', registration_view, name = 'register'),				#rejestracja
						path('properties', account_properties_view, name = 'properties'),	#detail usera
						path('properties/update', account_update_view, name = 'update'),	#update usera
						path('properties/delete', account_delete_view, name = 'delete'),	#delete usera
																							#zmiana hasła
						path('change_password', ChangePasswordView.as_view(), name="change_password"),
																							#czy istnieje
						path('check_if_account_exists', does_account_exist_view, name="if_account_exist"),
					]
					
	2.LOGOWANIE - zmieniasz z funkcji obtain_auth_token na swoją własną:
		*W URLS.PY:

						from rest_framework.authtoken.views import obtain_auth_token
						urlpatterns = [
							path('my_obtain', obtain_auth_token, name = 'my_obtain'),		#login 1
							path('login', ObtainAuthTokenView.as_view(), name = 'login'),	#login 2
						]
		*WE VIEWS.PY:
			*dla funkcji obtain_auth_token z rest_framework.authtoken.views musisałeś podać w żadaniu 
			 POST parametr o kluczu 'username' ale teraz możesz podać parametr przez siebie ustalony 
			 czyli 'email'
			*GET_OR CREATE() - tworzy token jeżeli user jakims sposobem nie ma tokenu
						from rest_framework.views import APIView
						from django.contrib.auth import authenticate
						class ObtainAuthTokenView(APIView):
							authentication_classes = []
							permission_classes = []
							def post(self, request):
								data = {}
								email = request.POST.get('email') 			#dla obtain_auth_token
																			#musiało by być 'username'
								password = request.POST.get('password')  
								account = authenticate(email=email, password = password) 
								if account:
									token=Token.objects.get_or_create(user=account)   
									data['response'] = 'Succesfully authenticated'
									data['pk'] = account.pk
									data['email'] = email
									data['token'] = token.key
								else:
									data['response'] = 'Error'
									data['error_message'] = 'Invalid credentials'
								return Response(data=data)

	1.REJESTRACJA USERA POPRZEZ API:
		*W SERIALIZERS.PY:
			*dla password i password2 musisz zrobić ograniczenie 'write_only=True' możesz to zrobić 
			 nad klasą Meta lub w klasie Meta:
							password2 = serializers.CharField(style={'input_type': 'password'}, 
															  write_only=True)
							class Meta:
								...
								extra_kwargs ={'password': {'write_only': True}}
			*przeciążasz metodę save() w której pobierasz dane z słownika 'validated_data' (słownik 
			 validated_data traktujesz jak cleaned_Data we forms.ModelForm) i na podstawie tych danych 
			 tworzysz usera, przypisujesz mu hasło ('set_password(password)') i zapisujesz tego usera w 
			 bazie danych (wraz ze zwróceniem go):
							from rest_framework import serializers
							from account.models import Account

							class RegistrationSerializer(serializers.ModelSerializer):
								password2 = serializers.CharField(style={'input_type': 'password'}, 
																  write_only=True)    #nadawanie ograniczeń
								class Meta:
									model=Account
									fields = ['email','username','password','password2']
									extra_kwargs ={                                   #nadawanie ograniczeń                             
										'password': {'write_only': True}
									}
								def save(self):
									account = Account(
										email=self.validated_data['email'],                                     
										username = self.validated_data['username'],
									)
									password = self.validated_data['password']
									password2 = self.validated_data['password2']
									if password !=password2:
										raise serializers.ValidationError(
																  {'password': 'Password must match'})
									account.set_password(password)
									account.save()
									return account
		*WE VIEWS.PY:
			*tworzysz api_view(['POST',]) a wewnątrz obiekt serializera któemu przypisujesz dane pobrane 
			 z requesta. Sprawdzasz metodą is_valid() serializera i w metodzie Response zwracasz status 
			 i słownik (albo z błędami albo z przypisanymi danymi):
							from .serializers import RegistrationSerializer
							from rest_framework import status
							from rest_framework.response import Response
							from rest_framework.decorators import api_view

							@api_view(['POST',])
							def registration_view(request):
								serializer = RegistrationSerializer(data=request.data)
								data={}
								if serializer.is_valid():
									account = serializer.save()
									data['response'] = "succesfully registersa new user"
									data['email'] = account.email
									data['username'] = account.username
									s = status.HTTP_201_CREATED
								else:
									data = serializer.errors
									s = status.HTTP_400_BAD_REQUEST
								return Response(data=data, status = s)
		*W URLS.PY:
			*dla żądania POST ścieżka nie może kończyć się slashem (zarówno w urls.py i w postmanie)
							from django.urls import path
							from account.api.views import registration_view
							urlpatterns = [
								path('register', registration_view, name = 'register'),
							]							
							
===========================================================================================================
6)DJANGO REST FRAMEWORK - PODSTAWY:						
	7. MODELOWE PODEŚCIE DO API:
		*W URLS.PY
			**musisz pamiętać że ścieżka odwołująca się do funkcji we views wysyłającej żądanie POST 
			  nie może kończyć się slashem !!! (inaczej nie zadziała):
			**również przy wywoływaniu w postmanie wywołuj tę ścieżkę (create) bez slasha na końcu!!!
							urlpatterns = [
								path("<slug:slug>/", api_detail_blog_view, name="detail"),
								path("<slug:slug>/update/", api_update_blog_view, name="update"), 
								path("<slug:slug>/delete/", api_delete_blog_view, name="delete"),
								path("create", api_create_blog_view, name="create"),    
							]
		*W SERIALIZERS.PY:
							from rest_framework import serializers
							from blog.models import BlogPost
							class BlogPostSerializer(serializers.ModelSerializer):
								class Meta:
									model = BlogPost
									fields = ['title', 'body', 'image', 'date_updated' ]
		*WE VIEWS.PY:									
							from rest_framework import status
							from rest_framework.response import Response
							from rest_framework.decorators import api_view

							from .serializers import BlogPostSerializer
							from blog.models import BlogPost, Account
							from django.contrib.auth.decorators import login_required
							
							from rest_framework.permissions import IsAuthenticated
							from rest_framework.pagination import PageNumberPagination
							from rest_framework.filters import SearchFilter, OrderingFilter
							from rest_framework.generics import ListAPIView
							from rest_framework.authentication import TokenAuthentication
							class ApiBlogListView(ListAPIView):
								queryset = BlogPost.objects.all()
								serializer_class = BlogPostSerializer
								authentication_classes = (TokenAuthentication,)
								permission_classes = (IsAuthenticated,)
								pagination_class = PageNumberPagination
								page_size = 2
								filter_backends = (SearchFilter, OrderingFilter)
								search_fields = ('^title','body', '=author__username','author__email')
							
							@api_view(['GET',])
							def api_detail_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="GET":
									serializer = BlogPostSerializer(blog_post)
									return Response(serializer.data, status=status.HTTP_200_OK)
							
							@login_required(login_url='login')
							@api_view(['PUT',])
							def api_update_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="PUT":
									serializer = BlogPostSerializer(blog_post, data=request.data)
									data={}
									if serializer.is_valid():
										serializer.save()
										data["success"] = "update successful"
										return Response(data=data)
									return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
							
							@login_required(login_url='login')
							@api_view(['DELETE',])
							def api_delete_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="DELETE":
									operation=blog_post.delete()
									data={}
									if operation:
										data["success"] = "delete successful"
									else:
										data["failure"] = "delete failed"
									return Response(data=data)

							@login_required(login_url='login')
							@api_view(['POST',])
							def api_create_blog_view(request):
								account = Account.objects.get(pk=1)
								blog_post = BlogPost(author=account.user)
								if request.method == 'POST':
									serializer = BlogPostSerializer(blog_post, data = request.data )
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status = status.HTTP_201_CREATED)
									return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

	6.PAGINATION oraz WYSZUKIWARKA SEARCHFILTER (FILTERING) w LISTVIEW:
		*https://www.django-rest-framework.org/api-guide/pagination/
		*https://www.django-rest-framework.org/api-guide/filtering/#searchfilter
		*w SETTINGS.PY 
			*ustawiasz domyślną klasę dla wszystkich klas zwracających listę dla żądania 'GET' (zamiast 
			 tego możesz wszystko skonfigurować w class-based-views we views.py (oprócz PAGE_SIZE))
						REST_FRAMEWORK = {
							...
							'DEFAULT_PAGINATION_CLASS':'rest_framework.pagination.PageNumberPagination',
							'PAGE_SIZE':2,
		*WE VIEWS.PY:
			*pagination i searchfilter najłatwiej zrobic tworząc dla GET LISTa class-based-views.
			*w ramach konfiguracji PAGINATION konfigurujesz pola pagination_class odpowiadajce za 
			 pagination oraz page_size odpowiadające za ilość obiektów wyświetlonych w liście, 
			*w ramach konfiguracji WYSZUKIWARKI SEARCHFIELDS konfigurujesz pola filter_backends (do 
			 którego przypisujesz krotkę z klas SearchFilter i OrderingFilter) oraz search_fields
			 gdzie wpisujesz pola po których ma być wyszukiwany dany obiekt
				**pola muszą być związane z klasą w pliku serializers.py
				**pola muszą być typu TextField albo CharField - jeżeli są instancjami obiektów to 
				  poprzez podwójny podkreślnik '__' można wypisać ich pola 
				**można podać tez przed polami znaki: '^','='.'$' oznaczających '^'(rozpoczynanie
				  wyszukiwania, '='(dokładne dopasowanie),'$'(wyszukiwanie po regexie)
						from rest_framework.permissions import IsAuthenticated
						from rest_framework.pagination import PageNumberPagination
						from rest_framework.filters import SearchFilter, OrderingFilter
						from rest_framework.generics import ListAPIView
						from rest_framework.authentication import TokenAuthentication
						class ApiBlogListView(ListAPIView):
							queryset = BlogPost.objects.all()
							serializer_class = BlogPostSerializer
							authentication_classes = (TokenAuthentication,)
							permission_classes = (IsAuthenticated,)
							pagination_class = PageNumberPagination
							page_size = 2
							filter_backends = (SearchFilter, OrderingFilter)
							search_fields = ('^title','body', '=author__username','author__email')
				*na tej podstawie możemy stworzyć ścieżkę do API składającą się z:
					**ścieżki podstawowej do listy (oraz zmiennych po znaku zapytania):
								http://127.0.0.1:8000/api/blog/list
					**zmiennej page (od pagination)	
								http://127.0.0.1:8000/api/blog/list?page=2
					**zmiennej search (od searchfilter) używanej z '+' jako spacja:
								http://127.0.0.1:8000/api/blog/list?page=2&search=body+of+my
					**zmiennej ordering odpowiedzialnej za wyświetlenie listy w danej kolejności:
								http://127.0.0.1:8000/api/blog/list?search=body+of&ordering=-date_uptaded
			*poprzez żądanie 'GET' zostanie zwrócona słownik JSON zawierający klucze: z ilością 
			 wszystkich obiektów -'count', ściężką do następnej/poprzedniej strony -'next'/'previous'
			 oraz wszystkimi wynikami -'results':
						{
							"count": 3,
							"next": "http://127.0.0.1:8000/api/blog/list?page=2",
							"previous": null,
							"results": [
								{
									"title": "my_new_title",
									"body": "is body of my new",
									"image": "http://127.0.0.1:8000/blog_images/331050936_s_MbFrqNA.jpg",
									"date_updated": "2022-04-21T13:51:09.898767Z",
									"username": "marek"
								},
								{
									"title": "my_title",
									"body": "thi is body of my new title",
									"image": "http://127.0.0.1:8000/blog_images/331050936_s_Q2kMpcx.jpg",
									"date_updated": "2022-04-21T14:03:06.990520Z",
									"username": "marek"
								}
							]
						}
		*W URLS.PY:
			*dodajesz scieżkę do zwracania całej listy:
						from .views import ApiBlogListView
						urlpatterns = [
							...
							path("list", ApiBlogListView.as_view(), name = "list"),
						]
	
	5.AUTHENTICATION & PERMISSIONS & RESTRICTED ROUTE:
		*PODSTAWY:
			*https://www.django-rest-framework.org/api-guide/permissions/#setting-the-permission-policy
			*w przypadku nieautoryzowanego dostępu są 2 błędy pasujące do tego typu działania:
				HTTP 401 Unauthorized
				HTTP 403 Permission Denied
		*WERYFIKACJA poprzez RESTRICTED ROUTE:
			**zamiast authentyfikacji i nadania zezwoleń przez @permission_classes(IsAuthenticated, )
			  możesz udekorować funkcje nad dekoratorem żądania '@api_view' do dodatkowej weryfikacji,
			  czyli: '@login_required(login='loginPage'):
							from rest_framework import status
							from rest_framework.response import Response
							from rest_framework.decorators import api_view
							from django.contrib.auth.decorators import login_required
							
							@login_required(login_url='login')
							@api_view(['GET',])
							def api_detail_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								if request.method =="GET":
									serializer = BlogPostSerializer(blog_post)
									return Response(serializer.data, status=status.HTTP_200_OK)
		*DZIAŁANIE we VIEWS.PY - authentykacje i zezwolenia (permissions) można zrobic na 3 sposoby:
			***wpisując w settings.py ogólną authentykacji / permission dla wszystkich funkcji:
						REST_FRAMEWORK = {
							'DEFAULT_AUTHENTICATION_CLASSES': [
								'rest_framework.authentication.BasicAuthentication',
								'rest_framework.authentication.SessionAuthentication',
							],
							'DEFAULT_PERMISSION_CLASSES': [						#NIE podawaj domyślnej 
								'rest_framework.permissions.IsAuthenticated',	#klasy ZEZWOLEN bo do
								]												#każdej funkcji będziesz 
							}													#musiał podawać token do 
						}														#autoryzacji:
			***w function-basedview poprzez dekoratory(@authentication_classes i @permission_classes)
						from rest_framework.decorators import (api_view, permission_classes, 
															   authentication_classes)
						from rest_framework.authentication import (SessionAuthentication, 
																   BasicAuthentication)
						from rest_framework.permissions import IsAuthenticated
						@api_view(['GET'])
						@authentication_classes([SessionAuthentication, BasicAuthentication])
																	#sprawdza albo jedną albo drugą
						@permission_classes([IsAuthenticated])
						def example_view(request, format=None):
							...
			***w class-based-views przesłaniając pola authentication_classes i permission_classes:
						from rest_framework.authentication import (SessionAuthentication, 
																   BasicAuthentication)
						from rest_framework.permissions import IsAuthenticated
						class ExampleView(APIView):
							authentication_classes = [SessionAuthentication, BasicAuthentication]
																	#sprawdza albo jedną albo drugą
							permission_classes = [IsAuthenticated]				
							...
		*RODZAJE AUTHENTYFIKACJI (BasicAuthentication, TokenAuthentication, SessionAuthentication):
			*BasiAuthentication 
					**(wraz z zezwoleniem permission_classes = IsAuthenticated)
					**używane tylko podczas produkcji - nie wolno stosować go już w deployment'cie
					**potrzebna jest podstawowa weryfikacja (username i password)			
			*SessionAuthentication 
					**(wraz z zezwoleniem permission_classes = IsAuthenticated)
					**zalecane dla aplikacji webowych typu AJAX, korzysta z domyślnego Django session 
					  backend wykorzystuję się zazwyczaj z BasicAuthentication	
						authentication_classes = [SessionAuthentication, BasicAuthentication]
					**musisz dodać do urls:
						path('auth/', include('rest_framework.urls'))
			*TokenAuthentication:
					**(wraz z zezwoleniem permission_classes = IsAuthenticated)
					**zalecane dla aplikacji natywnych tj na konkretny system, np: android, ios
				*W SETTINGS.PY:
					*instalacja pipem 'rest_framework.authtoken' i migracja tego:
							pip install django-rest-authtoken
							python manage.py migrate
					*do INSTALLED_APPS dodajesz 
							INSTALLED_APPS = [
								...
								'rest_framework.authtoken',
							]			
					*od teraz pojawi ci się dodatkowy klasa/model w adminie o nazwie 'Token'
				*W MODELS.PY:
					*żeby Token tworzył się automatycznie podczas tworzenia użytkownika towrzysz sygnał 
					 do utworzenia Tokenu (klasa Token z rest_framework.authtoken.models) przy tworzeniu 
					 konta użytkownika (User / klasa Account wskazana w zmiennej settings.AUTH_USER_MODEL). 
					 Dla klasy Token podajesz argument w postaci tego kto jest właścicielem tokenu:
							from django.conf import settings
							from django.db.models.signals import post_save
							from django.dispatch import receiver
							from rest_framework.authtoken.models import Token

							@receiver(post_save, sender = settings.AUTH_USER_MODEL)
							def create_auth_token(sender, instance=None, created=False, **kwargs):
								if created:
									Token.objects.create(user=instance)
				*W URLS.PY:
					*importujesz funkcje obtain_auth_token z rest_framework.authtoken.views która zwraca 
					 z tabeli Token: auth_token danego użytkownika.
					*dla ścieżki 'my_obtain' i żądania 'POST' zostaje wywołana funkcja: obtain_auth_token 
					 która pobiera z requesta 2 parametry: 'username' i 'password' (mimo tego że w 
					 models.py dla klasy dziedziczącej po AbstractBaseUser w zmiennej USERNAME_FIELD 
					 podałeś 'email' to przy metodzie obtain_auth_token musisz podać w parametrach 
					 nazwę 'username' (zamiast 'email'). 
							from django.urls import path
							from rest_framework.authtoken.views import obtain_auth_token
							urlpatterns = [
								path('my_obtain', obtain_auth_token, name = 'my_obtain'),
							]							
				*WE VIEWS.PY:
							from rest_framework import status
							from rest_framework.response import Response
							from .serializers import BlogPostSerializer
							
							from rest_framework.decorators import api_view, permission_classes
							from rest_framework.permissions import IsAuthenticated
							
							@api_view(['PUT',])
							@permission_classes((IsAuthenticated, ))
							def api_update_blog_view(request, slug):
								try:
									blog_post = BlogPost.objects.get(slug=slug)
								except BlogPost.DoesNotExist:
									return Response(status = status.HTTP_404_NOT_FOUND)
								user = request.user
								if blog_post.author != user:
									return Response({'response':"You don't have permission to edit that"}) 
								if request.method =="PUT":
									serializer = BlogPostSerializer(blog_post, data=request.data)
									data={}
									if serializer.is_valid():
										serializer.save()
										data["success"] = "update successful"
										return Response(data=data)
									return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
					*możesz pobierać Token:
							account = Account.objects.get(id=1)
							data={}
							data['token'] = Token.object.get(user=account).key
					*możesz nadawać funkcjom ZEZWOLENIA ('PERMISSIONS'):
						*przed funkcjom dodajesz dekorator: 
							@permission_classes((IsAuthenticated, ))
						*jeżeli zależy Tobie żeby oprócz tego żeby użytkownik miał autoryzacje (był 
						 zalogowany) to jeszcze był autorem utworzone obiektu to dodajesz:
							user = request.user
							if blog_post.author != user:
								return Response({'response':"You don't have permission to edit that"}) 
					*(w POSTMANIE dla POST w Headers podajesz parametr:
					 {'Authorization': 'Token wartość_klucza'})
	
	4.DOSTĘPNOŚĆ CORS-HEADERS:
			*)https://github.com/adamchainz/django-cors-headers
			a)instalujesz cors-headers:
							python -m pip install django-cors-headers
			b)w głównej app/funkc w settings.py:
				*w sekcji INSTALLED_APPS dodajesz "corsheaders":
							INSTALLED_APPS = [
								"corsheaders", 
								...,
							]
				*w sekcji MIDDLEWARE dodajesz "corsheaders.middleware.CorsMiddleware":
							MIDDLEWARE = [
							"corsheaders.middleware.CorsMiddleware",
								...,
							]
				*na samym dole ustwiasz jedną z trzech zmiennych 
					*CORS_ALLOW_ALL_ORIGINS = True  - wskazujesz że wszystkie storny mogą mieć dostęp
					*CORS_ALLOWED_ORIGINS - wskazujesz które konkretne strony mogą mieć dostęp
					*CORS_ALLOWED_ORIGIN_REGEXES - wskazujesz regexa pasujących stron mogących mieć dostęp
			c)dzięki tym ustawieniom pliki javascript będą mieć dostęp do danych przesyłanych przez API, np:
							<!DOCTYPE html>
							<html lang="en">
							<head>
								<meta charset="UTF-8">
								<meta http-equiv="X-UA-Compatible" content="IE=edge">
								<meta name="viewport" content="width=device-width, initial-scale=1.0">
								<title>Document</title>
							</head>
							<body>
								<h1>Cool rooms</h1>
								<div id ="rooms-container">

								</div>
							</body>
							<script>
								let roomsContainer = document.getElementById('rooms-container')
								let getRooms = async () =>{
									let response = await fetch('http://127.0.0.1:8000/api/rooms/')
									let rooms = await response.json()
									//console.log("RESPONSE: ", response)
									//console.log("rooms:", rooms)
									for(let i=0; rooms.length>i; i++){
										let room = rooms[i]
										let row = `<div>
														<h3>${room.name}</h3>
													</div>`
										roomsContainer .innerHTML += row
									}
								}
								getRooms()
							</script>
							</html>
							
	3.OGÓLNE DZIAŁANIE we VIEWS.PY (opcja 2.2 uzywana docelowo):
		0**PODSTAWY:
			*chcąc utworzyć API dla danej app/funkc utwórz wewnątrz folder 'api' gdzie umieścisz pliki: 
			 urls.py, views.py, serializers.py (będą to dodatkowe pliki do logiki - inne niż views.py, 
			 urls.py umieszczone bezpośrednio w folderze danej app/funkc. ) Ponadto tworząć nowy folder 
			 'api' pamiętaj o utworzeniu wewnątrz tego folderu pustego pliku '__init__.py'
			*ŻĄDANIA: GET -detailView i listView, POST -createView, PUT -updateView, DELETE -deleteView
		1**OPCJA PIERWSZA - BEZ WYKORZYSTANIA rest_framework'a:
				*wykorzystujesz wysyłanie plików Json poprzez JsonResponse
				*dla danych przychodzących w żądaniu POST i PUT korzystasz z: JSONParser().parse(request)
				 by je sparsować z typu JSON na text. Następnie je serializujesz.
				*dla żądań PUT i POST by podtrzymać sesje korzystasz z dekoratora @csrf_token (gdyż 
				 normalnie musiałbyś wysłać najpierw żądanie GET, pobrać csrf_token a później w HEADERS
				 dołączyć go do żądania POST/PUT:
			*OPCJA 1.1 - serializujesz poprzez metodę serialize() 
				*w serialize() nie można wysyłać obiektów Pythona tylko te z ORM
				*w JsonResponse 'safe=False' pozwala na podanie listy do argumentu zamiast słownika
					#przykład 1:
							from django.http import JsonResponse
								lst = ["1", "2"]
								return JsonResponse(lst, safe=False)
					#przykład 2:
							from django.http import JsonResponse
							import json
							from django.core.serializers import serialize
							def getRooms(request):
								rooms = Room.objects.all()
								rooms_serialize = json.loads(serialize('json',rooms))
								return JsonResponse(rooms_serialize, safe=False) 
			*OPCJA 1.2 - serializator w pliku serializers.py
				*w serializers.py:
							from rest_framework import serializers
							from .models import Article
							class ArticleSerializer(serializers.ModelSerializer):
								class Meta:
									model = Article
									fields  = ['id','title', 'author']					
				*we views.py
							from django.http import HttpResponse, JsonResponse
							from rest_framework.parsers import JSONParser
							from django.views.decorators.csrf import csrf_exempt
							@csrf_exempt
							def article_list_and_create(request):
								if request.method == 'GET':
									articles = Article.objects.all()
									serializer = ArticleSerializer(articles, many=True)
									return JsonResponse(serializer.data, safe=False)
								elif request.method =='POST':
									data = JSONParser().parse(request)
									serializer = ArticleSerializer(data=data)
									if serializer.is_valid():
										serializer.save()
										return JsonResponse(serializer.data, status = 201)
									return JsonResponse(serializer.errors, status = 400)
							@csrf_exempt
							def article_detail_update_delete(request,pk):
								try:
									article = Article.objects.get(pk=pk)
								except Article.DoesNotExist:
									return HttpResponse(status = 404)
								if request.method == 'GET':
									serializer = ArticleSerializer(article)
									return JsonResponse(data = serializer.data)
								elif request.method == 'PUT':
									data = JSONParser().parse(request)
									serializer = ArticleSerializer(article, data=data)
									if serializer.is_valid():
										serializer.save()
										return JsonResponse(serializer.data, status = 201)
									return JsonResponse(serializer.errors, status = 400)
								elif request.method == 'DELETE':
									article.delete()
									return HttpResponse(status = 200)
									
		2**OPCJA DRUGA - WYKORZYSTUJESZ FUNCTION-BASED-VIEWS w rest_framework'u:
				*przypisujesz dekorator @api_view, w którym precyzujesz żądania: GET, POST, PUT, DELETE 
				*dla żądań PUT i POST parsowanie danych (z typu JSON na text) ,które robiłes poprzez 
				 'JSONParser().parse(request)' wykonuję dekorator @api_view
				*dla żądań PUT i POST z serializera koszystasz jak z formularza. Przekazujesz dane, 
				 robisz walidację dla obiektu serializatora (if serializer.is_valid()) i następnie 
				 wywołujesz save() dla serializatora tworząc nowy obiekt bazowy (dla modelu związanego 
				 z serializatorem)
				*zamiast JsonResponse (from django.http) zwracasz Response (from rest_framework.reponse)
				 który zwraca dane lub błędy (serailizer.data i serializer.errors) oraz status  
				 (from django.rest_framework import status). Są to m.in statusy takie jak:
					*status.HTTP_200_OK
					*status.HTTP_201_CREATED
					*status.HTTP_400_BAD_REQUEST
					*status.HTTP_404_NOT_FOUND
				*argument 'many=True' oznacza że będzie serializacja listy a nie pojedyńczego obiektu
								serializer = ArticleSerializer(articles, many=True)
			*OPCJA 2.1 - serializujesz poprzez metode serialize():
				*w serialize() nie można wysyłać obiektów Pythona tylko te z ORM
							from rest_framework.decorators import api_view
							from rest_framework.response import Response
							from django.core.serializers import serialize
							@api_view(['GET'])
							def getRooms(request):
								rooms = Room.objects.all()
								serializer = serialize('json',rooms)
								return Response(serializer)
			*OPCJA 2.2 (POWSZECHNIE UŻYWANA)- serializator w serializers.py:
				*w serializers.py:
							from rest_framework import serializers
							from .models import Article
							class ArticleSerializer(serializers.ModelSerializer):
								class Meta:
									model = Article
									fields  = ['id','title', 'author']		
				*we views.py:
							from rest_framework.decorators import api_view
							from rest_framework.response import Response
							from rest_framework import status

							@api_view(['GET','POST',])
							def article_list_view(request):
								if request.method == 'GET':
									articles = Article.objects.all()
									serializer = ArticleSerializer(articles, many=True)
														#arg ' many=True ' oznacza że będzie serializacja 
														#więcej niż jednego obiektu (cała lista/zbiór)
									return Response(serializer.data, status=status.HTTP_200_OK)
								elif request.method =='POST':
									serializer = ArticleSerializer(data=request.data)
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status =status.HTTP_200_OK)
									return Response(serializer.errors, status =status.HTTP_400_BAD_REQUEST)
							@api_view(['GET','PUT','DELETE',])
							def article_detail_view(request,pk):
								try:
									article = Article.objects.get(pk=pk)
								except Article.DoesNotExist:
									return Response(status =status.HTTP_404_NOT_FOUND )
								if request.method == 'GET':
									serializer = ArticleSerializer(article)
									return Response(serializer.data, status =status.HTTP_200_OK)
								elif request.method == 'PUT':
									serializer = ArticleSerializer(article, data=request.data)
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status =status.HTTP_200_OK)
									return Response(serializer.errors, status =status.HTTP_400_BAD_REQUEST)
								elif request.method == 'DELETE':
									article.delete()
									return Response(status =status.HTTP_200_OK)
					*dodatkowo (nie jest to wymagane) możesz stworzyć legende dla wszystkich ścieżek w api:
							@api_view(['GET'])     
							def getRoutes(request):
								routes = [
									'GET /api/article/',
									'GET /api/article/:id/',
								]
								return Response(routes)
								
		3**OPCJA TRZECIA - CLASS-BASED-VIEWS w rest_framework'u:
				*w serializers.py:
							from rest_framework import serializers
							from .models import Article
							class ArticleSerializer(serializers.ModelSerializer):
								class Meta:
									model = Article
									fields  = ['id','title', 'author']		
				*w urls.py:
					*dla opcji 3.1 APIView i 3.2 GenericAPIView & mixinsprzez - mimo że masz 1dną klasę 
					 dla wszystkich żądań to i tak musisz stworzyć 2 ścieżki - bez i z identyfikatorem id
					*dla opcji 3.3 OSOBNE GenericAPIView - przez to że masz każdą klasę osobna to dla 
					 każdej klasy tworzysz odpowiednią ścieżki:
							urlpatterns =[
						#dla OPCJI 3.1 - APIView:
								path('classBasedViewArticle/', ArticleApiView.as_view()),
								path('classBasedViewArticle/<int:id>/', ArticleApiView.as_view()),
						#dla OPCJI 3.2 - GenericAPIView & mixins:
								path('genericsMixins/', GenericAPIView.as_view()),
								path('genericsMixins/<int:pk>/', GenericAPIView.as_view()),
						#dla OPCJI 3.3 - OSOBNE GenericAPIView:
								path('list/', ListApiView.as_view()),
								path('create/', CreateApiView.as_view()),
								path('detail/<int:id>/', DetailApiView.as_view()),
								path('update/<int:id>/', UpdateApiView.as_view()),
								path('delete/<int:id>/', DeleteApiView.as_view()),								
							]
			*OPCJA 3.1 - APIView:
					*tworzysz klasę dziedzczącą po APIView (rest_framework.views) i przesłaniasz te metody 
					 dla których chesz by dane żądania działały: get(), post(), put(), delete()
				*we views.py:
							from rest_framework.response import Response
							from rest_framework import status
							from rest_framework.views import APIView
							class ArticleApiView(APIView):
								def get_object(self, id):
									try:
										return Article.objects.get(pk=id)
									except Article.DoesNotExist:
										return Response(status=status.HTTP_404_NOT_FOUND)
								def get(self, request, id=None):
									if id:
										article = self.get_object(id)
										serializer = ArticleSerializer(article)
										return Response(serializer.data)
									else:
										articles = Article.objects.all()
										serializer = ArticleSerializer(articles, many=True)
										return Response(serializer.data, status =status.HTTP_200_OK)
								def post(self, request):
									serializer = ArticleSerializer(data=request.data)
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status =status.HTTP_200_OK)
									return Response(serializer.errors, status =status.HTTP_400_BAD_REQUEST)
								def put(self,request, id):
									article = self.get_object(id)
									serializer = ArticleSerializer(article, data=request.data)
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status =status.HTTP_200_OK)
									return Response(serializer.errors, status =status.HTTP_400_BAD_REQUEST)
								def delete(self, request, id):
									article = self.get_object(id)
									try:
										article.delete()
									except:
										data ={'failure':'Object is not exist'}
										return Response(data, status=status.HTTP_404_NOT_FOUND)
									else:
										data ={'succesc':'Object deleted'}
										return Response(data, status =status.HTTP_200_OK)
			*OPCJA 3.2 -  GenericAPIView CLASS-BASED-VIEWS and MIXINS:
					*tworzysz klasę dziedzczącą po GenericAPIView (rest_framework.generics) oraz 
					 wszystkich mixins'ach dla których chcesz by dane żądania działały:
						GET (LIST) - mixins.ListModelMixin, 
						POST (CREATE) - mixins.CreateModelMixin,
						GET (DETAIL) - mixins.RetrieveModelMixin,
						PUT (UPDATE) - mixins.UpdateModelMixin,
						DELETE (DELETE) - mixins.DestroyModelMixin
					*wewnątrz przesłaniasz metody odpowiadające odpowiednim mixins'om: get(), post(), 
					 put(), delete(). W tych metodach uruchamiasz metody z mixinsów:
						dla get() - self.list(request) oraz self.retrieve(request, pk)
						dla post() - self.create(request)
						dla put() - self.update(request, pk)
						dla delete() - self.destroy(request, pk)					
				*we views.py:
							from rest_framework import generics
							from rest_framework import mixins
							class GenericAPIView(generics.GenericAPIView, 
														mixins.ListModelMixin, 
														mixins.CreateModelMixin,
														mixins.RetrieveModelMixin,
														mixins.UpdateModelMixin,
														mixins.DestroyModelMixin):
								serializer_class = ArticleSerializer
								queryset = Article.objects.all()
															###jeżeli nie 'pk' tylko np 'id' w urls.py 
															###to tworzysz zmienną: lookup_field = 'id'
								def get(self, request, pk=None):
									if id:
										return self.retrieve(request, pk)
									else:
										return self.list(request)
								def post(self, request):
									return self.create(request)
								def put(self, request, pk=None):
									return self.update(request, pk)
								def delete(self, request, pk=None):
									return self.destroy(request, pk)
			*OPCJA 3.3 - OSOBNE GENERICS CLASS-BASED-VIEWS:
					*dziedziczą po GenericAPIView oraz po konkretnych mixins'ach dzieki czemu są 
					 dostarczone domyślne metody get(), post(), put(), delete() i wystarczy tylko 
					 skonfigurować odpowiednie pola:
						*class_serializer = ArticleSerializer
									- wskazujesz klasę któa będzie wykorzystana do serializera
						*queryset = Article.objects.all()			 
									- wskazujesz pobranie wszystkich danych z modelu
						*lookup_field = 'id' 
									- wskazujesz nazwę identyfikatora dla detail, update, delete, 
						*authentication_classes = (TokenAuthentication,)
									- zmienna odpowidzialna za atuoryzację
						*permission_classes = (IsAuthenticated,)
									- wskazujesz typ autoryzacji
						*filter_backends = (SearchFilter, OrderingFilter)
									- zmienna związana z searchfield (patrz --> PAGINATION I SEARCHFIELD)
						*search_fields = ('^title','body', '=author__username','author__email')
									- wskazujesz po jakich polach ma być wyszukiwarka
						*pagination_class = PageNumberPagination
									- tylko dla list (patrz --> PAGINATION I SEARCHFIELD)
						*page_size = 2
									- tylko dla list - wskazujesz ilość zwracanych obiektó w liście
					*dla każdej klasy tworzysz odpowiednie ścieżki:
						path('list/', ListApiView.as_view()),
						path('create/', CreateApiView.as_view()),
						path('detail/<int:id>/', DetailApiView.as_view()),
						path('update/<int:id>/', UpdateApiView.as_view()),
						path('delete/<int:id>/', DeleteApiView.as_view()),
				*we views.py:
							from rest_framework.generics import (ListAPIView, 
																 CreateAPIView,
																 RetrieveAPIView,
																 UpdateAPIView,
																 DestroyAPIView)
							class ListApiView(ListAPIView):
								serializer_class = ArticleSerializer
								queryset = Article.objects.all()
							class CreateApiView(CreateAPIView):
								queryset = Article.objects.all()
								serializer_class = ArticleSerializer
							class DetailApiView(RetrieveAPIView):
								queryset = Article.objects.all()
								serializer_class = ArticleSerializer
								lookup_field='id'
							class UpdateApiView(UpdateAPIView):
								queryset = Article.objects.all()
								serializer_class = ArticleSerializer
								lookup_field='id'
							class DeleteApiView(DestroyAPIView):
								queryset = Article.objects.all()
								serializer_class = ArticleSerializer
								lookup_field='id'	
								
		4**OPCJA CZWARTA - VIEWSETS & ROUTERS w rest_framework'u:
					*działają tak samo jak class-based-vews ale zamiast metod jak get() i post() 
					 dostarczają  takie metody jak list(), retrieve(), create(), update(), destroy()
				*w urls.py:
					*poprzez wykorzystanie Router'ów inaczej wygląda przechodzenie po ścieżkach - zamiast
					 tworzyć 2 ścieżki dla klasy (ścieżkę z identyfikatorem (retrieve, update, destroy) i 
					 bez niego (list, create)) tworzysz jedną ścieżkę i router powoduję że możesz chodzić 
					 po innych ścieżkach po identyfikatorach:
					*ścieżka w routerze nie może się kończyć slashem '/'
						*w urls.py tworzysz router:
							from rest_framework.routers import DefaultRouter
							router = DefaultRouter()
							router.register('article', ArticleViewSet, basename = 'article')
							router.register('genericArticle', ArticleGenericViewSet, basename = 'generic')
							router.register('modalArticle', ArticleModalViewSet, basename = 'modal')
						*w urls.py tworzysz ścieżke:
							urlpatterns =[
								...
								path('viewset/', include(router.urls)),
							]
						*i chodzisz po ścieżkach wg identyfikatorów id (przykład dla opcji 4.1 ViewSet):
									'viewset/' --> 'viewset/article/'--> 'viewset/article/2/' 
			*OPCJA 4.1 - ViewSet:
					**dziedziczy po ViewSet i musisz przesłonić metody (te które chcesz wykorzystać) 
					  z grupy metod: list(), create(), retrieve(), update(), destroy()
					**żeby pobrać konkretną instancję użyj get_object_or_404()
				*we views.py:
							from rest_framework import viewsets
							from django.shortcuts import get_object_or_404
							class ArticleViewSet(viewsets.ViewSet):
								def list(self, request):
									articles = Article.objects.all()
									serializer = ArticleSerializer(articles, many=True)
									return Response(serializer.data)
								def create(self, request):
									serializer = ArticleSerializer(request.data)
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status=status.HTTP_201_CREATED)
									return Response(serializer.data, status=status.HTTP_400_BAD_REQUEST)
								def retrieve(self, request, pk=None):
									queryset = Article.objects.all()
									article = get_object_or_404(queryset, pk=pk)
									serializer = ArticleSerializer(article)
									return Response(serializer.data)
								def update(self, request, pk=None):
									queryset = Article.objects.all()
									article = get_object_or_404(queryset, pk=pk)
									serializer = ArticleSerializer(article, data=request.data)
									if serializer.is_valid():
										serializer.save()
										return Response(serializer.data, status =status.HTTP_200_OK)
									return Response(serializer.data, status=status.HTTP_400_BAD_REQUEST)
								def destroy(self, request, pk=None):
									queryset = Article.objects.all()
									article = get_object_or_404(queryset, pk=pk)
									try:
										article.delete()
									except:
										data ={'failure':'Object is not exist'}
										return Response(data, status=status.HTTP_404_NOT_FOUND)
									else:
										data ={'success':'Object deleted'}
										return Response(data, status =status.HTTP_200_OK)					
			*OPCJA 4.2 - GenericViewSet & mixins
					**klasa dziedziczy po GenericViewSet i mixins'ach -> musisz przesłonić odpowiednie 
					  pola tak samo jak w osobnych class-based-views. Przede wszystkim pola queryset i 
					  serializer_class
				*we views.py:
							from rest_framework import viewsets
							from rest_framework import mixins
							class ArticleGenericViewSet(viewsets.GenericViewSet,
														mixins.ListModelMixin, 
														mixins.CreateModelMixin,
														mixins.RetrieveModelMixin,
														mixins.UpdateModelMixin,
														mixins.DestroyModelMixin):
								serializer_class = ArticleSerializer
								queryset = Article.objects.all()
			*OPCJA 4.3 - ModelViewSet :
					**ModelViewSet dziedziczy po GenericViewSet i po wszystkich mixins'ach więc wystarczy
					  tylko skonfigurować pla queryset i serializer_class
							from rest_framework import viewsets
							class ArticleModelViewSet(viewsets.ModelViewSet):
								serializer_class = ArticleSerializer
								queryset = Article.objects.all()
	2.SERIALIZERS.PY:
		1*RODZAJE:
			A) Z ROZWINIĘCIEM KAŻDEGO POLA i MOŻLIWOŚĆIĄ NAŁOŻENIA OGRANICZEŃ NA POLA
						from rest_framework import serializers
						from blog.models import BlogPost
						class BlogPostSerializer(serializers.Serializer):
							title = serializers.CharField(max_length=50)
							body = serializers.CharField(max_length=200)
							image = serializers.ImageField()
							date_updated = serializers.DateTimeField(read_only=True)
			B) Z KLASĄ WEWNĄTRZNĄ i MOŻLIWOŚCIĄ NAŁOŻENIA OGRANICZEŃ NA POLA:
						from rest_framework import serializers
						from blog.models import BlogPost
						class BlogPostSerializer(serializers.ModelSerializer):
							date_updated = serializers.DateTimeField(read_only=True)
							class Meta:
								model = BlogPost
								fields = ['title', 'body', 'image', 'date_updated' ]
		2*METODY TWORZENIA:
			*https://www.django-rest-framework.org/api-guide/serializers/#saving-instances
			*we views.py podczas zapisywania obiektu serializatora zostanie wywołana metoda save() 
			 która jeżeli nie będzie przesłonieta wywoła metodę create lub update. (jeżeli w argumencie
			 serializatora podasz instancje obiektu bazowego dla serializatorem to zostanie wywołana 
			 metoda update a jeżeli nie to metoda create):
				**we views.py:
						serializer = BlogPostSerializer(data=request.data)				#metoda create
						blog1 = BlogPost(title=...)
						serializer = BlogPostSerializer(blog1, data=request.data)		#metoda update
						if serializer.is_valid():
							serializer.save()		#wywołanie save() i tym samym albo create albo update
			**partial=True oznacza że możesz wpisać część danych 
						serializer = BlogPostUpdateSerializer(blog_post, data=request.data, partial=True)
			*wewnątrz serializatora by uzyskać dane używasz validated_data['my_field'] albo 
			 self.validated_data['my_field'] albo request.POST.get(). Następnie zapisujesz obiekt 
			 utworzony lub update'towany i go zwracasz.
				**w serializers.py:
						class BlogPostSerializer(serializers.ModelSerializer):
							class Meta:
								model = BlogPost
								fields = ['title','body']				#'__all__'
							def create(self, validated_data):							
								b1 = BlogPost(
									title= validated_data['title'], 
									body= validated_data['body'],
									)
								b1.save()
								return b1
							def update(self, instance, validated_data): 
								instance.title = validated_data['title']
								instance.body = validated_data['body'])
								instance.save()
								return instance
			*metode save() też można przesłonić:
							def save(self):
								b1 = BlogPost(
									title= self.validated_data['title'], 
									body= self.validated_data['body'],
									)
								b1.save()
								return b1
		3*METODY WALIDACJI:
			*dla danych przychodzących (żądania PUT i POST) możesz zrobić własną walidacje w 
			 serializerze i podnieść wyjątek ValidationError
			*dla metody 'validate' zwracasz słownik 'data' a dla 'validate_<my_filed>' wartość pola:
				**w serializers.py:
							def validate(self, data):
								if data['start'] > data['finish']:
									raise serializers.ValidationError("finish must occur after start")
								return data
							def validate_title(self, value)
								if 'django' not in value.lower():
									raise serializers.ValidationError("Blog post is not about Django")
								return value				
			*uruchamiane podczas wywoływania metody 'is_valid()' we views.py:
				**we views.py:
							if serializer.is_valid():		#walidacja
								serializer.save()			#zapisanie danych pryzychodzących jako obiekt 
		4*serializers.SerializerMethodField()
			*pozwala na serializację danych które są w klasie serializowanej instancjami innych klas
			 (konkretnie chodzi o pola innych klas)
			*najpierw w klasie serializowanej dodajesz metodę która będzie przyjmować obiekt klasy
			 serializowanej. Wewnątrz pobierasz dane z bazy danych (pola z klasy będacej polem w klasie 
			 serializowanej) (def get_username_from_author)
			*następnie tworzysz pole dla Serilizera (username) i przypisujesz mu metodę 
			 serializers.SerializerMethodField() do której podajesz w arg w cudzysłowiach nazwę tej metody,
			 którą utworzyłeś przed chwilą (get_username_from_author)
			*na końcu dodajesz nazwę pola ('username') w klasie Meta w polu fields: 
				**w serializers.py:
						from rest_framework import serializers
						from blog.models import BlogPost
						class BlogPostSerializer(serializers.ModelSerializer):
							username = serializers.SerializerMethodField('get_username_from_author')
							class Meta:
								model = BlogPost
								fields = ['title', 'body', 'image', 'date_updated', 'username']
							def get_username_from_author(self, blog_post):
								username = blog_post.author.username
								return username
							
	1.INSTALACJE:
		*https://www.django-rest-framework.org/
		a)instalacja w konsoli:
							pip install djangorestframework  /  python -m pip install djangorestframework
							pip install markdown      		 /  python -m pip install markdown 
							pip install django-filter  		 /  python -m pip install django-filter
		  lub skopiowanie projektu:
							git clone https://github.com/encode/django-rest-framework
		b)w INSTALLED_APPS w settings.py w głównej app/funkc. dodajesz 'rest_framework'
							INSTALLED_APPS = [
								'rest_framework',
							]
		c)tworzysz nową app/funkc:
							python manage.py startapp api 
		  lub samemu zakłądasz folder który musi zawierać plik __init__.py, urls.py, views.py 

	0.POSTMAN:
		*PODSTAWY:
			**służy do testowania żądań w API
			**ustawiasz TYP ŻĄDANIA, uruchamiasz swój serwer, wpisujesz śćieżkę i klikasz 'SEND'
			**dla żądania POST wpisujesz argumenty do serializera w dziale danych wysyłanych w sekcji 
			  'BODY' we 'form-data' 
			**w przypadku ZEZWOLEŃ 'PERMISSIONS' musisz w sekcji 'Headers' dodać zmienną odpowiedzialną 
			  za autoryzacji i przypisać jej token wgschematu: {'Authorization': 'Token wartość_tokena')
						KEY:				VALUE:
						Authorization   	8a09c71f5ba4bda0e8a7c449164d8b58d85197f7
			**przy żądaniu 'POST' zarówno w ścieżka w URLS.PY jak i w postmanie musi byc BEZ slasha na 
			  końcu!!! Inaczej ścieżka wywoływana ścieżka będzie pokazywać błędy:
				**w URLS.PY:
						urlpatterns = [
							path("create", api_create_blog_view, name="create"),    
						]	
				**w POSTMAN'ie:
						http://127.0.0.1:8000/api/blog/create
		*SESJE dla FORMULARZY:
			**wszystkie formularze zbudowane w django (a nie te oparte o djangorestframework) wymagają
			  sporządzenia sesji czyli użycia zmiennej csrf_token
    		**wysyłasz POSTMAN'em żądanie GET na stronę logowania -> kopiujesz csrftoken z odebranych
			  danych z sekcji 'cookies' 
			**tworzysz w POSTMAN'ie żądanie POST na stronę logowania -> w danych do wysłania w sekcji 
			  'Headers' tworzysz zmienną: 'X-CSRFToken' i dajesz jej wartość w postaci skopiowanego
			  csrftoken'u z poprzedniego punktu. Wysyłasz żądanie. 		

============================================================================================================
5)TESTY:
	https://docs.djangoproject.com/en/4.0/intro/tutorial05/
	https://docs.djangoproject.com/en/4.0/topics/testing/
	0)PODSTAWY:
		a*w każdej app/funkc. jest plik test.py przeznaczony do testów
		b*Testy uruchamia się komendami:
					python manage.py test										#uruchamia wszystkie testy
					python manage.py test <app_name>
		c*w tests.py tworzysz klasy testów które musza dziedziczyć po klasie TestCase. Klasy testów służą 
		  testowaniu nie tylko funkcji w pliku views.py ale także pojedyńczych modeli z models.py.
		d*testy nie korzystają z ogólnej bazy danych (działającej przy developmentcie oraz produkcji) ale
		  na swojej własnej bazie danych dlatego w każdej klasie Testującej dziedziczącej po TestCase 
		  tworzysz funkcje setUp() w której tworzysz obiekty do bazy testującej:
					from .models import Article
					from django.test import TestCase
					class ArticleTestCase(TestCase):
						def setUp(self):
							a1 = Article.objects.create(title='Hello World', content='something else')
							self.my_title = a1.title			#poprzez 'self' możesz tworzyć zmienne 
																#do użycia w pozostałych metodach
						def test_quryset_exists(self):
							qs = Article.objects.all()
							self.assertTrue(qs.exists())	
							self.assertEqual(qs.first().title, self.my_title)
		e*testowanie robisz głównie przez asercje ale możesz testować też poprzez blok 'try except':
					import os 
					from django.contrib.auth.password_validation import validate_password
					class ainventoryCongfigTest(TestCase):
						def test_secret_key_strength(self):
							SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY')
							try:
								is_strong = validate_password(SECRET_KEY)
							except Exception as e:
								msg = f'Bad Secret key {e.messages}'
								self.fail(msg)
		f*testowanie możesz zawrzeć też w bloku with context - jeśli full_clean() wyrzuci błąd przy 
		  sprawdzeniu danych w utworzonym obiekcie (full_clean()) to test zostanie zaakceptowany:
				     def test_myObject(self):
						with self.assertRaises(ValidationError):
							ingredient = RecipeIngredient( name ="New", quantity = 10)
							ingredient.full_clean()					
	1)Testowanie pliku models.py:
		*Wewnątrz klas tworzysz funkcje które przez to że klasa dziedziczy po TestCase będą automatycznie 
		 uruchamiane po odpaleniu testów. Wewnątrz funkcji tworzysz asercje sprawdzające poprawność danych
					from django.test import TestCase
					from .models import Question						#pobierasz model 
					class QuestionModelTests(TestCase):					#klasa testów do testowania modelu
						def test_<name_function>_<that_testing>(self):
							"""opis testu"""
							q1 = Question(...)
							self.assertIs(q1.<name_function>(),False)	#czy porównanie zwróci False
	2)Testowanie pliku VIEWS.PY:
		a)testowanie pliku views.py w pliku test.py	
			*tak jak dla models tworzysz klasę testującą dziedziczącą po TestCase która testuję każdą 
			 funkcje/class-based-view z views.py. Wewnątrz  klasy testującej tworzysz funkcje testujące 
			 różne przypadki i w nich wykorzystujesz wbudowane pole client'a:
					from django.test import TestCase
					class QuestionIndexViewTest(TestCase):
						def test_no_question(self):
							response = self.client.get(reverse('index'))
							self.assertEqual(response.status_code, 200)
							self.assertContains(response, "No polls availble")	#odpowiada response.content
																				#sprawdza tekst w htmlu
							obj = Question(text='mama',pub_date=...)
							self.assertQuerySetEqual(response.context['klucz'],[obj.text])
		b)testowanie w konsoli:
			*w konsoli musisz zadbać o ustanowienie środowiska do testów:
					from django.test.utils import setup_test_environment
					setup_test_environment()	
			*w konsoli jest konieczność pobrania własnego Client'a imitującego klienta w przeglądarce
					from django.test import Client
					client = Client()
			*od teraz na danym kliencie możemy żadąc zwrócenie odpowiednich danych:
				*żądanie konkretnej strony po ścieżce:
					response = client.get('/')			#Not Found: /
					response = client.get('home/')
				*żadanie konkretnej strony po atrybucie 'name' w path:
					form django.url import reverse
					response = client.get(reverse('index'))
				*zwrócenie statusu strony:
					response.status_code 				#404 /200
				*zwrócenie HTMLa wyrenderowanej strony:
					response.content					#<li><a href="/polls/1/">Wha's up?</a></li>
				*zwrócenie przesyłanego słownika na stronę:
					response.context					#[...'klucz': <QuerySet [<Question: What's up>]>...]
					response.context['klucz']			#<QuerySet [<Question: What's up?>]>
	3)Testowanie haseł i SECRET_KEY - metoda validate_password z django.contrib.auth.password_validation 
					import os 
					from django.contrib.auth.password_validation import validate_password
					class ainventoryCongfigTest(TestCase):
						def test_secret_key_strength(self):
							SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY')
							try:
								is_strong = validate_password(SECRET_KEY)
							except Exception as e:
								msg = f'Bad Secret key {e.messages}'
								self.fail(msg)
	4)Rzeczy dodatkowe odróżniające zwykłe testy od testów w Django:
		*testująca klasa dziedziczy po klasie Testcase z django.test a nie z unittest
					from django.test import TestCase
		*klasa TestCase dostarcza pole client które pozwala na imitowanie klienta i żądanie stron po 
		 atrybucie name w funkcji path w urls.py: 
					from django.url import reverse
					class MyTestClass(TeatCase):
						def my_func(self):
							self.client.get(reverse('detail')
		*klasa TestCase dostarcza specjalny typ asercji: assertContains() i assertQuerySetEqual()
					from django.url import reverse
					class MyTestClass(TeatCase):
						def my_func(self):
							response = self.client.get(reverse('detail')
			*assertContains() - sprawdza czy w zwracanym wyrenderowanym HTML'u zawiera się string w 2gim arg
							self.assertContains(response, 'my text in HTML'(
			*assertQuerySetEqual() - czy zwracany słownik dla podanego klucza odpowiada liście wartości
							self.assertQuerySetEqual(response.context['my_key'], [value1, value2])
								
==============================================================================================================				
4)RÓŻNE FORMY FORMULARZY:
	0*Formularz WIELOKROTNEGO WYBORU 
		***TO-DO-APP - tech with TIM - https://www.techwithtim.net/tutorials/django/custom-forms/
		***W TEMPLATES - tworzysz formularz z inputami 'type=text', 'type=checkbox' oraz buttonami:
							<form method = 'POST' action="create">
								{% csrf_token %}
								<ul>
									{% for item in ls.item_set.all %}
										{%if item.complete == False%}
											<li><input type="checkbox", value="clicked", 
													name="c{{item.id}}">{{item}}</li>
										{% else %}		###(dla starozaznaczonych input'ów type='checkbox 
														###użyj pola: 'checked' (przy sprawdzenie warunku: 
														###'gdy zadanie ukończone' to dla danego tagu 
														###"input type='checkbox'" dodaj pole 'checked'
											<li><input type="checkbox", value="clicked", 
													name="c{{item.id}}" checked>{{item}}-COMPLETE</li>
										{%endif %}
									{% endfor %}
								</ul>
								<button type="submit", name="saveButton", 
													value ="save button">SAVE everything</button>
								<input type='text', name='newItem'>
								<button type="submit", name="saveNewItemButton", 
													value = "save new Item button">Add new Item</button>
							</form>
		***SŁOWNIK REQUEST - po przesłaniu formularza tworzy się słownik klikniętych "checkbox'ów", 
		   wciśniętych buttonów i wszystkich input'ów type="text":
							<QueryDict: {'csrfmiddlewaretoken': ['yXRRDKvKzh70bRK...'], c1': ['clicked'], 
							'c4': ['clicked'], 'saveButton': ['save button'], 'newItem': ['']}>
		***WE VIEWS.PY - pobierasz wartości ze słownika request.POST metodęą get() / getlist() (dla list) 
		   lub nawiasy kwadratowe: request.POST.get('key') ALBO request.POST['klucz']
							def index(request,id):
								lst = ToDoList.objects.get(id=id)
								if request.method != 'POST':			#if request.method == 'GET'	
									context ={'ls':lst}
									return render(request, "site1/list.html", context)
								else:  									#if request.method == 'POST'	
									#print(request.POST) - w konsoli pokaże ten słownik 
									if request.POST.get("saveButton"):
										for item in lst.item_set.all():
											if request.POST.get("c" + str(item.id)) == "clicked":
												item.complete = True
											else:
												item.complete = False
											item.save()
									elif request.POST.get("saveNewItemButton"):
										txt = request.POST.get("newItem")
										if len(txt)>2:
											lst.item_set.create(text=txt, complete=False)
										else:
											print("invalid")
									context ={'ls':lst}
									return render(request, "site1/list.html", context)
	1*Formularz JEDNOKROTNEGO WYBORU (formularz budowany od podstaw w HTMLu, przekierowujący na inną 
	  stronę przez pole action w tagu form i przekazujący dane przez request.POST):
		*DLA MODELI, URLS.PY i VIEWS.PY:
					#w models.py - dla modeli:
							class Question(models.Model):
								question_text= models.CharField(max_length=200)
								pub_date = models.DateTimeField('date published')
							class Choice(models.Model):
								question = models.ForeignKey(Question, on_delete=models.CASCADE)
								choice_text = models.CharField(max_length=200)
								votes = models.IntegerField(default=0)
					#w urls.py - dla linku:
							path('<int:question_id>/', views.detail, name='detail'),	
					#we views.py - dla funkcji detail():
							def detail(request, question_id):
								question = get_object_or_404(Question, id=question_id)
								return render(request, 'polls/detail.html', {'question': question})
		*TWORZYSZ FORMULARZ który po wysłaniu przekierowuję do funkcji vote() z views.py zamiast do samego 
		 siebie. Funkcja vote() we views.py ogarnia logikę (czyli posumowanie głosów) i przekierowanie do 
		 innej funkcji z views.py która prześle dane do odpowiedniego pliku HTML:
					#w templates - wyświetla się plik detail.html, gdzie znajduję się formularz:
							{% if error_message %}
								<h1>{{ error_messages }}</h1>
							{% endif %}
							<form method='POST' action={% url 'vote' question.id %}		
														#przy metodzie POST przesyła dane z formularza 
														#do funkcji vote() w pliku views
								{% csrf_token %}
								<fieldset>
									<legend>{{ question.question_text }} </legend>
									{% for choice in question.choice_set.all %}
										<input type="radio" name="choice" value ={{choice.id}}  
																		id="choice{{forloop.counter}}" />
														#pole name będzie przekazane jako klucz w slowniku
														#z request.POST a value jako wartość do tego klucza
										<label for="choice{{ forloop.counter }}">{{choice.choice_text}}
																								 </label>
														#label musi pasować do "radio" czyli opcji wyboru. 
														#Robisz to poprzez 'for' gdzie wskazujesz id 'radio'
									{% endfor %}
								</fieldset>
								<input type="submit" value="vote" />
							</form>
					#urls.py
							path('<int:question_id>/vote/', views.vote, name='vote'),
							path('<int:question_id>/results/', views.results, name='results'),
					#we views: 
							def vote(request, question_id):]
								question = Question.objects.get(id=question_id)
								try:
									selected_choice= question.choice_set.get(pk=request.POST['choice'])
								except(KeyError, Choice.DoesNotExist):
									return render(request, 'polls/results.html', {'question':question, 
																	'error_message':"You didn't choose"})
								else:
									selected_choice.votes+=1
									selected_choice.save()
									return HttpResponseRedirect(reverse('polls:results', kwargs={
																			"question_id":question.id}))
														#przy method=POST używasz HttpResponseRedirect()
														#zamiast metody render() gdyż dane z request.POST 
														#przy odświeżaniu w render prześlą się drugi raz 
														#co nie może mieć miejsca!!!
							def results(request, question_id):
								question = Question.objects.get(id=question_id)
								return render(request, 'polls/results.html',{'question':question}
					#w templates:
							{{question.question_text}}
							<ul>
								{%for choice in question.choice_set.all %}
									<li>{{choice.choice_text}} -- {{choice.votes}}, 
																	vote{{ choice.votes|pluralize }}</li>
								{% endfor %}
								<a href="{% url 'polls:detail' question.id %}">Vote again?</a>
							</ul>
	2*Wiele tych samych formularzy na jednej stronie (FORMSET we form):
		*we forms.py --> zwykła klasa formularza
		*we views.py:
							from django.forms import inlineformset_factory
							def createOrder(request,pk):
								OrderFormSet = inlineformset_factory(Customer, Order, 
															fields=('product','status'), extra=10)
								customer = Customer.objects.get(id=pk) 
								formset = OrderFormSet(instance=customer)
								if request.method =='POST':
									formset=OrderFormSet(request.POST, queryset=Order.objects.none(), 
																			Orderinstance=customer )
									if formset.is_valid():
										formset.save()
										return HttpResponseRedirect(reverse('home'))
								context={'formset':formset}
								return render(request, 'accounts/order_form.html', context)
		*w templates:
							<form autocomplete="off" action="" method ="POST">
								{% csrf_token %}
								{{formset.management_form}}
								{%for form in formset%}
									<p>{{form}}</p>
								{%endfor%}
								<input type="submit" name="Submit"/>
							</form>			
							
============================================================================================================
3)ROZSZERZENIE KLASY MODELS: 
	A) models.Manger, models.QuerySet
		1*Podstawy:
			*we views.py zamiast stosować standardowe metody pobierające dane z bazy danych np: 
			 Mymodel.objects.filter(...) albo Mymodel.objects.get(...) można stworzyć swoje własne metody
			 w klasie dziedziczącej po models.Manager
		2*models.Manager:
			*w models.py tworzysz klasę o nazwie takiej samej jak główny model ale dodajesz końcówkę 
			 Manager. Klasa ta dziedziczy po models.Manager ; 
					class ArticleManager(models.Manager)						#dla klasy Article 
			*w models.py w głównym modelu musisz dodać pole objects któremu przypisujesz MymodelManager()
					class(Article(models.Model)
						objects = ArticleManager()
			*w models.py w klasie MymodelManager defniujesz funkcje (np search(self, query)) które później 
			 możesz wykorzystać we views.py przy wywoływaniu obiektów np: Article.objects.search(query='abc')
					class ArticleManager(models.Manager):
						def search(self, query):
							if query is not None:
								#return Article.objects.filter(Q(title__icontains=query) | 
															   Q(content__icontains=query))
								return self.get_queryset().filter(Q(title__icontains=query) | 
																  Q(content__icontains=query))
							else:
								return self.get_queryset().none()  				 #zwróci pustą listę
				#zamiast Article.objects możęsz wywołać metodę na self.get_queryset()
		3*models.QuerySet
			*możesz przesłonić metodę get_queryset() z models.Manager zwracając z niej obiekt klasy 
			 dziedziczącej po models.QuerySet gdzie wewnątrz umieszczasz metody przejmujące wyszukiwanie; 
					class ArticleQuerySet(models.QuerySet):
						def search2(self, query):
							if query is not None:
								return self.filter(Q(title__icontains=query) | Q(content__icontains=query))
							else:
								return self.none()   #zwróci pustą listę
			*teraz w klasie dziedziczącej po models.Manager przesłaniasz get_queryset(self.model self._db)
			 i podając domyślną bazę danych
					class ArticleManager(models.Manager):
						def get_queryset(self):
							return ArticleQuerySet(self.model, self._db)
						def search(self, query):
							return self.get_queryset().search2(query)  
	B) VALIDATORS:
		*https://docs.djangoproject.com/en/4.0/ref/validators/
		*słuzy do stworzenia realcji JEDEN - WIELE  z użyciem ograniczonej listy stringów/obiektów:
		*tworzysz plik validators.py wraz z ograniczoną listą stringów i wyrzucasz wyjątkiem ValidationError 
		 gdy wpisane hasło przy tworzeniu obiektów nie znajduję  się w liście:
				*wewnątrz validators.py
					from django.core.exceptions import ValidationError
					my_lst = ['pdf','doc','svg']
					def validate_MY(value):
						if value not in my_lst:
							raise ValidationError(f'{value} is not in list'
				*wewnątrz models.py
						from django.db import models
						class Post(models.Model):
							extension = models.CharField(max_length=50, validators = [validate_MY]
							...


==============================================================================================================
2)STRONA ADMINISTRATORA: 
	A)WSTĘP:
		*PODSTAWY:
			*[<sciezka_do_nazwyStrony_z_serwerem>/admin np 127.0.0.1/8000/admin]
			*admin site daje możliwość przeglądania wszystkich baz danych wraz z tworzeniem, updatowaniem 
			 i usuwaniem tychże danych. 
			*ponadto masz tam bazę użytkowników (na których również możesz dokonywać powyższych operacji)
 			 wraz z hasłami które są domyślnie zahashowane i posolone. Użytkownicy ci składają się na 3 
			 grupy w zależności od statusu dostępu: administratorzy (superuser), ci co mogą się zalogować 
			 do admin-site ale nie mają praw administratora (staff user) oraz ci o najwęższych prawach 
			 (active). 
			*znajduję się tam też panel boczny gdzie masz wyswietlone wszystkie historie wszystkich 
			 dokonanych operacji.
		*STWORZENIE I PIERWSZE UŻYCIE - najpierw trzeba stworzyć domyślne bazy danych (komenda migrate 
		 pozwala na zatwierdzenie zmian w bazie danych, ale jeżeli te bazy jeszcze nie istnieją to są 
		 tworzone takie domyślne jak auth_user). Następnie możesz utworzy pierwszego superusera 
		 (administratora).
						python manage.py migrate					#utworzenie domyślnych baz danych
						python manage.py createsuperuser			#utworzenie 1wszego administratora
						#jeżeli nie działa to wpisz winpty: winpty python manage.py createsuperuser
		*AUTOMATYCZNE WYGENEROWANIE TABELI z KLASY w pliku MODELS.PY - w pliku admin.py musisz pobrać 
		 daną klasę/tabelę z pliku models.py i następnie ja zarejestrować. Dzięki temu będziesz mógł 
		 modyfikować dane z tabeli z pozycji administratora będąc zalogowanym na stronie administracyjnej:
						#w admin.py danej app/funkc. (w tym przypadku w app/funkc klasa Post):
						from . models import klasaPost
						admin.site.register(klasaPost)
	B) ZARZĄDZANIE DANYMI W PANELU ADMINISTRATORA (admin.ModelAdmin + admin.StackedInline/TabularInline)
		*https://docs.djangoproject.com/en/4.0/ref/contrib/admin/
		*https://docs.djangoproject.com/en/4.0/intro/tutorial07/
		*UTWORZENIE - tworzysz klasę o nazwie z modelem/klasą którą chcesz przechowywać i dodajesz końcówkę
		 'Admin' wraz z dziedziczeniem po admin.ModelAdmin:
						from django.contrib import admin
						from  .models import Meetup
						class MeetupAdmin(admin.ModelAdmin):
							...
		*POLA:
			*fields - w panelu dla danego modelu ustawiasz poszczególne pola wg upodobania. Domyślnie 
			 gdy nie ustawisz tego pola to wyświetlą się wszystkie pola danego modelu:
						class Meetup(admin.ModelAdmin):
							fields = ['title','slug']
			*raw_id_fields - wskazujesz które pola będaće kluczami obcymi powinny wyświetlać się Tobie 
			 zamiast w liście to w dodatkowym automatycznie otwierającym się oknie.
			*read_only_fields - pola tylko do wyświetlenia w adminie bez możliwości edycji 
						class Meetup(admin.ModelAdmin):
							read_only_fields = ['timestamp','updated']      
							raw_id_fields = ['user']    
			*inlines - daje możliwość wyświetlenia obiektów klucza obcego w modelu powiązanym relacją z 
			 innym modelem. Tworzysz klasę dziedziczącą po 'admin.StackedInline' lub 'admin.TabularInline'
			 wg formuły nazewnictwa: 'class <model_name>Inline(admin.StackedInline)' w której podajesz 
			 pole 'model'. Natępnie w klasie powiązanej relacją w polu inlines podajesz listę wszystkich
			 tych klas 'Inlines':
						from django.contrib import admin
						class ChoiceInline(admin.StackedInline):	#class ChoiceInline(admin.TabularInline):
							model = Choice
							extra =1
						class QuestionAdmin(admin.ModelAdmin):
							fields = ['pub_date', 'question_text']
							inlines =[ChoiceInline]
			*extra - w klasie która jest kluczem obcym możesz wskazać ile pustych obiektów  klucza obcego 
			 jest domyślnie wyświetlanych. Wykorzystywane w klasach dziedzicząćach po admin.StackedInline
			 oraz po admin.TabluarInline
			*list_display - w panelu wyświetlają się kolumny o polach klasy/modelu które wskażesz w krotce:
						class MeetupAdmin(admin.ModelAdmin):
							list_display('title','slug')
			*list_filter - w panelu pokaże się blok z filtrami odwołującymi się do pól klasy/modelu kótre
			 wskażesz w krotce:
						class MeetupAdmin(admin.ModelAdmin):
							list_display('title','slug')
							list_filter=('location',)
			*prepopulated_ fields - wskazujesz które pola mają mieć autouzupełnianie na bazie innych pól 
			 (podajesz je w słowniku gdzie klucz jest polem gdzie ma być autouzupełnianie a wartość ma 
			 być krotką pól któe mają być tym autouzupełnieniem) -TO JEST AUTOUZUPEŁNIENIE TYLKO W ADMINIE 
			 A NIE W BAZIE DANYCH WIĘC TRZEBA PÓŹNIEJ TO ZAPISAĆ!!! (zamiast tego raczej przesłaniaj 
			 metodę save() w models gdzie użyj funkcji slugify()):
						class MeetupAdmin(admin.ModelAdmin):
							list_display('title','slug')
							list_filter=('location',)
							prepopulated_fields={'slug':(title,)}
		*REJESTRACJA W ADMIN.PY 
			***rejestrujesz klasę administracyjną wraz z klasą bazową:
						admin.site.register(Meetup, MeetupAdmin)
			***możesz odrejestrować klasę User i zarejestrować ją raz jeszcze później:
						from django.contrib.auth.models import User
						admin.site.unregister(User)
						class RecipeInline(admin.StackedInline):
							model = Recipe
							extra = 0
						class UserAdmin(admin.ModelAdmin):
							model = User
							inlines = [RecipeInline]
							list_display =['username']
						admin.site.register(User)	

=============================================================================================================
1)DEBUGOWANIE CAŁEGO PROJEKTU:
  *UTWORZENIE PLIKU potrzebnego DO DEBUGOWANIA
	*znajdując się wewnątrz jakiegokolwiek pliku z rozszerzeniem .py przechodzisz w panelu bocznym na ikonę 
	 "play z żuczkiem" i klikasz na napis: "create a launch.json file" i z dostępnych opcji wybierasz opcje 
	 z DJANGO.
	*Tworzy ci się plik launch.json w folderze .vscode. Ten plik służy tylko do debugowania więc jeżeli np 
	 zmienisz port w "args" dodając do listy w cudzysłowiu nowy nr portu to podczas odpalania projektu 
	 poprzez wpisywanie ręcznie komend w terminalu, nie będzie to miało znaczenia tylko podczas jego 
	 debugowania (chyba że odpalisz projekt przez CTRL + F5 (czyli Run without debugging))
	*launch.json - składa się z par kluczy i wartości dających "launch profile"
  *DEBUGOWANIE:	
	*żeby rozpocząć debugowanie to (już po zaznaczeniu breakpoint'ów), przechodzisz na ikonę "play z 
	 żuczkiem" i u góry wciskasz play. Uruchomi się Tobie projekt w taki sam sosób jakbyś uruchamiał go w 
	 terminalu (pipenv shell ;; python manage.py runserver) tylko w miejscach breakpointów się zatrzyma 
	 (otworzy ci się nowy teminal) 
	*KOLEJNE FUNKCJE wyświetlone w panelu:
		*STEP OVER f10- przejdź przez kolejną linijkę
			*panel boczny - wraz z przechodzeniem przez kolejne linijki panel będzie (inspect) sprawdzał 
			 wartości w tych linijkach 
		*STEP INTO f11 - jeżeli natrafisz w linijce na funkcje to możesz wejśc wewnątrz jej ciała i zobaczyć
		 czy tam nie ma jakiegoś buga
		*STEP OUT SHIFT +f11 - następnie możesz wyjśc z takiej funkcji 
		*RESTART - załączasz debugowanie od nowa
		*STOP - kończysz debugowanie
	*żeby włączyć projekt bez debugowania to robisz:
			CTRL + f5 (RUN --> Run without debugging)
  *DEBUGOWANIE poprzez DJANGO-DEBUG-TOOLBAR:
   https://django-debug-toolbar.readthedocs.io/en/latest/installation.html
    *ZALETY: 
		*mając odpowiednio przygotowany plik html (czyli conajmniej zawierający tagi html 
		 oraz body) mozesz w przeglądarce po wcześniejszym odpaleniu pliku (CTRL + f5 / F5) korzystać z 
		 panelu do debugowaniu gdzie masz wszystkie potrzebne opcje i informacje.
	*INSTALACJA:	
		*instalacja w wirtualce:
				pipenv install django-debug-toolbar
		*dodanie do settings.py w głównej APP/FUNKCJONALNOŚCI do sekcji INSTALLED_APPS:
				... ,
				'debug_toolbar' 
		*dodanie do urls.py w głównej APP/FUNKCJONALNOŚCI do urlpatterns (+ dodanie biliotek):
				import debug_toolbar
				from django.conf import settings
				from django.urls import include, path
				urlpatterns = [
					...
					path('__debug__/', include(debug_toolbar.urls)),
				]
		*dodanie do settings.py w głównej APP/FUNKCJONALNOŚCI do sekcji MIDDLEWARE:
				... ,
				'debug_toolbar.middleware.DebugToolbarMiddleware',
		*dodanie do settings.py w głównej APP/FUNKCJONALNOŚCI całej sekcji INTERNAL_IPS wraz ze swoim ip:
				INTERNAL_IPS = [
					# ...
					'127.0.0.1',
					# ...
				]
				
