											SPIS TREŚCI:
############################################################################################################
POSTGRESQL PYTHON:		https://www.tutorialspoint.com/python_postgresql/python_postgresql_limit.htm
MYSQL:					https://www.w3schools.com/python/python_mysql_getstarted.asp
MONOGDB:				https://www.w3schools.com/python/python_mongodb_getstarted.asp
						https://www.tutorialspoint.com/python_mongodb/index.htm
PYTHON SQLITE:			https://www.tutorialspoint.com/python_sqlite/index.htm

python beautiful SOUP:	https://www.tutorialspoint.com/beautiful_soup/index.htm
python WEB_SCRAPING:	https://www.tutorialspoint.com/python_web_scraping/index.htm
PYTHON BLOCKCHAIN:		https://www.tutorialspoint.com/python_blockchain/index.htm
python web development:	https://www.tutorialspoint.com/python_web_development_libraries/index.htm
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################




################################### BEAUIFUL SOUP | HTMLPARSER #############################################
########################################## BEAUIFUL SOUP ###################################################
https://www.py4e.com/code3/urllink2.py?PHPSESSID=d163255a18b681c23d5f6c01094fc6a0
########################################### HTML PARSER ####################################################	
https://www.askpython.com/python-modules/htmlparser-in-python


############################### NETWORKING: SOCKETY, URLLIB, REQUESTS ######################################
######################################## URLLIB | REQUEST ##################################################
REQUEST MODULE:						https://www.w3schools.com/python/module_requests.asp
##################################### NETWORKING: SOCKETY ##################################################
WYMIANA DANYCH MIEDZY KLIENTEM A SERWEREM:
									https://www.youtube.com/watch?v=yUZpSQhds3M
									https://www.youtube.com/watch?v=sETW3WhxG0o


############# SENDING EMAIL (SENDGRID): MODULE smtplib | RECIVING EMAIL: MODULE imap #######################
KOD IMAP (w pliku inbox.py): 		https://github.com/codingforentrepreneurs/30-Days-of-Python/commit/8b09ed860dc5d36b1f90c54987c541e2a9317782#diff-07a5d8e5d735aa27245df73d8956d60ce43ccdbd21a672f1f45f39047f959410
									https://www.tutorialspoint.com/python_network_programming/python_imap.htm
KOD SMTP (w pliku send_mail.py): 	https://github.com/codingforentrepreneurs/30-Days-of-Python/commit/8b09ed860dc5d36b1f90c54987c541e2a9317782#diff-0068d3b04d9889c399f27998909e2adca26494b4c823a2adcbb5edaaf73f856b
									https://www.tutorialspoint.com/python_network_programming/python_smtp.htm
									
									
####################### API | JSON | XML | CSV | DATABASE | BAZY DANYCH ####################################
API JSON example:					https://www.py4e.com/code3/geojson.py
API XML example:					https://www.py4e.com/code3/geoxml.py
JSON MODULE:						https://www.w3schools.com/python/python_json.asp
XML:								https://www.py4e.com/html3/13-web
									https://nowaker.net/post/xml-instance-xml-schema.html
CSV:								https://www.youtube.com/watch?v=Xi52tx6phRU  
						
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################



############################################################################################################
######################################## BEAUIFUL SOUP #####################################################
https://www.py4e.com/code3/urllink2.py?PHPSESSID=d163255a18b681c23d5f6c01094fc6a0
1* BIBLIOTEKA BEAUTIFUL SOUP - WSTĘP:
  *https://www.py4e.com/code3/urllink2.py?PHPSESSID=d163255a18b681c23d5f6c01094fc6a0
	*pobranie biblioteki poprzez from bs4 import BeautifulSoup
	*przeczytanie całej strony z linka
	*stworzenie obiektu BeautifulSoup poprzez podanie w argumencie sparsowanego linku do strony
	*wywołanie metody soup() do przeszukania wszystkich tagow o danym arg i przejscie po nich
			import urllib.request, urllib.parse, urllib.error
			from bs4 import BeautifulSoup
			url ='http://www.dr-chuck.com/page1.htm'
			html = urllib.request.urlopen(url).read()
			soup = BeautifulSoup(html, 'html.parser')
			tags = soup('a')
			for tag in tags:
				print(tag.get('href',None))
				
	*przykład wywoływania tagów: (zadanie: https://www.py4e.com/tools/python-data/?PHPSESSID=d163255a18b681c23d5f6c01094fc6a0)
			tags = soup('a')
			for tag in tags:
			    # Look at the parts of a tag
				print 'TAG:',tag
				print 'URL:',tag.get('href', None)
				print 'Contents:',tag.contents[0]
				print 'Attrs:',tag.attrs

######################################### HTML PARSER ######################################################	
https://www.askpython.com/python-modules/htmlparser-in-python
https://www.journaldev.com/19931/python-html-parser

1. HTMLPARSER:
	*klasa która jest wykorzystywana w krókich i prostych zadaniach do scrapowania kodu html
	*pobierasz klasę HTMLParser z modułu html.parser lub sam moduł html.parser
	*Żeby móc skorzystać z jego funkcji to najpierw musisz stworzyc klasę która będzie dziedziczyć od modułu
 	 HTMLParser i przesłonić te funkcje któe zwróćą te dane których potrzebujesz
	*Te funkcje któe przesłonisz zostaną automatycznie odpalone poprzez funkcje feed() wywołanej na obiekcie
	 stworzonej przez Ciebie klasy dziedziczącej po HTMLParser'ze
	*funkcje które automatycznie zostaną odpalone po wywołaniu funkcji feed(txt) (gdzie w argumencie 
	 podajesz stringa z htmlem) i które trzeba wcześniej przesłonić:
		*handle_starttag(tag, attrs) - zwraca wszystkie tagi otwierające  <tag> 
		*handle_endtag(tag) - zwraca wszystkie tagi zamykające </tag>
		*handle_startendtag(tag, attrs) - zwraca tagi otwierająco-zamykające <tag />
		*handle_data(data) - zwraca treści między tagami
		*handle_comment(data) - zwraca komentarze w tekscie html
		+inne metody
	*możesz przesłonic w niej wszystkie funkcje (decydując się na printy albo na returny) i następnie 
	 wywołac metodę feed na nowy obiekcie która uruchomi wszystkie metody 
			from html.parser import HTMLParser
			class MyHTMLParser(HTMLParser):
				def __init__(self):
					super().__init__()
				def handle_starttag(self, tag, attrs):
					print("Start :",tag)
					for name, value in attrs:
						print("-> "+str(name)+" > "+str(value))
				def handle_endtag(self, tag):
					print("End   :",tag)
				def handle_startendtag(self, tag, attrs):
					print("Empty :",tag)
					for name, value in attrs:
						print("-> "+str(name)+" > "+str(value))
			parser=MyHTMLParser()
			txt='<title name='tytul'>JournalDev HTMLParser</title>'
			parser.feed(txt)		#zwroci: Start : title ;; -> name > tytul ;; End   : title


############################################################################################################
############################ NETWORKING: SOCKETY, URLLIB, REQUEST ##########################################
https://www.w3schools.com/python/module_requests.asp

0* ODPALENIE SERWERA I KLIENTA POWININES ZROBIĆ W DWÓCH KONSOLACH
   SOCKET - czyli inaczej połączenie miedzy dwoma urządzeniami
   SĄ RÓZNE STANDARTY (PROTOKOŁY) przy połączeniach (działające na róznych portach):
	*Telnet(23) - login
	*SSH(22) - Secure Login
	*HTTP (80) - WebSites
	*HTTPS (443) - Secure WebSites
	*Smtp(25) - email
	*IMAP(143/220/993) - email retrival
	*POP(109/110) - email retrival
	*DNS(53) - Domain
	*FTP(21) - Files
  KODOWANIE - najwcześniejszym formatem znakow byla tablica ASCII (znakow lacinskich) ale pozniej doszlo 
		wiele jezykow i ich znakow diakrytycznych -> stąd pojawił się format UNICODE Tyle że on zajmował 
		bardzo dużo miejsca bo az 4 Bajty (UTF-32) [dla porownania tablica ASCII zajmuje 1 BAJT] -> stąd 
		pojawił się pomysł żeby spakować ten format UTF-32 na mniejszy. Powstał UTF-16 (zajmujący 2 Bajty) 
		a pózniej UTF-8 który pozwala dynamicznie ustalac wielkość (zajmuję od 1-4 Bajtów)(Gdy zajmuję 1 
		Bajt to jest w pełni kompatybilny z tablicą ASCII
			- NAPISY można reprezentować za pomocą 2 typów danych 
					*String
					*Byte
		W Pythonie 2.0 Stringi były reprezentowane przez Byte'y (w formacie tablicy ASCII) a jezeli chciało 
		się żeby były reprezentowane w formacie UNICODE to był na to specjalnie tworzony obiekt. W Pythonie 
		3.0 Stringi są reprezentowane w formacie UNICODE. Ponieważ dane wysyłasz poprzez Byte'y to musisz 
		je jeszcze zakodować według odpowiedniego formatu (98% wybiera format UTF-8). Robisz to poprzez 
		metode encode() która zaminia dane na Byte'y.

####DO WSZYSTKICH 3 MODUŁÓW PONIŻEJ
####STATUS KODY DO STRON HTML:
		  200 - OK (przyznany dostęp)
		  3.. - przekierowania
		  4.. - błędy po stronie użytkownika
		  400 - Bad Request(zła odpowiedź serwera)
		  403 - Forbidden (nie przyznano dostępu)
		  404 - Not Found (nie znaleziono)
		  5.. - błędy po stronie serwera
		  
1* POBRANIE DANYCH z SERWERA STRONY INTERNETOWEJ HTTP:
	*URL SKŁĄDA SIĘ Z:	https://en.wikipedia.org/wiki/URL?key=value&life=42#History
		PROTOKÓŁ: 		HTTP, HTTPS, FTP,...	(protokół do wymiany danych)
		HOST: 			en.wikipedia.org		(adres hosta)
		PORT: (jeżeli nie jest podany to używa się domyślnych: dla http: 80 ; dla https: 443)
		PATH: 			wiki/URL				(ścieżka)
		QUERYSTRING:	?key=value&life=42		(pary kluczy i wartośći oddzielone '&')
		FRAGMENT:		#History 				(sekcja strony )	
 A)POPRZEZ SOCKETY:
   *https://www.py4e.com/code3/socket1.py
	*tworzysz OBIEKT socketa (klienta)
	*poprzez metodę connect() łączysz sie z adresem(HOST+PORT) serwera
	*tworzysz w stringu rządanie GET wg specjalnego PROTOKOŁU i je kodujesz (metoda encode()):
			'GET http://data.pr4e.org.romeo.txt HTTP/1.0\r\n\r\n'
	*wysyłasz rządanie poprzez metode send()
	*odbierasz dane w pętli for ustalając sobie maksymalny rozmar przyjomwanych paczek poprzez metode 
	 recv('rozmiar_max_paczek') oraz dekodujesz te paczki
	*zamykasz połączenie socketu poprzez metodę close()
			import socket
			client_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
			client_socket.connect(('data.pr4e.org',80))
			rzadanieGet='GET http://data.pr4e.org.romeo.txt HTTP/1.0\r\n\r\n'.encode()
			client_socket.send(rzadanieGet)
			while True:
				data = client_socket.recv(BUFFER)
				if len(data) <1: break
				print(data.decode())
			client_socket.close()
	*zwraca głównie headers czyli nagłówki strony i połaczenia

 B)POPRZEZ BIBLIOTEKĘ URLLIB - jeszcze szybciej i krócej:
   *urllib package skłąda się z modułów:
		*request - do otwierania linków URL
		*response - (wykorzystywany przez request module, nie używasz bezpośrednio)
		*error - zawiera wyjąti specjalne dla modułu request
		*parse - ma wiele potrzebnych funkcji do dzielenia lników URL na małe ważne fragmenty
		*robotparser - sprawdza pliki robots.txt w celu sprawdzenia jakie pozwolenia są 
			przyznawane dla dla botów i crawlerów
   *https://www.py4e.com/code3/urllinks.py
   *SCHEMAT PODSTAWOWY:
		*pobierasz biblioteke urllib.request, urllib.parse, urllib.error
		*odwolujesz sie do urllib.request i wywolujesz metode urlopen gdzie wpisujesz link
					import urllib.request, urllib.parse, urllib.error
					file = urllib.request.urlopen('http://data.pr4e.org/romeo.txt')
		*czytasz pobrane dane poprzez przejscie kazdej linijki i zdekodowanie jej
					for line in file:
						print(line.decode().strip())
		 możesz też użyć metody read() do czytania z pliku (tylko raz możesz użyć metody read() później 
		 python zamyka połączenie) a póżniej decode gdzie jako argument podajesz kodowanie np.: 'utf-8':
					data=file.read()				#zwróci obiekt typu <class 'bytes'>
					html=data.decode("UTF-8")		#zwróći stringa
		*zwraca dla nas skrpyt HTML wraz z tym co znajduje sie na stronie
	WAŻNE DODATKI:
		*urllib.request.urlopen('link') zwraca Tobie typ danych:
		  <class 'http.client.HTTPResponse'>
		*możesz sprawdzić czy połączenie cały czas jest otwarte (zwróci True or False)
					file.isclosed()
		*zaraz po metodzie urllopen możesz użyc metody peek() do sprawdzenia kilku pierwszych linijek co 
		 pobrałeś. (To co zwróci nie będzie stringiem tylko obiektem typu BYTE)
		  <class 'bytes'>
					print(file.peek())
		*możesz sprawdzić jaki HTTP STATUS CODE otrzymałeś. 
					print(file.code)
		*możesz sprawdzić długość pliku w Byte'ach (length)
					print(file.length)
		*TWORZENIE LINKÓW - możesz odpowiednio zakodować link poprzez metodę urlencode() gdzie podasz 
		 słownik w którym będą odpowiednie paramtery np:
					params={'v':'EuC-yVzHhMI', 't':'5m56s'}
					querystring=urllib.parse.urlencode(params)
					url='http://www.youtube.com/watch'+'?'+querystring
				 
 C)POPRZEZ MODULE REQUEST - jeszcze szybciej i krócej:
	*jest to biblioteka zewnetrzna wiec musisz ja pobrac (bedac w folderze pliku w konsoli
	 w pycharmie ) 			pip install requests		|		pipenv install requests
	*PODSTAWY:
		*Możliwości:
			*możliwość odebrania skryptu HTML wraz z tym co znajduje sie na stronie (metoda get)
			*możliwość wysyłania informacji na stronę (metoda post)
			*możliwość pobierania obrazów (metoda get)
			*możliwość wysyłania authentication information dla podstawowego logowania i formularzy
			*możliwość śledzenia przekierowań 
		*zwraca Response Object with the response data(content, encoding, status, etc)
		*jest to biblioteka świetna do pobierania danych ale nie ich przetwarzania( od tego 
		 jest Beautiful Soup)
		*https://httpbin.org - strona do testowania funkcji z biblioteki requests:
			*są tam zapisane różne metody jak get, post, put, delete 
			*oraz zakończenie linka też w postaci /get, /post, /delete, /put itp - te zakońzenia nie są 
			 wymagane przy innych stronach internetowych i są to takie podstrony strony httpbin.org
			*na razie nie rozumiem do czego służą te wszystkie przykłady na stronce ale się dowiem...
			
			
	*METODY REQUESTS: 	https://www.w3schools.com/python/module_requests.asp
	  *post(...) - służy do wysyłania danych do np formularza:
					import requests
					dictionary={'username':'corey', 'password': 'testing'}
					r=requests.post('https://httpbin.org/post', data=dictionary)
	  *get(...) 
			**params - przy metodzie get możesz dodać paramtery w postaci słownika i te paramtery zostaną 
			  odpowiednio skonfigurowane tak by stworzyć link:
					import requests
					payload={'page': 2, 'count':25}
					r=requests.get('https://httpbin.org/get', params=payload)
							#zwróci: https://httpbin.org/get?page=2&count=25
							#to get w linku nie jest wymagane tylko jest to część adresu strony
			**auth - przy metodzie get mozesz dodać parametr auth do prostego authentication:
					import requests
					r=requests.get('https://httpbin.org/basic-auth/corey/my_password' 
															, auth=('corey', 'my_password')
					print(r.text)
		 *url - zwraca podany url
					print(r.url)						#zwróci: https://httpbin.org/get?page=2&count=25
		 *text - zwraca content of te response czyli HTML'a:
			*get('adresStrony') - zwraca skrpyt html
					import requests
					r=requests.get("http://httpbin.org")		
					print(r.text)													#zwróci htmla
		 *json() - zwraca format jsona:
			*get('adresStrony/json') - zwraca słownik JSON'a
					import requests
					r=requests.get("http://httpbin.org/json")	
					print(r.json())													#zwróci JSON'a
		 *content - zwraca content of the response w bajtach (bytes)
			*get(url='adresStrony', stream=True) - zwraca strumień wykorzystywany do większych plików jak 
			 zdjęcia. Mimo wszystko da się to wykorzystać TYLKO DO MNIEJSZYCH zdjęć/plików.
				*content - pozwala zobaczyć cały plik który otrzymano drogą strumieniową dzięki 
				 get(url='adres'strony,stream=True)
					import requests
					r=requests.get("https://static.wikia.nocookie.net/lotr/images/e/e3/
									Lonely_Mountain_-_DoS.jpg/revision/latest?cb=202003
									17224945", stream=True)
					file=open("filename", 'wb')
					file.write(r.content)
				*raw - możńa ten argument wykorzystąc do funkcji modułu shutil (shell util) o nazwie 
				 shutil.copyfileobj() i pobierać BARDZO DUŻE PLIKI jak ogromne zdjęcia.
					import requests
					import shutil
					with requests.get("https://static.wikia.nocookie.net/lotr/images/e/e3/
									  Lonely_Mountain_-_DoS.jpg/revision/latest?cb=202003
									  17224945", stream=True) as r:
						with(open("filename", "wb")) as file:
							shutil.copyfileobj(r.raw, file)		#pozwala zonbaczyć DUŻE zdjęcia
		 *headers - zwraca wszystkie ważne informacje dotyczące storny/obrazka/jsona w formie
			słownika
					import requests
					r=requests.get("https://imgs.xkcd.com")
					print(r.headers)
		 *status_code - możesz sprawdzić jaki status kodu otrzymałeś po dostaniu się do strony. 
			Statusy są widoczne powyżej.
					import requests
					r=requests.get("http://httpbin.org/json")	
					print(r)										#zwróci Status Code
					print(r.status_code)							#zwróci Status Code
		 *ok - zwraca True jeśli status_code jest mniejszy niż 400 i False jeśli jest >= 400
					import requests
					r=requests.get("https://imgs.xkcd.com/comics/")
					print(r.ok)
		 *raise_for_status()- jeżeli wyskoczy inny status niż 200 to podniesie wyjątek:
					import requests
					r=requests.get("http://httpbin.org/json")	
					r.raise_for_status()
		 *cookies - zwraca słownik cookies'ów
					import requests
					r=requests.get('https://httpbin.org/cookies')
					print(r.cookies)
		 
	
########################## WYMIANA DANYCH MIĘDZY SERWEREM A KLIENTEM:#######################################
  https://www.youtube.com/watch?v=yUZpSQhds3M
  https://www.youtube.com/watch?v=sETW3WhxG0o
  *SERWER:
    *STWORZENIE OBIEKTU SOCKETA
	  *musisz zaimportowac bilbioteke socket, przypisac HOST i PORT, i stworzyć OBIEKT SOCKETA:
		socket.AF_INET - rodzina adresow IPV4 ;deklarujemy jakie IP bedzie obiekt przyjmował
		socket.AF_INET6 -rodzina adresow IPV6 ;deklarujemy jakie IP bedzie obiekt przyjmował
		socket.SOCK_STREAM - strumien przesyłu danych dla socketa
			import socket as s
			HOST = s.gethostname()
			PORT = 33000
			server_socket = s.socket(s.AF_INET, s.SOCK_STREAM)
    *OTWARCIE POŁĄCZENIA DLA KLIENTA:
		*poprzez bind() wiążasz ze sobą HOST I PORT tworzac adres SERWERA (w argumencie podajesz krotke: 
		 (HOST,PORT))
		*poprzez metode listen(2) włączasz nasluchiwanie polączeń (w argumencie jest kolejka klientow ktorzy
		 beda mogli sie połaczyć (to nie stala, mozesz wpisac tam dowolna liczbe)
		*w nieskończonej pętli while true pobierasz socket klienta i adres klienta
		*żeby coś wysłać albo odebrac to operujesz na obiekcie klienta -> client_socket
			server_socket.bind((HOST, PORT))
			server_socket.listen(2)
			while True:
							#NAWIĄZANIE POŁACZENIA
				client_socket, address = server_socket.accept()
				print(f"Uzyskano polaczenie od {address} | lub {address[0]}:{address[1]}")
							#STRONA ODBIERAJĄCA
				name = client_socket.recv(BUFFER).decode("utf8")
				print(f"[{address[0]}:{address[1]}], Nazwa uzytkownika: {name}")
							#STRONA WYSYŁAJĄCA
				msg = f"Witaj na serwerze, {name}!".encode("utf8")
				client_socket.send(msg)
						
						#WYKORZYSTYWANIE HEADERA czyli nie ustalanie BUFFERA na sztywno
							#STRONA ODBIERAJĄCA:
				HEADER=8
				surname_header =client_socket.recv(HEADER).decode()
				surname=client_socket.recv(int(surname_header)).decode()
				print(f"Nazwisko uzytkownika: {surname}")
							#STRONA WYSYŁAJĄCA:
				HEADER=8
				msg2= f"nazwisko ktore otrzymalismy to: {surname}".encode()
				msg2_header=f"{len(msg2):<{HEADER}}".encode()
				client_socket.send(msg2_header+msg2)



  *KLIENT:
	*TWORZYSZ OBIEKT KLIENTA I nastepnie TWORZYSZ POŁĄCZENIE Z KLIENTEM
	*wysyłanie i odbieranie robisz poprzez operowanie na obiekcie klienta (czyli samego siebie) czyli 
	 client_socket
			import socket as s     
			HOST = s.gethostname() 			#wpisujesz nazwe HOSTA SERWERA na sztywno ALBO 
											#poprzez gethostname() (swojego komputera)
			PORT = 33000
			client_socket = s.socket(s.AF_INET, s.SOCK_STREAM)
			client_socket.connect((HOST, PORT))	#to jest jak wybranie numeru telefonu do serwera
						#STRONA WYSYŁAJĄCA
			name=input("Twoje imie: ").encode("utf8")
			client_socket.send(name)
						#STRONA ODBIERAJĄCA
			print(client_socket.recv(BUFFER).decode("utf8"))
					
					#WYKORZYSTYWANIE HEADERA czyli nie ustalanie BUFFERA na sztywno
						#STRONA WYSYŁAJĄCA
			HEADER=8
			surname=input("Twoje nazwisko: ").encode()
			surname_header= f"{len(surname):<{HEADER}}".encode()
			client_socket.send(surname_header + surname)
						#STRONA ODBIERAJĄCA:
			HEADER=8
			msg2_header=client_socket.recv(HEADER).decode()
			msg2=client_socket.recv(int(msg2_header)).decode()
			print(msg2)

  *METODY W SOCKETACH - niezależnie czy jestes w serwerze czy w kliencie zawsze uzywasz metod na obiekcie 
   klienta (w kliencie na obiekcie klienta stworzonym przez konstruktor a w serwerze na obiekcie klienta 
   zwróconym dzięki server_socket.accept()):
		*METODA send() -wysylasz jakies dane podane w argumencie ktore wczesniej musisz zakodować poprzez 
						metodę encode("utf8")
		*METODE recv() -otrzymujesz jakies dane do ktorych musisz okreslic ilosc zarezerwowanego miejsca na 
						te dane (argument BUFFER,ktory deklarujesz wcześniej) i ktore musisz takze 
						zdekodowac poprzez metode decode("utf8")
						
	*Jeżeli masz bardzo duży plik to zamiast rezerwować miejsce (BUFFER) na sztywno (czyli zarezerwowanego 
	 miejsca na plik) to czekasz na wiadomość od drugiej strony ktora będac podzielona na 2 cześci: daje 
	 nam (pierwsza cześć - NAGŁÓWEK:) rozmiar pliku oraz (druga cześć:) dany plik. Dzięki temu strona 
	 odbierająca dokladnie wie ile BUFFERA ma sobie przygotować na dany plik:
		*PO STRONIE WYSYŁĄJĄCEJ musisz stworzyć:
            *zmienną - plik ktory zakodujesz
            *zmienna_header - czyli rozmiar wysyłanego pliku ktoremu przypiszesz poprzez HEADER 
			 miejsce w jakim te dane o rozmiarze będą musiały się zmieścić. ZAPIS takiejgo 
			 rozmiaru: (+trzeba jeszcze zakodowac): 
					zmienna_header= f"{len(surname):<{HEADER}}".encode()
			 Taki zapis stworzy nam iles-bajtowy odstep(HEADER) ktory musi byc taki sam po stronie 
			 otrzymujacej 
			*metoda send() ktorej w argumencie dasz zmienna_header+zmienna czyli danych o rozmiarze pliku i 
			 sam plik

        *PO STRONIE OTRZYMUJĄCEJ musisz stworzyc:
            *HEADER - czyli ile miejsca rezerwujesz na wiadomosc o wielkosc pliku ktory zostanie nadesłany 
			 w metodzie receive
            *header_len - zmienna ktora przechowa wielkosc pliku ktory nadejdzie
            *zmienną - której przekazesz nadesłany plik za pomocą metody recv() ktorej w argumencie 
			 przekazesz header_len (normalnie byłby BUFFER) czyli wielkość nadesłanego pliku zamiast na 
			 sztywno ustalac BUFFER

    *HEADER a BUFFER:
		*HEADER to zarezerwowany obszar miejsca na nagłówek (czyli rozmiar rozmiaru nadeslanego pliku -on 
		 musi byc taki sam zarowno po stronie odbierającej i po stronie wysyłającej) np jezeli zarezerwuje 
		 8 bajtow miejsca na dane o wielkosci pliku po stronie wysyłającej i dodam do tego sam plik to po 
		 stronie odbierajacej muszę najpierw odczytac te 8 bajtow a dopiero potem kolejny plik. Jeżeli 
		 odczytałbym tylko 2 bajty rozmiaru rozmiaru pliku to pozostałe 6 bajtów już by program pobrał sobie
		 z mojego pliku co spowodowałoby błąd krytyczny gdyż po stronie odbierającej wczytałyby błedne dane 
		 o wielkosci pliku (przez te 6 dodatkowych bajtów) jak i błedne dane o samym pliku (przez te 6 
		 brakujących początkowych bajtów dla pliku)
		*BUFFER to zarezerwowany obszar dla pliku. Jest on ustalany na sztywno. Wczesniej nie trzeba 
		 przesylac mu informacji o wielkosci przesyłanego pliku. Minus jest że jezeli plik jest mały to 
		 niepotrzebnie mozesz rezerwowac duży obszar dla pliku a gdy z kolei plik jest ogromny to plik 
		 zostanie ucięty po osiagnieciu maksymalnej liczby ustalonej wczesniej w BUFFER'ZE
		 
3* WYJĄTKI w SOCKETACH:
	*SPRAWDZANIE: IF URL IS VALID:
	 https://www.codespeedy.com/check-if-a-string-is-a-valid-url-or-not-in-python/
			import validators
			valid=validators.url('gist.github.com/dperini/729294')
			if valid==True: print("Url is valid")
			else: print("Invalid url")
	*https://www.networkcomputing.com/data-centers/python-network-programming-handling-socket-errors
	

############################################################################################################
############# SENDING EMAIL (SENDGRID): MODULE smtplib | RECIVING EMAIL: MODULE imap #######################
KOD IMAP (w pliku inbox.py): 		https://github.com/codingforentrepreneurs/30-Days-of-Python/commit/8b09ed860dc5d36b1f90c54987c541e2a9317782#diff-07a5d8e5d735aa27245df73d8956d60ce43ccdbd21a672f1f45f39047f959410
									https://www.tutorialspoint.com/python_network_programming/python_imap.htm
KOD SMTP (w pliku send_mail.py): 	https://github.com/codingforentrepreneurs/30-Days-of-Python/commit/8b09ed860dc5d36b1f90c54987c541e2a9317782#diff-0068d3b04d9889c399f27998909e2adca26494b4c823a2adcbb5edaaf73f856b
									https://www.tutorialspoint.com/python_network_programming/python_smtp.htm
									
2* RECIVING EMAIL by IMAP (MODULE imaplib i MODULE email):
 ** Cały potrzebny kod w pliku inbox.py: 	https://github.com/codingforentrepreneurs/30-Days-of-Python/commit/8b09ed860dc5d36b1f90c54987c541e2a9317782#diff-07a5d8e5d735aa27245df73d8956d60ce43ccdbd21a672f1f45f39047f959410
 O) PROTOKÓŁ IMAP:
		*odpowiada za synchronizację oraz odbieranie wiadomości e-mail.
		*jego główną zaletą jest możliwość synchronizacji wszystkich folderów wiadomości, między różnymi 
		 programami pocztowymi oraz urządzeniami mobilnymi. Oznacza to, że wiadomość e-mail pobierana z 
		 serwera nie jest automatycznie z niego usuwana.
 A) MODUŁ IMAP:
		*pobranie odpoweidenich modułów:
				import imaplib
				import email
		*utworzenie najważniejszych zmiennych do połączenia:
				host='imap.gmail.com'
				username='antekmarek555@gmail.com'
				password='pythonEntrepreneurs'
		*stworzenie połączenia i wybranie sekcji wiadomości 'ODEBRANE (inbox)'
				def get_inbox():
					mail=imaplib.IMAP4_SSL(host)
					mail.login(username,password)
					mail.select("inbox")
					my_message = []					#przygotowanie kontenera na wiadomości
		*pobranie numerów wiadomośći. Wybierasz tylko te nieodczytane:
					downloading_info, search_data=mail.search(None, 'UNSEEN')
													#donloading_info zwróci Tobie 'OK' jeżeli
													# uda się pobrać numery wiadomości 
													# (nie interesuje nas to)
													#search_data zwróci w postaci binearnej 
													# numery nieprzeczytanych wiadomości	
 B) Wyciągnięcie danych z pobranych wiadomości:
		*Przejście po pojedyńczym każdym numerze wiadomości (z uzyskanego wcześniej search_data):
					for num in search_data[0].split():
						email_data = {}
		*Pobranie danej wiadomości i wszystkich danych z każdą związanych:
						downloading_info, data = mail.fetch(num, '(RFC822)')
											#downloading_info zwróci OK (nie interesuję nas to)
											#data zwróci wiadomość z danymi z nią związaną 
		*kontynuacja pobieranie wiadomośći i wszystkich danych z nią związanych poprzez odwołanie się do 
		 pierwszej komórki listy data:
						number_email, b= data[0]	#downloading info zwróci: b'3 (RFC822 {538}'
													#zmienna b stanowi całą wiadomość z innymi
													#ważnymi rzeczami z nią związanymi
		*pobranie już właściwej wiadomości przy pomocy moduły email:
						email_message = email.message_from_bytes(b)
 C) Przejście po wiadomości (po każdej pojedyńczo):
		*zapisanie w słowniku email_data oraz wyświetlenie wartośći dla kluczy:
		 FROM, TO, SUBJECT, DATE:
						for header in ['subject', 'to', 'from', 'date']:
							print("{}: {}".format(header, email_message[header]))
							email_data[header] = email_message[header]
		*przejście po treści wiadomości przez metody: walk(), get_content_type() i get_payload() wraz ze
		 sprawdzeniem czy do czynienia mamy z tekstem czy z tekstem HTML:
					    for part in email_message.walk():
							if part.get_content_type() == "text/plain":
								body = part.get_payload(decode=True)
								email_data['body'] = body.decode()
							elif part.get_content_type() == "text/html":
								html_body = part.get_payload(decode=True)
								email_data['html_body'] = html_body.decode()
        *przypisanie konkretnej wiadomosci do kontenera wiadomości, zakończenie pracy serwera oraz zwrot
 		 wszystkich wadomośći po zakończeniu działania funkcji:
						my_message.append(email_data)
						mail.close()
					return mymessage
 D) ODPALENIE FUNKCJI przy uruchamianiu pliku w terminalu (komenda: python3 -i inbox.py):
				if __name__ == "__main__":
					my_inbox = get_inbox()
					print(my_inbox)
		
1* SENDING EMAIL by SMTP:(MODULE smtplib & MODULE email.mime.text & MODULE email.mime.multipart)
 ** Cały potrzebny kod w pliku send_mail.py: 	https://github.com/codingforentrepreneurs/30-Days-of-Python/commit/8b09ed860dc5d36b1f90c54987c541e2a9317782#diff-0068d3b04d9889c399f27998909e2adca26494b4c823a2adcbb5edaaf73f856b
 O* PROTOKÓŁ SMTP wraz ze wsparciem standartu MIME:
		*protokół SMTP - pozwala tylko na wysyłanie wiadomości a nie na synchronizacje folderów pocztowych. 
			(pobierania wiadomości ze skrzynki e-mail serwera). Protokół SMTP nie ma swojego następcy ani 
			odpowiednika w innych protokołach. Wykorzystuję się go m.in w formularzach kontaktowych na 
			stronach internetowych. 
		*standart MIME - definiuję budowę maili w protokole SMTP oraz pozwala je formatować 	
 A) Na początku musisz mieć odpowiednio skonfigurowanego swojego maila któy pozwoli ci na dostępnośc przez 
    pliki pythona np.: w gmailu musisz:
	  *w sekcji security odznaczyć "Less Secure apps/dostęp do mniej bezpiecznych aplikacji"
	  *musisz wejść w link: https://accounts.google.com/DisplayUnlockCaptcha tak żeby pojawił ci się tekst: 
	   "Account access enabled" po to żeby twój plik.py mógł się logować.
	w przypadku gdybyś chciał wysyłać tysiące takich maili to o wiele lepiej jest skorzytać z 
	maila/aplikacji sendgrid  która pozwoli wysyłać ci tysiące maili bez ograniczeń.
 B) MODUŁ smtplib - wykorzystuję się go do:
		*ustanowienia połączenia z podanym serwerem w argumencie i podanym domyślnym portem 587:
			*możesz zapisać w pierwszej formie, przypisując do zmiennej server:
					server=smtplib.SMTP(host='smtp.gmail.com', port=587)
			*możesz zapisać wykorzystując formułę with:
					with smtplib.SMTP(host='smtp.gmail.com', port=587) as server:
						server.login()...
		*skonfigurowania domyślnych ustawień:
					server.ehlo()
		*ustanowienia bezpiecznego połączenia:
					server.starttls()
		*logowania na maila (konkretnie na SMTP SERVER)
					username='antekmarek555@gmail.com'
					password='pythonEntrepreneurs'
					server.login(username, password)
		*wysłanie maila:
					server.sendmail(from_addr="",to_addrs="antekmarek555@gmail.com",msg="Czesc")
			*argument from_addr="..." - nie musi zawierać naszego maila, może być nawet puste pole gdyż i 
			 tak to zostanie pobrane z nazwy loginu 
			*argument to_addr - trzeba wpisać albo pojedyńczego maila w postaci stringa albo maile w postaci
 			 listy stringów
			*argument msg - przyjumuję wartość w postaci stringa
		*zakończenia połączenia:
					server.quit()
 C) MODULE email.mime.text & MODULE email.mime.multipart -wykorzystuję się do formatowania maila który 
      będzie wysłany. Formatowane są: Subject, From (od kogo - oprócz maila zapisywane jest imie w 
	  sekwencji "Od Antka <antekmarek555@gmail.com"), To (do kogo zostały wysłane maila, wymienione po 
	  przecinku) oraz tekst który może przybrać formę zwykłą lub HTML'a (te 2 moduły i funkcje z nimi 
	  związane są PRZED MODUŁEM SMTP):
		*trzeba najepierw pobrać moduły:
					from email.mime.text import MIMEText			#formatowanie tekstu maila
					from email.mime.multipart import MIMEMultipart	#formatow. From, To, Subject
		*sformatować From, To, Subject:
					msg = MIMEMultipart('alternative')		#musisz podać argument 'alternative'
					msg['From'] = from_email
					msg['To'] = ", ".join(to_emails)
					msg['Subject'] = subject
		*sformatować tekst maila:
					text="moj tekst wiadomosci"
					txt_part = MIMEText(text, 'plain')
					msg.attach(txt_part)
					msg_str = msg.as_string()
		*sformatować część htmla tekstu w mailu:
					html="<h1>moj tekst wiadomosci HTML</h1>"
					if html != None:
						html_part = MIMEText(html, 'html')
						msg.attach(html_part)		#dodając text htmla, wcześniejsze dodanie 
					msg_str = msg.as_string()		#tekstu nie będzie załączone tylko 
													#zostanie nadpisane przez tego htmla
											

############################################################################################################
########################## CSV | XML | JSON | API | BAZY DANYCH:  SQLite ###################################
SQLite:				https://www.youtube.com/watch?v=pd-0G0MigUA
API JSON example:	https://www.py4e.com/code3/geojson.py
API XML example:	https://www.py4e.com/code3/geoxml.py
JSON MODULE:		https://www.w3schools.com/python/python_json.asp
XML:				https://www.py4e.com/html3/13-web
					https://nowaker.net/post/xml-instance-xml-schema.html
CSV:				https://www.youtube.com/watch?v=Xi52tx6phRU  

5* BAZA DANYCH SQLITE:
   https://www.youtube.com/watch?v=pd-0G0MigUA
	*PODSTAWY:
		*używa się głównie w sytuacjach gdy potrzebujesz funkcjonalności sql'owej bazy danych ale nie 
		 chcesz ogarniać tego przez w pełni sql-ową bazę danych typu Postgres albo MySql
		*SQLite jest IDEALNE do małych lub średnich aplikacji w któych działasz na małej utworzonej bazie
		 danych lub do prototypowania gdzie baza danych istnieje tylko w podręcznej pamięci i jest usuwana 
		 wraz z zakończeniem pracy programu 
		*przy chęci zmiany na inną bazę danych np Postgresa da się łatwo to zrobić (tzw SQL ALCHEMY)
		*TYPY DANYCH:
			*NULL - NULL value
			*INTEGER - signed integer
			*REAL - floating point value
			*TEXT - text string value
			*BLOB - The value is a blob of data, stored exactly as it was input
	*POŁĄCZENIE I FUNKCJE PYTHONOWE w SQLITE:	
		0*jest w bibliotece standardowej więc nie trzeba go nawet instalować wystarczy tylko zaimportowanie:
					import sqlite3
		1*musisz połączyć się z bazą danych przy pomocy metody connect(), wybierając czy chcesz stworzyć 
		  plik sql'owy czy mieć utworzoną bazę w pamięci RAM (nie powstanie plik sqlowy i baza zostanie 
		  usunięta po zakończeniu pracy programu):
			  *wybierając konkretną bazę danych (wpisujesz nazwę pliku) - jeżeli plik podany w argumencie 
			   nie istnieje to zostanie utworzony:
					conn = sqlite3.connect('music.db')
			  *wybierając pamięc podręczną RAM (przy każdym uruchomienieu programu powinineś tworzyć bazę 
			   danych i dodawać do niej rekordy gdyż po zakończeniu programu baza zostanie usunięta):
					conn = sqlite3.connect(':memory:')
		  oraz wywołać na tej bazie danych metodę cursor() 
					cur = conn.cursor()
		2* Na tym kursorze wykonywac operacje sql poprzez metode execute() i albo je scommitować albo 
		   wszystko zawrzeć w bloku context managera:
			  *po wszystkich takich operacjach musisz scommitować je by mieć pewność że zostaną one 
			   wywołane (poprzez metode commit() na obiekcie connection):
					cur.execute('DROP TABLE IF EXISTS Tracks')
					cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
					cur.execute("INSERT INTO Tracks VALUES('tytuł', 20)")
					...
					conn.commit()
					conn.close()
			  *możesz też nie commitować oraz nie zakańczać połączenia ale wtedy musisz zawrzeć wszystko w
			   bloku context managera:
					conn = sqlite3.connect('music.db')
					cur = conn.cursor()
					with conn:
						cur.execute('DROP TABLE IF EXISTS Tracks')
						cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
						cur.execute("INSERT INTO Tracks VALUES('tytuł', 20)")
						...
		3* W przypadku SELECTÓW - by dostac się do zwracanych wartości musisz odwołać się na obiekcie 
		   cursora do metod:
			*fetchone() - zwraca jako krotkę, każdy kolejny wierz z wyniku funkcji SELECT (tak jak iterator):
					cur.execute("""SELECT * FROM music""")
					print(cur.fetchone())
					print(cur.fetchone())
			*fetchall() - zwraca jako listę krotek wszystkie wiersze wyniku funkcji SELECT:
					cur.execute("""SELECT * FROM music""")
					print(cur.fetchall())
	***PRZYKŁADOWE KODY SQLite:
			A)
					import sqlite3
					conn = sqlite3.connect('music.db')
					cur = conn.cursor()
					cur.execute('DROP TABLE IF EXISTS Tracks')
					cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
					cur.execute("INSERT INTO Tracks VALUES('tytuł', 20)")
					cur.execute("INSERT INTO Tracks VALUES('tytuł2', 20)")
					cur.execute("""SELECT * FROM Tracks""")
					print(cur.fetchone())
					print(cur.fetchone())						#najpierw zwróci jeden a później drugi
					print(cur.fetchall())
					conn.commit()
					conn.close()
			B)
					import sqlite3
					conn = sqlite3.connect('music.db')
					cur = conn.cursor()
					with conn:
						cur.execute('DROP TABLE IF EXISTS Tracks')
						cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
						cur.execute("INSERT INTO Tracks VALUES('tytuł', 20)")
						cur.execute("INSERT INTO Tracks VALUES('tytuł1', 20)")
						cur.execute("""SELECT * FROM Tracks""")
						print(cur.fetchone())
						print(cur.fetchone())					#najpierw zwróci jeden a później drugi
						print(cur.fetchall())
					conn.close()
	*DZIAŁANIA SQL'owe w PYTHONIE w SQLITE:
		**schemat dzialania dla pliku SQL jest taki że zawsze najpierw usuwasz całą bazę danych po to żeby 
		  stworzyć ją na nowo i wypełnić danymi - a wszystko po to żeby nie wyskoczył błąd
					cur.execute('DROP TABLE IF EXISTS Tracks')
					cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
		**jeżeli chcemy odwołać się do PYTHONOWYCH zmiennych w zapytaniu SQL to: 
			*NIE WOLNO używać do tego operacji F'string lub metody format (tak jak poniżej) ze względu na
  			 atak hakerski SQL INJECTION:
					cur.execute("INSERT INTO Tracks VALUES ('{}', {})".format('Tytuł', 20) 	#tak nie wolno
			*odwołanie do zmiennych pythonowych robisz poprzez zapisywanie znaków zapytania w instrukcji 
			 sqla i po zapytaniu po przecinku dajesz krotkę z tą samą ilością zmiennych co ilość znaków 
			 zapytania. W ten sposób podmieniasz te znaki zapytania na te zmienne w krotce:
					title, long ='My Way', 15
					cur.execute('INSERT INTO Tracks (title, plays) VALUES (?, ?)', (title, long))
			 tak samo możesz odwołać się do zmiennych w instrukcji SELECT np: w warunku WHERE (pamiętaj o 
			 tym że jeżeli wypisujesz w krotce pojedyńczą zmienną to musisz ją zakończyć przecinkiem):
					cur.execute('SELECT * FROM Tracks WHERE title = ?', (' Tytuł',))					
			*zamiast znaków zapytania możesz też użyć kluczy do Słownika (Dictionary) których nazwy będą 
			 odpowiadać nazwom kolumn sql'owych utworzonych wcześniej przez instrukcje CREATE TABLE.
			 Wartości (przypisane do kluczy) będą odpowiadać wcześniej utworzonym zmiennym (wypiszesz
			 je tak jak w poprzednim przypadku, po przecinku (zamiast w krotce to w kolekcji Dictionary)
			 za instrukcją sqlową wg schematu: {'klucz': wartosc, 'klucz': wartosc)}
					title, long ='My Way', 15
					cur.execute('INSERT INTO Tracks (title, plays) 
						VALUES (:title, :plays)', {'title': title, 'plays':long})
			tak samo możesz odwołać się do zmiennych w instrukcji SELECT np w warunku WHERE :
					cur.execute('SELECT * FROM Tracks WHERE title = :title', {'title': 'Tytuł'})
		**w przypadku gdybś chciał stworzyć osobne funkcje w których chiałbyś zawrzeć wykonywanie instrukcji
		  sqlowych to musisz wczesniej stworzyć obiekt connection i cursor a w funkcji zawrzeć instrukcje
		  sql'ową w bloku contexta managera odwołującego się właśnie do tego obiektu connection:
					conn = sqlite3.connect('music.db')
					cur = conn.cursor()
					def insert_track(track):
						with conn:
							cur.execute("INSERT INTO Track VALUES (?,?)",(track.title, track.long))
					...
					conn.close()
		  w takim bloku nie musisz wpisywać instrukcji sqlowych które nie potrzebują zacommitowania takich 
		  jak SELECT:
					conn = sqlite3.connect('music.db')
					cur = conn.cursor()
					def get_track_title(track):
						cur.execute('SELECT * FROM Track WHERE title=?',(track.title,))
						return cur.fetchall()
					...
					conn.close()

4*API - pobranie danych:
	*pobierasz bilbioteki jsona i do sparsowania oraz otwarcia URLa (urllib)
				import urllib.request, urllib.parse, urllib.error
				import json
	*przy pomocy funkcji urllib.parse.urlencode({'address': zmiennaAddress,'key':zmiennaKey}) parsujesz 
	 zmienne na odpowiedni kod który pózniej przyłączysz do bazowego linku (w tym linku '+' będzie oznaczał 
	 spacje a '%2C' będzie oznaczał kropkę 
				url = serviceurl + urllib.parse.urlencode({'address': parameters['address'], 
														   'key': parameters['key']})
	*przy pomocy funkcji urllib.request.urlopen(url) pobierasz dane z linku
	*nastepnie je czytasz (read()) odkodowujesz (decode()) i zapisujesz w zmiennej która będzie miała 
	 STRINGA JSONa
	*ładujesz dane ze stringa JSONa do danej kolekcji w Pythonie 
				html=urllib.request.urlopen(url)
				jsonData=html.read().decode()
				jsonPython=json.loads(jsonData)
	*przypisujesz do zmiennych poszczegolne elementy z tejze kolekcji, po czym je wyswietlasz
	*PRZYKŁAD GEOCODE GOOGLE MAPS API:      	https://www.py4e.com/code3/geojson.py
				import urllib.request, urllib.parse, urllib.error
				import json
				import ssl
				
				api_key=False
				# If you have a Google Places API key, enter it here
				# api_key = 'AIzaSy___IDByT70'
				# https://developers.google.com/maps/documentation/geocoding/intro
				
				if api_key == False:
					api_key = 42
					serviceurl = 'http://py4e-data.dr-chuck.net/json?'
				else:
					serviceurl = 'https://maps.googleapis.com/maps/api/geocode/json?'
				
				# Ignore SSL certificate errors
				ctx = ssl.create_default_context()
				ctx.check_hostname = False
				ctx.verify_mode = ssl.CERT_NONE

				while True:
					location = input('Enter location: ')
					location = "Ann Arbor, MI"
					if len(location)<1: break
					
					parameters=dict()
					parameters['address'] = location
					parameters['key'] = api_key
					url = serviceurl + urllib.parse.urlencode({'address': parameters['address'],
															   'key':parameters['key']})
					print('Uzyskano url =: ',url)

					html = urllib.request.urlopen(url)
					jsonData=html.read().decode()
					print('JSONdata length:',len(jsonData),'characters')
					print(jsonData)

					try:
						jsonPython= json.loads(jsonData)
						print('JSONloads:', jsonPython)
					except:
						jsonPython=None
					if not jsonPython or jsonPython['status'] !='OK' or 'status' not in jsonPython :
						print("=============FAILURE TO RETRIVE============")
						print(jsonData)
						continue

					lat = jsonPython["results"][0]["geometry"]["location"]["lat"]
					lng = jsonPython["results"][0]["geometry"]["location"]["lng"]
					loc = jsonPython["results"][0]["formatted_address"]
					print('lat:',lat,'lng:',lng)
					print('EnteredLocation:',location,', GoogleLocalization:',loc)
					

3* JSON MODULE:
METODY JSON:	https://www.w3schools.com/python/python_json.asp
	*to wbudowany (built-in) moduł w pythona - wystarczy go zaimportowac (nie trzeba instalowac)
	*JSON prezentuje dane jako zagniezdzone Dictionary albo zagnieżdżone Listy. 
		*JSON to typ plikow i specjalna składnia do przechowywania i wymiany danych 
		*w Pythonie JSON zapisany jest jak String (najlepiej zawrzec w 3 apostrofach) ale różni się tym że:
			*stringi w JSONie mogą być zapisane TYLKO przy pomocy PODWÓJNYCH CUDZYSŁOWIÓW
			*true i false są zapisane od małej litery zamiast dużej
			*zamiast None masz null
			*klucze mogą być tylko stringami ale wartości dla kluczów mogą być poniższymi typami danych:
				-string
				-int
				-true or false
				-list
				-null
				-inny JSON object
				
	  *zagnieżdzone Dictionary w Dictionary
			import json
			data='''{
				"name" : "Chuck",
				"phone" : {
							"type" : "init1",
							"number" : "+1 734 303 4456" 
						   },
				"email" : {
							"hide" : "yes"
						   }
				}'''
			zmienna = json.loads(data)				   #zmienna to teraz DICTIONARY   #ZWRÓCI:
			print('Name:',zmienna["name"])			   Name: Chuck
			print('Phone:',zmienna["phone"]) 		   Phone: {'type': 'init1', 'number': '+1 734 303 4456'}
			print('Email:',zmienna["email"])		   Email: {'hide': 'yes'}
			print('Hide:',zmienna["email"]["hide"])	   Hide: yes
		
	  *zagnieżdzone Dictionary w liście:
			import json
			data='''[
				{"id" : "001",
				 "x" : "2",
				 "name" : "Chuck"
				},
				{"id" : "009",
				 "x" : "7",
				 "name" : "Buck"
				}
					]'''
			zmienna= json.loads(data)					#zmienna to teraz LISTA
			print('User counts:',len(zmienna))
			for i in zmienna:							#ZWRÓCI (po enterze - \n):
				print("Id",i['id'])						Id 001  \n  Name Chuck  \n  Attribute 2
				print("Name",i['name'])					Id 009  \n  Name Buck  \n  Attribute 7
				print("Attribute",i['x'])
	*FUNKCJE W PYTHONIE -  wszystkie funkcje automatycznie parsują dane ze składni Pythona na JSON'a i na 
	 odwrót, np.: None na null albo True na true.
	  *ZAMIANA JSON na Python:
		*json.loads(string) - ładuję dane json ze stringa:
			import json
			x =  '{ "name":"John", "age":30, "city":"New York"}'	#STRING 
			y = json.loads(x)										#zamiana - rezultatem jest:
			print(y["age"])											#kolekcja Dictionary
		*json.load(file) - ładuję dane z pliku json lub z pliku txt o składni jsona:
			import json
			json_file=open('path/nameFile.json', 'r', encoding='utf-8') 	/  	 #'path/nameFile.txt'
			x=json.load(json_file)
			print(y["age"])
	  *ZAMIANA Python na JSON:
		*json.dumps(string) - zamienia obiekt python'a na stringa o składni json:
			import json
			x = {"name": "John", "age": 30, "city": "New York"}		#kolekcja Dictionary
			y = json.dumps(x)										#zamiana na STRINGA
			print(y)
		*json.dumps(string,file) - zamienia obiekt python'a na plik .json (da się otworzyć jak zwykły txt)
		 o składni json'a:
			import json
			x = {"name": "John", "age": 30, "city": "New York"}		#kolekcja Dictionary
			with open('data.json', 'w', encoding='utf-8') as f:
				json.dump(x, f, ensure_ascii=False)					#ensure_ascii=False pozwala na
																	#umieszczenie znaków polskich: ł,ś,ć				
	*WAŻNE INFORMACJE:			
		*Na JSONa mozesz zamieniac te typy danych:
		  *kolekcje: list, tuple, dict	(NIE set!)
		  *zmienne: string, int, float 
		  *inne: True, False, None 
		*Te typy danych zostaną zamienione w JSON'ie na:
		  dict  ->  Object
		  list  ->  Array
		  tuple ->  Array
		  str	->  String
		  int	->  Number
		  float ->  Number
		  True  ->  true
		  False ->  false
		  None  ->  null
		*Żeby pliki JSON były ładniej zapisane (ze wcieciami zamiast w jednym wierszu) to użyj przy zamianie
 		 pythona na JSONa parametru indent=4: 	
			json.dumps(x, indent=4)
		*możesz zdefiniować separatory - domyślnie są to przecinek i dwukropek: default value is (", ", ": ")
			json.dumps(x, indent=4, separators=(". ", " = "))
		*możesz także wszystkie klucze w JSON'ie uporzadkowac alfabetycznie poprzez parametr sort_keys=True:		
			json.dumps(x, indent=4, sort_keys=True)
			
2* XML - język do przesyłu danych bez konkretnego jezyka:
https://www.py4e.com/html3/13-web
https://nowaker.net/post/xml-instance-xml-schema.html
https://diveintopython3.net/xml.html#xml-parse 
https://docs.python.org/3/library/xml.etree.elementtree.html
	*SKRÓT:
		*PRZEJDŹ OD RAZU DO DZIAŁU --> XML W PYTHONIE
	*BUDOWA:
		*spacje entery i taby nie mają znaczenia w XMLu tylko to: wewnatrz jakich innych tagów jest dany tag
		*The first element in every xml document is called the root element. An xml document can only have 
		 one root element.  xml documents can contain character encoding information on the first line, 
		 before the root element
				<?xml version='1.0' encoding='utf-8'?>
				<feed xmlns='http://www.w3.org/2005/Atom'> 
				  <title>dive into mark</title>           
				</feed>
		*Pozostała struktura:
			*hierarchiczna struktura - węzeł rodzica i dziecka: <foo></foo>
			*There is a self-closing tag also: <foo/>
			*Rodzaje Tagów:
				*start TAG							<person>
													  <name>Chuck</name>
													  <phone type="intl">
				*text content							+1 734 303 4456
				*self-closing TAG & attribute		  <email hide="yes" />
				*end TAG							</person>
			*Atrybuty:
				*Elements can have attributes: <bar lang='fr'>content</bar>
				*mozesz miec w jednej parze TAGow tylko jeden text content ale za to wiele atrybutów ktore 
				 mozesz definiowac jak chcesz
		*Elementy XMLa mogą byc zadeklarowane w różnych przestrzeniach nazw (namespaces). Namespace wygląda 
		 jak atrybut elementu w postaci linku URL, używający znacznika xmlns 
		 (np: xmlns='http://www.w3.org/2005/Atom') i ma za zadanie oznaczyć element w którym został 
		 zadeklarowany i wszystkie jego węzły dzieci (The namespace declaration affects the element where 
		 it’s declared, plus all child elements.)
			*Jeżeli dokument XML będzie korzystal z przestrzeni nazw http://www.w3.org/2005/Atom' to znaczy 
			 że jego elementy będą miały nazwy według standardu 'Atom' i dzięki temu będziesz mógł korzystać
			 z pewnych bibliotek w Pythonie które pozwolą ci wyszukiwać dane nazwy tagów (według 
			 ustandaryzowanej przestrzeni nazw Atom)
				*W takim ustandaryzowaniu głównym tagiem/rootem jest tag feed w którym oprócz atrybutu
				  przestrzeni nazw Atom xmlns='http://www.w3.org/2005/Atom' możesz dodać atrybut 
				  xml:lang='en' 
				*inne tagi to: title, subtitle, id, updated, link (z atrybutami rel, type, href), author, 
				 category, summary i inne:
						<?xml version='1.0' encoding='utf-8'?>
						<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
						  <title>dive into mark</title>
						  <subtitle>currently between addictions</subtitle>
						  <id>tag:diveintomark.org,2001-07-29:/</id>
						  <updated>2009-03-27T21:56:07Z</updated>
						  <link rel='alternate' type='text/html' href='http://diveintomark.org/'/>
						  <link rel='self' type='application/atom+xml' href='http://diveintomark.org/feed/'/>
						  <entry>
							<author>
							  <name>Mark</name>
							  <uri>http://diveintomark.org/</uri>
							</author>
							<title>Dive into history, 2009 edition</title>
							<link rel='alternate' type='text/html'
							  href='http://diveintomark.org/archives/2009/03/27/dive-into-history-2009-edition'/>
							<id>tag:diveintomark.org,2009-03-27:/archives/20090327172042</id>
							<updated>2009-03-27T21:56:07Z</updated>
							<published>2009-03-27T17:20:42Z</published>
							<category scheme='http://diveintomark.org' term='diveintopython'/>
							<category scheme='http://diveintomark.org' term='docbook'/>
							<category scheme='http://diveintomark.org' term='html'/>
						  <summary type='html'>Putting an entire chapter on one page sounds
							bloated, but consider this &amp;mdash; my longest chapter so far
							would be 75 printed pages, and it loads in under 5 seconds&amp;hellip;
							On dialup.</summary>
						  </entry>
						  <entry>
							<author>
							  <name>Mark</name>
							  <uri>http://diveintomark.org/</uri>
							</author>
							<title>Accessibility is a harsh mistress</title>
							<link rel='alternate' type='text/html'
							  href='http://diveintomark.org/archives/2009/03/21/accessibility-is-a-harsh-mistress'/>
							<id>tag:diveintomark.org,2009-03-21:/archives/20090321200928</id>
							<updated>2009-03-22T01:05:37Z</updated>
							<published>2009-03-21T20:09:28Z</published>
							<category scheme='http://diveintomark.org' term='accessibility'/>
							<summary type='html'>The accessibility orthodoxy does not permit people to
							  question the value of features that are rarely useful and rarely used.</summary>
						  </entry>
						  <entry>
							<author>
							  <name>Mark</name>
							</author>
							<title>A gentle introduction to video encoding, part 1: container formats</title>
							<link rel='alternate' type='text/html'
							  href='http://diveintomark.org/archives/2008/12/18/give-part-1-container-formats'/>
							<id>tag:diveintomark.org,2008-12-18:/archives/20081218155422</id>
							<updated>2009-01-11T19:39:22Z</updated>
							<published>2008-12-18T15:54:22Z</published>
							<category scheme='http://diveintomark.org' term='asf'/>
							<category scheme='http://diveintomark.org' term='avi'/>
							<category scheme='http://diveintomark.org' term='encoding'/>
							<category scheme='http://diveintomark.org' term='flv'/>
							<category scheme='http://diveintomark.org' term='GIVE'/>
							<category scheme='http://diveintomark.org' term='mp4'/>
							<category scheme='http://diveintomark.org' term='ogg'/>
							<category scheme='http://diveintomark.org' term='video'/>
							<summary type='html'>These notes will eventually become part of a
							  tech talk on video encoding.</summary>
						  </entry>
						</feed>
						
	*XML SCHEMA - XML mozesz tworzyc jak chcesz ale musisz do niego stworzyc plik XML SCHEMA
				  ktory bedzie zbiorem zasad przy wypełnianiu/czytaniu naszego pliku XML
		*korzystamy z generatorów pliku XML SCHEMA oraz validatorów w celu sprawdzenia czy 
		 pliki zgadzają się ze sobą. Są różne standardy w tworzeniu plików XML i XML Schema -> 
		 najpopularniejszy to specyfikacja XML Schema from W3C - XSD (XSD gdyz pliki kończą 
		 się rozszerzeniem .xsd)
		*XSD struktura - różne typy tagów i znaczników (ponizej sa tylko wymienione tagi i 
						 znaczniki (tak nie wygląda plik xlm schema)):
		  *<xml version="1.0" encoding="utf-8" ?>
		  *	<xs:schema></xs:schema> 
		      **atrybuty dla tagu schema:
		  		elementFormDefault="qualified"
		  		xlmns:xs="http://www/w3.org/2001/XMLSchema"
		  					#albo tworzysz element z atrybutem albo complexType z atrybutem
		  *	<xs:element name="person"></xs:element>
		  *	<xs:complexType name ="person"></xs:complexType>
		  *	<xs:sequence></xs:sequence>
		  *	<xs:element />
		      **różne atrybuty dla tagu element:
		 		name="full_name"
				minOccurs="1"
			    maxOcurs="unbounded"
			    type="xs:string" 
				  **rozne wartosci dla atrybutu 'type':
						[xs:string [dla: John], xs:date [dla: 2002-9-24], xs:decimal [dla: 999.50], 
				         xs:integer[dla: 30], xs:positiveInteger [dla: 30]
						 xs:dateTime [dla: 2002-05-30T09:33:10Z</startdate>]
						 (Z - Zulu Time Zone czyli GreenwichTime in London)]
		  *	<xs:SimpleType></xs:SimpleType>
		  *	<xs:restriction base="xs:string"></xs:restriction>
		  *	<xs:enumeration value="FR" />
		* Przykład pliku XML SCHEMA:
				<?xml version="1.0" encoding="UTF-8" ?>
				<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
				<xs:element name="shiporder">
				  <xs:complexType>
					<xs:sequence>
					  <xs:element name="orderperson" type="xs:string"/>
					  <xs:element name="shipto">
						<xs:complexType>
						  <xs:sequence>
							<xs:element name="name" type="xs:string"/>
							<xs:element name="address" type="xs:string"/>
							<xs:element name="city" type="xs:string"/>
							<xs:element name="country" type="xs:string"/>
						  </xs:sequence>
						</xs:complexType>
					  </xs:element>
					  <xs:element name="item" maxOccurs="unbounded">
						<xs:complexType>
						  <xs:sequence>
							<xs:element name="title" type="xs:string"/>
							<xs:element name="note" type="xs:string" minOccurs="0"/>
							<xs:element name="quantity" type="xs:positiveInteger"/>
							<xs:element name="price" type="xs:decimal"/>
						  </xs:sequence>
						</xs:complexType>
					  </xs:element>
					</xs:sequence>
					<xs:attribute name="orderid" type="xs:string" use="required"/>
				  </xs:complexType>
				</xs:element>
				</xs:schema>
				
				
	*XML w PYTHONIE:
	  *musisz pobrać moduł xml.tree.ElementTree as ET (dobrze dopisac sobie alias do tego)
						import xml.etree.ElementTree as ET
	  *dane przetrzymujesz w potrójnych apostrofach w stringu albo w pliku xml
	  *PODSTAWOWE FUNKCJE:
			*fromstring(stringxml)
				*odczytuje ze stringa struktury xml i zwraca zmienną typu elementxml 
				*z modułu xml.tree.ElementTree biezesz funkcje fromstring(stringxml) którą 
				 podajesz w argumencie dla funkcji ElementTree:
						import xml.etree.ElementTree as ET
						tree = ET.ElementTree(ET.fromstring(stringxml))
			*parse('filexml')
				*odczytuję z pliku xml jego strukture i zwraca zmienną typu elementxml
				*w argumencie wpisujesz w cudzysłowach ścieżkę do pliku xml
						import xml.etree.ElementTree as ET
						tree = ET.parse('examples/feed.xml')
		*DODATKOWE:
			***tostring(elementxml)	
				*nie służy do odczytywania pliku xml tylko do konwersji struktury xmla do stringa
				*w argumencie wpisujesz zmienną która jest typu: element xml czyli np: root=tree.getroot()
						import xml.etree.ElementTree as ET
						tree=ET.parse('hodlers.xml')
						root=tree.getroot()
						print(ET.tostring(root))
			***write('xmlpath')
				*służy do zapisywania danej struktury do pliku xml(jeżeli nie istniej to go tworzy):
						import xml.etree.ElementTree as ET
						tree = ET.ElementTree(ET.fromstring(stringxml))
						tree.write('namefileXML')
			***append(elementXML)
				*dodawanie do struktury XMLa nowego tagu 
				*najpierw musisz stworzyć element xmla. Możesz to zrobić na 2 sposoby:
					*wykorzystując ET.fromstring("stringxml")
						zmienna = ET.fromstring('<tag>content</tag>')
						root.append(zmienna) 	 / 	 tree.find('.//tagname[@id="3"]').append(zmienna)
					*wykorzystując ET.Element('newTagname')
						zmienna= ET.Element('tag')
						zmienna.text='content'
						root.append(zmienna)	 / 	 tree.find('.//tagname[@id="3"]').append(zmienna)
	   *ROOT:
		   *funkcja getroot() pozwala dostać się do głównego rodzica tagów 
				root = tree.getroot()
		   *(gdbyś chciał wywołać getroota dla wyniku przypisania metody fromstring() to metoda fromstring()
		    musi zostac wywolana jako argument dla metody ElementTree z modułu xml.etree.ElementTree czyli:
						 tree = ET.ElementTree(ET.fromstring(data))
				#zamiast tree = ET.fromstring(data) -> jeżeli tak zrobisz to getroot() nic ci nie zwróci
			*wielkość pierwszej linii dzieci w rootcie uzyskasz poprzez len(root)
			*do dzieci w pierwszej linii dostaniesz się poprzez fora wroot'cie:
				print(root)			#zwroci: <Element {http://www.w3.org/2005/Atom}feed at cd1eb0>
				for child in root:
					print(child)	#zwroci: <Element {http://www.w3.org/2005/Atom}title at e2b5d0>
											 <Element {http://www.w3.org/2005/Atom}subtitle at e2b4e0>  
		    *żeby dostać się do atrybutów na root'cie trzeba wywołać pole attrib. Wtedy atrybuty zostaną 
		     przedstawione w postaci słownika. 
				root = tree.getroot() 
				print(root[4])				#zwroci: <Element {http://www.w3.org/2005/Atom}link at e181b0>		
				print(root[4].attrib)
											#zwroci:	{'href': 'http://diveintomark.org/',
														 'type': 'text/html',
														 'rel': 'alternate'}
	   *CONTENT i ATRYBUTY:
		*możesz odwołać się do contentu poprzez pole text LUB możesz odwołać się do odpowiednich atrybutów 
		 poprzez metode get(), np.: get('id').	 (W przypadku sytuacji gdy używasz jakies przestrzeni nazw
		 w rootcie np: <feed  xmlns='http://www.w3.org/2005/Atom' xml:lang='en'> wtedy zeby wyszukalo Tobie 
		 content albo atrybuty to tagi muszą należeć do tej przestrzeni nazw tzn nazwa tagu musi być jedną
	     z nazw zawierających się w przestrzeni nazw wskazanych w atrybucie xmlns='http://www.w3.org/2005/Atom')
			#PRZYKŁAD 1:
					import xml.etree.ElementTree as ET
					data='''<person id=1>OSOBA
							  <name>Chuck</name>
							  <phone type="init1">
							   +1 734 303 4456
							  </phone>
							  <email hide="yes" />
							</person>'''
					tree = ET.ElementTree(ET.fromstring(data))     #LUB     tree = ET.fromstring(data)
					root=tree.getroot()
					print(root.text)										#zwróci OSOBA
					print(root.get('id'))									#zwróci 1
					print('Name:',tree.find('name').text)					#zwróci Chuck
					print('Attr:',tree.find('email').get('hide'))			#zwróci yes
		*możesz też ustawić w pliku jakiś atrybut taga lub text wewnątrz taga poprzez:
				*ustawienie atrybutu do taga: set('nameattribute', 'contentattribute')
					root.set('nameattribute', 'contentattribute'):
					tree.find('name').set('nameattribute', 'contentattribute')
				*przypisanie contentu do taga: text='contentTag':
					root.text='contentTag'
					tree.find('name').text='contentTag'
			i następnie zapisujesz poprzez metode write('xmlpath') gdzie podajesz ścieżke do pliku xml w 
			przypadku gdy operajuesz na pliku xml(jeżeli taki nie istnieje to zostanie stworzony):
					tree.write('hodlers.xml')
		  *to ustawienie możesz też zrobić dla wielu tagów jednocześnie:
					data='''<crypto coin="Money!!!">INWESTORZY:
								<investor>Joe 1</investor>
								<investor>Joe 2</investor>
							</crypto>'''
					tree=ET.ElementTree(ET.fromstring(data))
					id=1
					for investor in tree.findall('investor'):
						investor.set('id',str(id))
						id+=1
					for investor in tree.findall('investor'):
						print(ET.tostring(investor))
					tree.write('hodlers.xml')
		*możesz też usunąc dany atrybut poprzez funkcje del:
					del(root.attrib['id'])
					del(tree.find('name').attrib['id'])
		 i następnie zapisujesz to poprzez write
					tree.write('hodlers.xml')
					
	   *METODY FIND() i FINDALL()
		   *Na zmiennej root lub na zmiennej tree korzystasz z metod find() oraz findall() gdzie w 
		    argumencie podajesz tagi.
		   *domyślnie szuka tylko w pierwszej linii dzieci dlatego gdy chcesz żeby przeszukało Tobie całe 
		    drzewo to możesz tez wpisać ścieżkę względna w funkcji findall() dzięki czemu przejdzie  ci po 
			całym pliku XML i znajdzie dany tag np: findall('.//count')
		   *Jeżeli chcesz się dostać do każdego tagu to wystarczy podać symbol .// 
			  #PRZYKŁAD 2 oparty na TREE:
				import xml.etree.ElementTree as ET
				data ='''<stuff>
						  <users>
						   <user x="2"> 
							 <id>001</id>      
							 <name>Chuck</name>                
						   </user>
						   <user x="7">
							 <id>009</id>
							 <name>Brent</name>
						   </user>
						  </users>  
						 </stuff>'''
				tree = ET.fromstring(data)
				print(tree.findall('.//'))		#zwroci wszystkie tagi oprócz root'a:
												[<Element 'users' at 0x7fc272960180>, 
												 <Element 'user' at 0x7fc272960220>, 
												 <Element 'id' at 0x7fc27290e130>, 
												 <Element 'name' at 0x7fc27290e180>, 
												 <Element 'user' at 0x7fc27290e220>, 
												 <Element 'id' at 0x7fc27290e270>, 
												 <Element 'name' at 0x7fc27290e2c0>]
				tree = ET.ElementTree(ET.fromstring(data))
				lst = tree.findall('users/user')
				for item in lst:
					print(item) 		#zwroci referencje do wszystkich userów (do ich miejsca w RAMie)
				allIds = tree.findall('.//id')	#zwroci Tobie wszystkie tagi id		
				alltags = tree.findall('.//')	#zwroci Tobie wszystkie tagi oprócz root'a
			  #############################################################################################
			  #PRZYKŁAD 3 wywołanie na ROOTcie:
				import xml.etree.ElementTree as ET
				data ='''<feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'>
						  <users>
						   <user x="2"> 
							 <id>001</id>
							 <name>Chuck</name>                
						   </user>
						  </users>  
						 </feed>'''
				tree = ET.ElementTree(ET.fromstring(data))
				root = tree.getroot()
				print(root.findall('.//'))
				#####
				for child in root:
					print(child.attrib)			
								#zwróci:
									[<Element '{http://www.w3.org/2005/Atom}users' at 0x7f6e4f46c130>, 
									 <Element '{http://www.w3.org/2005/Atom}user' at 0x7f6e4f46c1d0>, 
									 <Element '{http://www.w3.org/2005/Atom}id' at 0x7f6e4f46c270>, 
									 <Element '{http://www.w3.org/2005/Atom}name' at 0x7f6e4f46c310>]
								#poniżej zwrocenie wszyskich atrybutów:
									{}
									{'x': '2'}
									{}
									{}
			  #############################################################################################
			  #PRZYKŁAD 4 -wywołanie na ROOTcie bez przestrzeni nazw (bez xmlns='http://www.w3.org/2005/Atom')
			    import xml.etree.ElementTree as ET
				data ='''<stuff>
						  <users>
						   <user x="2"> 
							 <id>001</id>
							 <name>Chuck</name>                
						   </user>
						   <user x="7">
							 <id>009</id>
							 <name>Brent</name>
						   </user>
						  </users>  
						 </stuff>'''
				tree = ET.ElementTree(ET.fromstring(data))
				root = tree.getroot()
	*PRZYKŁAD API XML - https://www.py4e.com/code3/geoxml.py

1. CSV - Comma Seperated Values:
CSV:		https://www.youtube.com/watch?v=Xi52tx6phRU
			https://www.youtube.com/watch?v=q5uM4VKywbA
	*w skrócie:
		*ODCZYT:
					import csv
					file=open(path, 'r', newline='')
					reader=csv.reader(file)
					header=next(reader)
					data=[row for row in reader]
		*ZAPIS:
					import csv
					file=open(path,'w')
					writer=csv.writer(file)
					writer.writerow(["columnName1","columnName2"])		#zapisujesz header
					writer.writerow(["data1.1", "data1.2"])				#zapisujesz dane
					writer.writerow(["data2.1", "data2.2"])		
		*ODCZYT i ZAPIS:
					with open('plik.csv','r') as csv_file:
						csv_reader=csv.reader(csv_file)
						with open('new_plik.csv','w')as new_csv_file:
							csv_writer=csv.writer(new_csv_file,delimiter='-')
							for line in csv_reader:
								csv_writer.writerow(line)
		*ODCZYT I ZAPIS - DictReader & DictWriter:
					with open('plik.csv','r') as csv_file:
						csv_reader=csv.DictReader(csv_file)
						with open('slownik_csv_plik.csv','w') as new_csv_file:
							fieldnames=['first_name','last_name','email']
							csv_writer=csv.DictWriter(new_csv_file,fieldnames=fieldnames)
							csv_writer.writeheader()       #zapisuję pierwszy rząd z nazwami pól
							for line in csv_reader:        #bierze tylko wartości ze słownika (bez kluczy)
								csv_writer.writerow(line)

	*są to pliki excelowskie które można odczytać dzięki specjalnemu modułowi csv. Składają się one 
		*z pierwszego wiersza - który jest nazwami kolumn wymienionymi po przecinku albo średniku
		*z pozostałych wierszy - które są wartościami dla każdej z kolumn wymienionymi po przecinku
			(rzadziej średniku, domyślnie jednak po przecinku). Jeżeli są pod rząd dwa przecinki (lub
			średniki) ze spacją po środku to oznacza to że dane pole jest puste.
	*module csv zawiera specjalne METODY (które zwracają obiekt strumieniowy):
		*csv.reader(plikCSV):
			*służy do odczytu wszystkich linii w pliku csv. Normalnie do tego celu użyłbyś metody 
			 readlines() jednakże ona zwróci Tobie listę wszystkich linijek w postaci stringów które
			 wewnątrz (na samym końcu Stringa) będą zawierać znak entera. (Musiałbyś dlatego użyć metod
			 strip() a potem split())
					file=open(path)
					lines=[line.strip().split(',') for line in file]
					file.close()
			 to czy tak czy tak tworzy wiele problemów jak choćby to że na początku linijki możesz miec
			 cudzysłów który będzie odcięcty poprzez metodę strip. Dlatego lepiej użyć MODUŁU CSV
			*READER - csv.reader(plikCSV) zwróci Tobie listę list stringów pod warunkiem że domyślnym 
			 separatorem dla każdego wiersz (czyli parametr delimiter będzie ustawiony na przecinek).
			 Przy otwarciu pliku pamiętaj też o parametrze newline='' gdyz na róznych platformach może
			 to być nie tylko znak entera \n ale także inne jak np carriage return. 
					import csv
					plikCSV = open(path, 'r', newline='')
					reader=csv.reader(plikCSV)
					for line in reader:		LUB		print(next(reader))
						print(line)					[print(row) for row in reader]
													#zwróci Tobie najpierw pierwszą linie gdize masz 
													#nazwy kolumn a potem zwróci Tobie wszystkie inne
			*gdyby separatorem był inny znak np średnik a w csv.reader(plikCSV) parameter delimiter nie
			 byłby na niego ustawiony to csv.reader(plikCSV) zwróci Tobie listę list które zawierają jedną
			 linię w postaci Stringa. 
					import csv
					plikCSV = open(path, 'r')
					reader=csv.reader(plikCSV, delimiter=";")
					columnNames=next(reader)							#zwróci nazwy kolumn
					polaWwierszach=[row for row in reader]				#zwróci wszystkie linie
			*w sytuacji gdyby wystąpiły w jakieś linijce niepełne dane to nie musisz się tym przejmować
			 gdyż plik csv jest czytany linjka po linijce i brak jednej danej nie przesądza o przesunięciu
			 przypisywania pozostałych elementów. Tylko ta pojedyńcza linijka będzie spieprzona.
		*csv.writer(plikCSV)
			*służy do zapisu danych w pliku csv. Wykorzystuję się do tego metodę writerow()
			*pamiętaj by najpierw zapisać header (czyli nazwy kolumn) a potem zapisuj wszystkie dane
			 według nazw tych kolumn
			*pamiętaj żeby w metodzie open() użyć paramteru   newline=''  dzięki któremu nie będzie 
			 ci zapisywać enterów jako dodatkowej listy/linii
					import csv
					file=open(path,'w')							#w cudzysłowach nazwa pliku albo ścieżki
					writer=csv.writer(file) 
					writer.writerow(["columnName1","columnName2"])		#zapisujesz header
					writer.writerow(["data1.1", "data1.2"])				#zapisujesz dane
					writer.writerow(["data2.1", "data2.2"])				 	
		*csv.DictReader(csv_file) 
			*zwróci Dictionary z kluczami w postaci nazw z headeara czyli pierwszej linii pliku csv
					with open('plik.csv','r') as csv_file:
						csv_reader=csv.DictReader(csv_file)
						for line in csv_reader:
							print(line)				
						#zwróci: {'first_name': 'John', 'last_name': 'Doe', 'email': 'johndoe@gmail.com'}
								{'first_name': 'Sophie Elie', 'last_name': 'Don', 'email': 'bax@gmail.com'}
		*csv.DictWriter(csv_file)
			*poprzez specjalną słownikową składnię zapiszę nam plik csv
			*poprzez parametr fieldnames najpierw poda mu się nazwy kluczów (czyli pierwszą linię pliku 
			 csv) i zapiszę się to później komendą writeheader()
			*później poprzez komendę writerow(dict) i podanie w argumencie słownika z kluczami o nazwach
			 zapisanych wcześniej w parametrze fieldnames zapiszesz w pliku csv kolejne linie z wartościami
					with open('slownik_csv_plik.csv','w') as new_csv_file:
						fieldnames=['last_name','email']
						csv_writer=csv.DictWriter(new_csv_file,fieldnames=fieldnames)
						csv_writer.writeheader() 	            #zapisuję pierwszy rząd z nazwami pól
						csv_writer.writerow({'last_name':'Drab', 'email': 'drab@wp.pl'})			 
						csv_writer.writerow({'last_name':'Grab', 'email': 'grab@wp.pl'})		
							#wpisując wartości do pliku csv bierze tylko wartości ze słownika (bez kluczy)