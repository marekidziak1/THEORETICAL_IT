										SPIS TREŚCI:
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################

############################# OS ; FUNCTOOLS ; SYS ; SHUTIL ################################################
################ MODULE | MODULE: DATETIME i CALENDAR; TIME i TIMEIT ; RANDOM ##############################
SHUTIL MODULE:						https://www.geeksforgeeks.org/python-shutil-copytree-method/
OS MODULE:							https://www.programiz.com/python-programming/directory
METODY dla random:  				https://www.w3schools.com/python/module_random.asp
MODUŁ DATETIME:						https://www.w3schools.com/python/python_datetime.asp
									https://www.youtube.com/watch?v=eirjjyP2qcQ
MODULE CALENDAR:					https://www.geeksforgeeks.org/python-calendar-module/
MODULE, if__name__ == '__main__':	https://www.youtube.com/watch?v=sugvnHA7ElY


############ LOGGING | UNIT TESTS | PYTEST | PYDOC | PIP | VENV + VIRTUALENV | PIPENV ######################
PIPENV:								https://www.youtube.com/watch?v=6Qmnh5C4Pmo
PIP MANAGING: 						https://www.w3schools.com/python/python_pip.asp
PYDOC:								https://www.youtube.com/watch?v=URBSvqib0xw
ASSERTS in UNITTESTS:				https://www.mattcrampton.com/blog/a_list_of_all_python_assert_methods/	
LOGGING BASICS:						https://youtu.be/jxmzY9soFXg
LOGGING INTERMEDIATE:				https://www.youtube.com/watch?v=p0A4CV4MWd0



################# LAMBDA | DEKORATORY | CONTEXT MANAGER | ITERTOOLS - PRAWDOPODOBIEŃSTWO ###################
CONTEXT MANAGER:					https://www.youtube.com/watch?v=-aKFBoZpiqA
ITERTOOLS							https://docs.python.org/3/library/itertools.html
###### LEKCJA 20-22 ITERATORY: GENERATOR | MAPA | FILTER | FUNKCJE REDUCE() i ACCUMULATE() ####
ITERATORY:							https://www.w3schools.com/python/python_iterators.asp
									https://www.programiz.com/python-programming/methods/built-in/iter
									https://www.tutorialsteacher.com/python/iter-method
REDUCE():							https://www.geeksforgeeks.org/reduce-in-python/
ACCUMULATE():						https://www.geeksforgeeks.org/python-itertools-accumulate/


#################### LEKCJA 28 i 29 i 30 i 31 | DESTRUKTOR | HERMETYZACJA ##################################
###################### METODY KLAS I METODY STATYCZNE | Gettery i Settery ##################################
########## LEKCJA 25 i 26 i 27 KLASY I OBIEKTY OOP | DZIEDZICZENIE | METODY MAGICZNE #######################
OOP:								https://www.programiz.com/python-programming/object-oriented-programming
METODY MAGICZNE: 					https://www.youtube.com/watch?v=IkWrlRei0uA


######### LEKCJA 16 i 37 PODSUMOWANIE KOLEKCJI | WYCINKI KOLEKCJI | UNBOXING KOLEKCJI ######################
UNBOXING KOLEKCJI: 					https://www.w3schools.com/python/python_tuples_unpack.asp
########## BUILT-INS | *ARGS **KWARGS | KOPIOWANIE W PYTHONIE | MODULE COLLECTIONS #########################
SQUENCES:							https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
BUILT-IN:							https://www.programiz.com/python-programming/methods/built-in
COLLECTIONS MODULE:					https://www.geeksforgeeks.org/python-collections-module/
MODULE COPY: 						https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/
###########################  LEKCJA 15 KOLEKCJA DICTIONARY  ################################################
DICTIONARY INFORMACJE:				https://www.w3schools.com/python/python_dictionaries.asp
DICTIONARY METODY:					https://www.w3schools.com/python/python_dictionaries_methods.asp
####################### LEKCJA 24 KOLEKCJA SET | OPERATORY NA ZBIORACH #####################################
SET INFORMACJE:						https://www.w3schools.com/python/python_sets.asp
SET METODY:							https://www.w3schools.com/python/python_sets_methods.asp
SET METODY USUNIECIA: 				https://www.w3schools.com/python/python_sets_remove.asp
SET METODY ŁACZENIA:				https://www.w3schools.com/python/python_sets_join.asp
####################### LEKCJA 16 KOLEKCJA TUPLE - KROTKA i SEKWENCJE ######################################
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
KROTKA INFORMACJE:					https://www.w3schools.com/python/python_tuples.asp
KROTKA METODY:						https://www.w3schools.com/python/python_tuples_methods.asp
####################### LEKCJA 7 i 17 | KOLEKCJA: LISTA | LIST COMPREHENSION ###############################
METODY LISTA: 						https://www.w3schools.com/python/python_ref_list.asp
LISTY INFORMACJE:					https://www.w3schools.com/python/python_lists.asp
LIST COMPREHENSIONS: 				https://www.w3schools.com/python/python_lists_comprehension.asp


############################# LEKCJA 32 - 35 | WYRAZENIE REGULARNE #########################################
https://www.w3schools.com/python/python_regex.asp
########################## LEKCJA 18 i 19 | STRING | STRING FORMATTER ######################################
FUNKCJE Stringow: 					https://www.w3schools.com/python/python_strings_methods.asp
					   			   (https://www.w3schools.com/python/python_ref_string.asp)[to samo]
STRING FORMATTER:					https://www.w3schools.com/python/python_string_formatting.asp
######################################## OPERACJE NA PLIKACH (.txt) ########################################
FILE METHODS: 						https://www.w3schools.com/python/python_ref_file.asp
FILE OPERATIONS:   					https://www.w3schools.com/python/python_file_handling.asp
									https://www.programiz.com/python-programming/file-operation


############################################## WYJATKI #####################################################
TWORZENIE WŁASNYCH WYJĄTKÓW:		https://www.programiz.com/python-programming/user-defined-exception
TYPY WYJĄTKÓW:						https://www.w3schools.com/python/python_ref_exceptions.asp
									https://www.programiz.com/python-programming/user-defined-exception	
################################## PETLA FOR | FUNKCJE | REKURSJA ##########################################
######################################### IF | PETLA WHILE #################################################
############################################# PODSTAWY #####################################################
PODSTAWOWE FUNKCJE:					https://www.w3schools.com/python/python_ref_functions.asp
SŁOWA KLUCZOWE:						https://www.w3schools.com/python/python_ref_keywords.asp
SŁOWNICZEK:							https://www.w3schools.com/python/python_ref_glossary.asp


############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################# SKRÓCONA WERSJA ##############################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################







			
######################################### OPERACJE NA PLIKACH (.txt) #######################################
FILE METHODS: 						https://www.w3schools.com/python/python_ref_file.asp
FILE OPERATIONS:   					https://www.w3schools.com/python/python_file_handling.asp
									https://www.programiz.com/python-programming/file-operation
										
1* OPERACJE NA PLIKACH:
  ------------------------------------------------ ODCZYT --------------------------------------------------
  *METODY:   *OPEN(file)	   *READLINES() -cały plik	    *NEXT() -linie osobno	*READLINE()-linie osobno
	 f=open('plik.txt')			f=open(path,"r")			 f=open(path,"r")		  f=open(path,"r")			
	 if f.readable():			if f.readable():			 if f.readable():		  if f.readable():	
		 for line in f:				lines=f.readlines()			 line1=next(file)		  l1=f.readline()
			 print(line)				for line in lines:		 line2=next(file)		  l2=f.readline()
	 f.close()								print(line)		 f.close()				  f.close()
								f.close()
	 with open(path, "r") as f:	with open(path, "r") as f:	 with open(p,"r") as f:   with open(p,"r") as f:
		 if f.readable():			if f.readable():		 	 if f.readable():		  if f.readable():
			 for line in f:				lines=f.readlines()			 line1=next(file)		  l1=f.readline()
				 print(line)			for line in lines:			 line2=next(file)		  l2=f.readline()
											print(line)	
											
    *READ() - caly plik jednorazowo albo tyle znakow		  	
			  ile chcemy wpisując ilosc jako argument: 		
		f=open(test.txt)		with open('p.txt,'r') as f:	
		lines=f.read()				lines=f.read				
		tenSigns=f.reead(10)		tenSigns=f.reead(10)		
		f.close()
		
  *OPCJE PODCZAS ODCZYTU:
	   *TELL() - informacja o aktualnej pozycji/linijce		*SEEK() - zmiana pozycji/linijki do odczytu
	    f=open("plik.txt", 'r', encoding="utf-8")	   		 f=open("plik.txt", 'r', encoding="utf-8")
		if f.readable():									 if f.readable():
			line1=next(file)									 line1=next(file)
			f.tell();		#zwroci numer pozycji np 1		 	 f.seek(10); 		#zmiana numeru czytanej 
																					#pozycji na 10
 -------------------------------------------------- ZAPIS --------------------------------------------------
 **ZAPIS:
   *WRITE() - zwraca ilosc bajtów/znaków w tekście:		    *PRINT() (z parametrem file):
	f=open('plik.txt','w')	   #f=open('plik.txt','a')		 f=open('plik.txt','w')	
	f.write("costam"+"\n")									 print("costam", file=f)
	ile1 = f.write("costam2\n")								 print("costam2", file=f)
	ile2 = f.write(input('Wprowadź tekst')+"\n")
	print(ile1,ile2)	  #ilosc wprowadzonych znaków
	f.close()
	
	with open('p.txt','w') as f:							 with open('p.txt','w') as f:
		f.write("costam"+"\n")									 print("costam", file=f)
		ile1 = f.write("costam2\n")								 print("costam2", file=f)
		ile2 = f.write(input('Wprowadź tekst')+"\n")
		print(ile1,ile2)  #ilosc wprowadzonych znaków
 -----------------------------------------------------------------------------------------------------------

2* ROZSZERZENIE - METODA OPEN():
	A* Funkcja open() może działać na ścieżce 	 	 B* FileNotFoundError - (TYLKO PRZY ODCZYCIE) jeżeli 
				 WZGLĘDNEJ jak i BEZWZGLĘDNEJ:		 	plik nie istnieje -> ujmij to klauzulą try except:
	   f = open("demofile.txt", "r")						 try:							
	   f = open("D:\\myfiles\welcome.txt", "r")					 with open('p.txt,'r') as f:				
																	 ...									
															 except FileNotFoundError:		
																 ...
	C* TRZY PARAMETRY FUNKCJI OPEN(): nazwaPliku, trybOtwarcia (domyślnie tryb "r"), kodowanie:
			*TRYBY OTWARCIA("r","a","w","x"):
				*'r'-'READ' -do odczytu
				*'a'-'APPEND' -do appendowania nowego tekstu do starego, plik jest tworzony gdy nie istnieje
				*'w'-'WRITE' -do zapisu, za kazdym razem od poczatku, dotychczasowe dane zostaną usunięte
				*'x'-'CREATE' -do tworzenia pliku gdy NIE ISTNIAŁ WCZESNIEJ. Jeżeli istnieje to zwróci error
				*do tych trybow mozesz dodac jeszcze 2 literki odpowiadajace za to czy bedziesz bral pod 
				 uwage plik tekstowy ['t'] czy plik binarny ['b'] (domyślnie tekstowy):
						with open("test.txt","wb") as f:
							...
			*KODOWANIE (domyślne utf-8):
						with open("test.txt","w", encoding='utf-8') as f:
							...						
	D* KOPIOWANIE PLIKÓW (odczyt + zapis):		  	E* ODCZYT i ZAPIS PLIKÓW JPG (do jpg stosuj READ())
	  with open('my_file.txt','r') as rf:					 with open('my_file.jpg','rb') as rf:
	      with open('my_file_copy.txt','w') as wf:				 with open('my_file.jpg','rb') as rf:
		      for line in rf:										 chunk_size=4096
				  wf.write(line)									 rf_chunk=rf.read(chunk_size)
																	 while len(rf_chunk)>0:
																		 wf.write(rf_chunk)
																		 rf_chunk=rf.read(chunk_size)
																	
3* USUWANIE PLIKU: 					 /		 			USUWANIE FOLDERU:
	import os												 import os
	if os.path.exists("test.txt"):							 if os.path.exists("test.txt"):
		os.path.remove("test.txt")								os.rmdir("myfolder")


############################################################################################################
############################################################################################################
############################### WYJATKI: OBSŁUGA, RAISE, ASERCJE, WŁASNE WYJĄTKI ###########################
TWORZENIE WŁASNYCH WYJĄTKÓW:		https://www.programiz.com/python-programming/user-defined-exception
TYPY WYJĄTKÓW:						https://www.w3schools.com/python/python_ref_exceptions.asp
									https://www.programiz.com/python-programming/exceptions
									
3* TWORZENIE WŁASNYCH WYJĄTKÓW:		https://www.programiz.com/python-programming/user-defined-exception
	*tworzysz klasę wyjątku która dziedziczy po klasie Exception i przesłaniasz metodę __init__(): 
		class MyError(Exception):
			def __init__(self, salary, message="Salary is not in (5000, 15000) range"):
				self.salary = salary
				self.message = message
				super().__init__(self.message)
	*można go wywołać normalnie poprzez raise							oraz obsłużyć w blokach [try except]:
		def func(salary)													try:
			if not 5000 < salary < 15000:										func(1000)
				raise MyError(salary) #raise MyError(salary,"błąd")			except MyError as c:
		func(1000) 													 			print(c.salary, c.message)
		#zwróci:__main__.MyError Salary is not in (5000, 15000) range 		#zwróci: 1000 błąd		
		#LUB:  	__main__.MyError błąd
		
1* RAISE i ASERCJE - podnoszenie wyjatku poprzez raise albo wywolywanie asercji realizujesz głównie podczas 
   działania programu (przy definiowaniu funkcji). Ma to służyc głównie sytuacją gdzie chcesz zaakcentować 
   błąd logiczny w działaniu programu a nie taki który jest zdefiniowany w systemie (TypeError, KeyError itp)
   ***RAISE - PODNOSZENIE WYJATKU (W Javie 'throw'):
		*używa się by wyrzucić WŁASNY TYP WYJĄTKU (czyli taki którego system sam by nie podniósł) ALE
 		 JEDNORAZOWO (by używać go wielokrotnie to zrobiłbyś to poprzez własną klasę wyjątku)
		*w raise możesz użyć już zdefiniowanych typów wyjątków np.: ValueError
		  def function():			def function():					   def function():
			  x = "hello"			    x = "hello"					       x = "hello"
			  if not type(x) is int:	if not type(x) is int:			   if not type(x) is int:
				  raise Exception		    raise Exception("Only int")	       raise ValueError("Only int")
		*później używając tej funkcji możesz zrobić jej obsługę wyjątku ale wtedy zamiast napisu w raise 
		 wyświetlą się instrukcje w bloku except (jeżeli nie zrobisz obsługi wyjątku to przy podniesieniu 
		 twojego wyjątku nastąpi standardowe przerwanie programu):
					function()									#'Only int' + przerwanie programu
			#ALBO
					try:
						function()
						print("nie wykona się")
					except:
						print("instrukcje w bloku except")		#'instrukcje w bloku except'
					print("dalsze instrukcje")					#'dalsze instrukcje'
		*jeżeli słówko raise umieścisz wewnątrz bloku [except] to mimo tego że zrobiłeś obsługę wyjątku to
		 program zostanie przerwany. W tym przypadku jedynie blok finally zawsze zostanie wywolany.
					try:
						print(2/0)
					except ZeroDivisionError:
						print("Blad")
						raise
					finally:
						print("blok finally")
					print("dalsze instrukcje nie zostaną zrealizowane")
   ***ASERCJA - (UPEWNIENIE) 'ASSERT' (działa tak samo jak raise):
		*przy asercji musisz wygenerowac jakis warunek logiczny i jezeli ten warunek sie NIE SPRAWDZI to 
		 przy wywolaniu funkcji zostanie wyrzucony wyjątek (asercja) (przerywający dzialanie programu)
		*asercji uzywa sie po to zeby byc pewnym tego ze funkcja bedzie zwracac dana wartosc i uzywa sie
		 tego tylko na czas tworzenia programu a nie gdy juz jest gotowy program
		*przy asercji, po przecinku po warunku logicznym mozna wypisac co ma zostac wyswietlone w momencie 
		 podniesienia wyjatku
				def dzielenie(x, y):
					assert y!=0, " y jest rowne 0"
					print(x/y)
				dzielenie(2, 0)				#zwróci: AssertionError:  y jest rowne 0]
				
0* OBSLUGA WYJAKOW   [try ; except ; else ; finally]:
	*TYPY WYJĄTKÓW:		https://www.w3schools.com/python/python_ref_exceptions.asp
						https://www.programiz.com/python-programming/exceptions
		*SKŁADNIOWE (syntax)
		*LOGICZNE (logical) np (FileNotFoundError, ZeroDivisionError,ImportError)
	*OBSŁUGA WYJĄTKÓW:
	  *żeby program działał mimo wyjątku bo inaczej wystąpi przerwanie programu 
	  *przy obsluzeniu wyjątku (któremu możesz nadać alias) przerwanie bloku try i przejście do bloku except)
		 *RÓŻNE WARIANTY BLOKU EXCEPT:				    *BLOK FINALLY i ELSE:
			x,y,z,n,t = 4,3,0,'mama',[]				   x,y,z,n,t = 4,3,0,'mama',[]
			try:										   try:
				print(x/z) 									   print(x/y)
				print("linijki ktore sie nie wykonają")		   print("brak błędu więc się wykona")
			except ZeroDivisionError as zerr:			   except:					
				print("dzielenie przez zero")				   print("jakiś błąd")
			except (TypeError, IndexError):	#x/n | x/t[0]  else:
				print("1 z dwoch wyjatkow")					   print("wykona się gdy nie przerwie bloku try")
			except:										   finally:
				print("jakis inny blad")					   print("niezaleznie czy wyjatek czy nie")
			print("dalsze instrukcje")			 		   print("dalsze instrukcje")
					#'dzielenie przez zero'						 #1.3333333
					#'dalsze instrukcje'					 	 #'wykona się gdy nie przerwie bloku try'
																 #'niezaleznie czy wyjatek czy nie'
																 #'dalsze instrukcje'
																
############################################## FUNKCJE | REKURSJA ##########################################
3*Funkcje REKURENCYJNE (rekursja) - limit rekursji = 1000. Przy przekroczeniu błąd: RecursionError
	*pamiętaj o PRZYPADKU PODSTAWOWYM:
			def silnia(x):
				if x <= 1:			#przypadek podstawowy
					return 1
				else:
					return x * silnia(x-1)
	*MEMOIZATION (dodatkowy słownik poza funkcją rekurencyjną do przechowywania obliczonych przypadków:
			dictionary={}							LUB UŻYCIE dekoratora lru_cache() z modułu functools():
			def fibonnaci(n):							from functools import lru_cache
				if n in dictionary.keys():				@lru_cache(maxsize=128)		#PODAJ parametr maxsize 
					return dictionary.get(n)			def fibonnaci(n):
				if n==1 or n==2:							if n==1 or n==2:
					value=1										return 1
				elif>2:										elif n>2
					value=fibonnaci(n-1)+fibonnaci(n-2)			return fibonnaci(n-1)+fibonnaci(n-2)
				dictionary[n]=value
				return value
		 
2* PRZECIĄZANIE FUNKCJI 
	1*(w pythonie zamiast przeciazania jest nadpisanie)			
		def dodaj(arg1):								
			print(arg1+1)
		def dodaj(arg1, arg2):
			print(arg1+arg2)
		dodaj(2, 3)
		#dodaj(2)   	#ta funkcja nie zostanie wywolana bo zostala nadpisana przez dodaj(arg1, arg2)
	2*PRZECIAZANIE FUNKCJI mozna uzyskac poprzez ARGUMENT OPCJONALNY (musi być ostatnim argumentem):
		def dodaj(arg1, arg2=1):
			print(arg1+arg2)
		dodaj(2)		#wynik: 3
		dodaj(2,3)		#wynik: 5

1* Funkcje:
	*W I linijce funkcji opisz co dokładnie robi w trzech cudzysłowach:
					def func():
						'''function return nothing and do nothing'''
						pass
					help(func)	#dzięki temu w help(func) zwróci: function return nothing and do nothing
	*PODSTAWY:
		*najpierw deklaracja, później wywołanie
		*brak podzialu na PROCEDURY (voidy) a FUNKCJE ZWRACAJĄCE
		*do zmiennej mozna przypisac referencje funkcji
					def func(x):
						return x*x
					zmienna =func
					print(zmienna(5)		#wynik: 25
	*ARGUMENTY w Pythonie (bez definiowania ich typow):
		*przekazując argumenty do funkcji działasz na orginałach (referencjach) a nie na kopiach 
		*podawanie funkcje jako argument (podajesz referencje a nie wywołanie wiec bez nawiasów okrągłych)
					def func1(z):
						return z**2
					def func2(f1, x):
						return f1(x)
					print(func2(func1,5))   #wynik: 25
		*losowa kolejność argumentów jeżeli z dopisaniem ich nazw ;; możliwy tryb mieszany 
					def greet(name, msg):
						print(name, msg);
					greet(name = "Bruce",msg = "How do you do?")	#losowa kolejność
					greet(msg = "How do you do?", name = "Bruce")
					greet("Bruce",msg = "How do you do?");			#tryb mieszany podawania argumentów
	*ARGUMENTY OPCJONALNE / DOMYŚLNE w Pythonie:
		#arg z domyślną wartością musi być za arg właściwymi, przy wywołaniu nie trzeba go podawać:
				def my_function(name, country='Norway');
					print(f"My name is {name} and I'm from {country}")
				my(function('Marek')						#'My name is Marek, and I'm from Norway'
	  ! #MUTABLE DEFAULT ARGUMENTS - mutowalny argument domyślny (np jako pusta lista) jest tworzony TYLKO 
	     RAZ podczas I wywołania a nie za każdym razem od nowa podczas kolejnych wywołań, dlatego zamiast 
		 MUTOWALNYCH OBIEKTÓW do argumentów domyślnych podaje się IMUTABLE OBIEKTY np: None.
			1szy* ex: podanie pustej listy jako domyślny arg; 				Powinno być None:
				#MUTABLE ARGUMENTS:											#IMMUTABLE ARGUMENTS:
				def add(name, emp_list=[]):									def add(name, emp_list=None):
					emp_list.append(name)										if emp_list==None:
					print(emp_list)													emp_list=[]
																				emp_list.append(name)
																				print(emp_list)
				add('Mar')	 #zwróci: ['Mar']								add('Mar')	#zwróci: ['Mar']								
				add('Dar')	 #zwróci: ['Mar', 'Dar'],zamiast ['Dar'] 		add('Dar')	#zwróci: ['Dar']
					#nawet po wywołaniu argumentu z listą (['Gary'])
					#poprzednia domyślna lista będzie przechowywana
				add('Andrzej', ['Gary'])									add('Andrzej', ['Gary'])
				add('Jurek') #zwróci: ['Marek', 'Darek', 'Jurek']			add('Jurek') #zwróci: ['Jurekk']
			*2gi ex: podanie datetime.now() jako argument domyślny; Powinno być None:
				import time										    import time
				import datetime 									import datetime 
				def display_time(timing=datetime.datetime.now())	def display_time(timing=None):
					print(timing.strftime('%H:%M:%S))					if timing==None:
				display_time()		#zwróci: 	8:47						timing==datetime.datetime.now()
				time.sleep(60)											print(timing.strftime('%H:%M:%S))
				display_time()		#zwróci:  8:47 zamiast 8.48		display_time()		#zwróci: 8:47
				time.sleep(60)										time.sleep(60)
				display_time()		#zwróci:  8:47 zamiast 8:49		display_time()		#zwróci: 8.48
				
	*ARBITRARY ARGUMENTS : 
	  *args- argumenty jako krotka, (0 - ~)    **kwargs- argumenty jako słownik w specjalnej składni, (0 - ~)
		 def my_function(arg0, *args):				def my_function(arg0, **kwargs):
			 print("Arg0:", arg0)						print("Arg0:", arg0)
				 for arg in args:						for key, value in kwargs.items():
					print("ArgV:" + args)				 	print("His",key,"is",value)
		 my_function("Em","Li","Ma")				my_function("Ma",fname = "Tob", lname = "Ref")
		##Arg0: Em ; ArgV: Li ; ArgV: Ma			##Arg0: Ma ; His fname is Tob ; His lname is Ref
					 
######################################## IF | PETLA WHILE | PĘTLA FOR ######################################
3* Petla obiektowa FOR i funkcja RANGE
	*FUNKCJA RANGE():
			print(list(range(5))) #zwróci: [0,1,2,3,4]   ||   print(list(range(3, 8))) #zwróci: [3,4,5,6,7]
		*Iterowanie po range():							*Iterowanie po range() z 3cim parametrem = 2:		
			for i in range(5):							 for i in range(1,11,2)
				print(i) 		  #zwróci: 0 1 2 3 4 	     print(i)			#zwróci: 1,3,5,7,9
	*ITEROWANIE 
		*Po liście:				*Po Stringu:			*Po słowniku:
		 for x in [1,2,3,4]:	 for x in "banana":		 for key, value in {'c':10,'a':1}.items():
		     print(x)			     print(x)			     print(key, value)	#zwróci: c 10 ; a 1
		*Po liście krotek:								*Po posortowanej liście krotek (funkcja sorted):
		 for m1,m2,m3 in [('r',33,21),('f',10,22)]:		 for m1,m2,m3 sorted([('r',33,21),('f',10,22)]):
		     print(m1,m2,m3)  #zwroci: r 33 21; f 10 22      print(m1,m2,m3)	#zwroci: f 10 22 ; r 33 21;
	*DODATKI:
		*BREAK: 				*CONTINUE:				 *ELSE (musi być bez BREAK):	 *PASS:
		 for x in range(4):		 for x in range(4):		  for i in range(4):			  for i in [1,2]:
			 if x == 2:				 if x == 2:			      print(i)					      pass
				break					 continue		  else:
		     print(x)   #0,1		 print(x)	#0,1,3		  prin("Koniec") #0,1,2,3,END
			
2* PETLA WHILE
		#BREAK:			#CONTINUE:			#ELSE: (musi być bez BREAK)				  #PETLA NIESKOŃCZONA:
		while i<5:		while i<5:			while i<5:								  while True:	
			print(i)		print(i)			print(i)							      print(i)
			i+=1			i+=1				i+=1
			if i==3:		if i%2==0:		else:		
				break			continue		print("WHILE not interupt by BREAK")
			
1* IFy (zamiast && -> and ;; zamiast || -> or)
		1*PODSTAWY:									2*'and' bedzie wykonywany pierwszy. 'or' drugi: 
			x = 4										if True or False and False:
			if 5 < x:		    							print('True')
				print('Prawda')							else:
			elif 5 == x:									print ('False')		#zwróci 'True'
				print('Prawda')
			else 
				print('Falsz')			
	SKRÓCONY OPERATOR IF:
	#1*PODSTAWY:		 print("PRAWDA ") if 5>2 else print("Nieprawda")
						 import math
						 math.sin(math.radians(90)) if 5<2 else math.sin(math.radians(0))
	#2*Z FOREM:			 even_lst=[x for x in [0,1,2,3,4,5] if x%2==0]			#if na końcu
						 even_lst=[x if x%2==0 else 2 for x in [0,1,2,3,4,5]]	#if na początku
	#3*IF najpierw ten wewntrzny a poniej dopiero zewnetrzny:
						 digit_odd_lst=sorted([x for x in lst if x.isdigit() if int(x)%2!=0])	
################################################ PODSTAWY ##################################################
PODSTAWOWE FUNKCJE:		https://www.w3schools.com/python/python_ref_functions.asp
SŁOWA KLUCZOWE:			https://www.w3schools.com/python/python_ref_keywords.asp
SŁOWNICZEK:				https://www.w3schools.com/python/python_ref_glossary.asp
			
2* Składnia:
	*PODSTAWOWE FUNKCJE: https://www.w3schools.com/python/python_ref_functions.asp
	*KOMENTARZE i CUDZYSŁOWIA: #, ''' ''', """ """ --> ''' "..." ''' || """ '...' """
	*PRINT(): print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False) ;; print('...'+str(int))
	*USUWANIE ZMIENNYCH: del x
	*ZMIENNE:
		**UNPACKING: x, y, z = "Orange", "Banana", "Cherry"				
		**DATA TYPES: str ;; int (1, -1) ;; float (1.1) ;; Decimal(1.1) ;; complex (1+j) ;; None
		  bool (True, False) ;; Binary:bytes, bytearray, memoryview ;; Pochodne: oct(a), hex(a), bin(a)
		  Collections:	(range), list, tuple, dict, set, frozenset;
		**TYP:	type(zmienna)
		**GLOBAL - Najpierw deklaracja że zmienna jest globalna. Potem przypisywanie wartości:
				def outer_function():
					global a
					a = 20
					def inner_function():
						global a
						a = 30
						print('a1 =', a)
					inner_function()
					print('a2 =', a)
				a = 10
				outer_function()			#przez global zwroci: a1=30, a2=30, a3=30
				print('a3 =', a)			#zamiast a1=30, a2=20, a3=10 gdyby nie było global
		**NONLOCAL - zmiany na NONLOCAL VARIABLE w funkcji wewnętrznej będą miały wpływ w funkcji 
		  zewnętrznej. Działa tylko w funkcjach wewnetrznych.
					a = 10
					def outer_function():
						a = 20
						def inner_function():
							nonlocal a
							a= 30
							print('a1 =', a)
						inner_function()
						print('a2 =', a)
					outer_function()
					print('a3 =', a)				#przez nonlocal zwroci: a1=30, a2=30, a3=10
		**KONWERSJA TYPÓW: str(3), int(3), float(3)	
	*INPUT() - input("Podaj dane do input'a: ")
		**dane wejściowe jako stringi
		**LUB stdin.read()z biblioteki sys:
			import sys
			txt=sys.stdin.read()
	*Kolejność działań: (), pow(), * /, + - ;; od lewej do prawej
	*OPERATORY MATEMATYCZNE rozszerzone: int / int [:float] ;; 5 % 3 [:2] ;; 5 // 2 [:1] ;; 2 ** 3 [:8]
	*OPERATORY PRZYPISANIA: brak(x-- ; x++) tylko: += -= *= ;/= %= //= **= ;; BITOWE: &= |= ^= >>= <<=
	*OPERATORY LOGICZNE: brak(&& ||) tylko: and , or , not ;;   is , is not ;;   in , not in 
		*OPERATORY PRZYNALEŻNOŚCI IS, IS NOT - sprawdzają referencje a dla typ. prostych wartości (m.in str)
		*OPERATORY 'WYSTĘPOWANIA W' (MEMBERSHIP) (IN, NOT IN):
			print(1 in 1:'a',2:'b'})			# Output: True
			print('a' in 1:'a',2:'b'}) 			# Output: False
	*OPERATORY BITOWE: & AND ;; | OR ;; ^ XOR ;; ~ NOT ;; <<Zero fill left shift ;; >>	Signed right shift
			
1* Właściwości i SKROTY:				
	*SKRÓTY VISUALSTUDIO:
		*FIND & REPLACE: zaznaczenie text + CTRL+F ;;CTRL+H + newText;; ENTER||CTRL+ALT+ENTER
		*SHIFT + ALT + (strzałka w dół lub w góre) - kopiowanie linii 
		*ALT + (strzałka w górę lub w dół) - przemieszczanie się linii w górę lub w dół
		*CTRL + ` - terminal 
		*CTRL + b - panel boczny	
		
0.1* KONSOLA DLA PYTHONA:
	*otwieranie pliku .py w konsoli z argumentami:
				python -i nazwaPliku.py arg1 arg2 arg3
				python -m nazwaPliku arg1 arg2 arg3
	
0.0* INSTALACJA I KONFIGURACJA:			
	*instalacja pythona									https://www.youtube.com/watch?v=YYXdXT2l-Gg 
	*zmiana zmiennych środowiskowych:					https://www.youtube.com/watch?v=OdIHeg4jj2c				
	*sprawdzenie ścieżki do używanego intepretera (w konsoli: python)
				import sys
				sys.executable
	*ustawienie powyższej ścieżki jako 'python' oraz powyższej ścieżki w folderze libs/site-packages 
	 albo Scripts jako 'pip' w zmiennych środowiskowych 
	 
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################ ROZSZERZONA WERSJA ############################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
############################################################################################################
					
############################# OS ; FUNCTOOLS ; SYS ; SHUTIL ; GETPASS ######################################
################ MODULE | MODULE: DATETIME i CALENDAR; TIME i TIMEIT ; RANDOM ##############################
SHUTIL MODULE:						https://www.geeksforgeeks.org/python-shutil-copytree-method/
OS MODULE:							https://www.programiz.com/python-programming/directory
METODY dla random:  				https://www.w3schools.com/python/module_random.asp
MODUŁ DATETIME:						https://www.w3schools.com/python/python_datetime.asp
									https://www.youtube.com/watch?v=eirjjyP2qcQ
MODULE CALENDAR:					https://www.geeksforgeeks.org/python-calendar-module/
MODULE, if__name__ == '__main__':	https://www.youtube.com/watch?v=sugvnHA7ElY

 
6*MODULE getpass
	*służy do tego żeby w inputcie w momencie wpisywania hasła nie były widoczne znaki:
				import getpass
				username=input('Username: ')
				password=getpass.getpass('Password: ')
 
5*SHUTIL MODULE - moduł bardzo podobny do modułu OS:
https://www.geeksforgeeks.org/python-shutil-copytree-method/
	
4*SYS MODULE - moduł ogarniający systemowe komendy i działania w Pythonie:
	*sys.path - przy pobieraniu jakiegoś modułu python odwołuję się do listy ścieżek w których 
		te moduły mogą się znajdować. 
				import sys
				for path in sys.path:
					print(path)
	*sys.executable - zwrói z jakiej wersji Pythona korzystasz wskazując ścieżkę z jakiej
		interpreter korzysta by uruchomić program python.exe
	*sys.stdin.read() - możesz użyć zamiast input() 
				txt=sys.stdin.read()
	*sys.argv -pozwala wyświetlić wszystkie argumenty podane w konsoli podczas otwarcia
		pliku_.py/modułu za tymże plikiem_.py/modułem:
				if __name__ =='__main__':
					if len(sys.argv[1])>1:
						new_name=sys.argv[1]
						print(new_name)
		[UWAGA - pierwszy argument jest liczony jako nazwa funkcja, dopiero od jedynki 
		 masz argumenty właściwe]
		 		print(sys.argv)						#zwróci wszystkie argumenty
				print(sys.argv[0])					#zwróci naze wywoływanej funkcji
				print(sys.argv[1])					#zwróci pierwszy argument
	*sys.getsizeof(lst, "bytes") - do mierzenia wielkośći danej kolekcji
				print(sys.getsizeof([1,2,3,4,5]),"bytes")		# 64 bytes	
	*sys stdout - wykorzystywane w konstrukcji printa(): 
				print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False	

3*OS MODULE - moduł do działania na ścieżkach, gdy masz wiele plików:
  https://www.programiz.com/python-programming/directory
  https://www.youtube.com/watch?v=tJxcKyFMTGo&list=PL-osiE80TeTskrapNbzXhwoFUiLCjGgY7&index=10 
	*musisz pobrać moduł os:
					import os
	*PODSTAWY cz1 - NAJCZĘŚCIEJ UŻYWANE:
		*SPRAWDZENIE czy dana ścieżka istnieje:
						if os.path.exists(path):
							...
		*ZMIANA LOKALIZACJI/ZMIANA ŚCIEŻKI W KTÓEJ SIĘ ZNAJDUJESZ (change direction):
						os.chdir("C:\\InnyKatalog')
   	    *UZYSKANIE WSZYSTKICH PLIKÓW i PODŚCIEŻEK:
						os.listdir();
		*UZYSKANIE ŚCIEŻKI:	
			*UZYSKANIE AKTUALNEJ ŚĆIEŻKI w jakiej się znajdujesz użyj metody getcwd() lub 
			 metody getcwdb() jeżeli chcesz uzyskać obiekt bytowy:
						os.getcwd();	#'C:\\Program Files\\PyScripter'
						os.getcwdb();	# b'C:\\Program Files\\PyScripter'
			*UZYSKANIE ŚCIEŻKI ABSOLUTNEJ DO PLIKU to:
						file_path=os.path.abspath(__file__)
			*UZYSKANIE ŚCIEŻKI ABSOLUTNEJ DO FOLDERU/KATALOGU w którym znajuję się PLIK lub FOLDER:
						base_dir=os.path.dirname(os.path.abspath(__file__))
									#lub:
						file_path=os.path.abspath(__file__)
						base_dir=os.path.dirname(file_path)
		*UTWORZENIE ŚCIEŻKI:								
		 (teoretycznie mógłbyś to zrobić zwyczjanie podając to w Stringu ale w Macu i Windowsie różnią 
		 się slashe przy ścieżkach. W Windowsie jest backslach '\' a w Macu slash '/')
						path='templates/email.txt'		#nie robimy tak tylko używamy moduł os
			*WZGLĘDNEJ: 
						quasi_path=os.path.join("templates","email.txt")
			*BEZWZGLĘDNEJ:
					*najpierw trzeba dostać się do katalogu poprzez absolutną scieżkę:
						file_path=os.path.abspath(__file__)
						base_dir=os.path.dirname(file_path)
					*później stworzyć nową ścieżkę na bazie absolutnej ścieżki:
						directory=os.path.join(base_dir,"templates","file.txt")
			 
	*PODSTAWY cz2 - KATALOGI:
		*STWORZENIE NOWEGO KATALOGU (tylko katalogu, nie pliku)
			*stworzenie pojedyńczego katalogu
						os.mkdir('nowyKatalog');
			*stworzenie całego łańcuszka katalogów (na początku mogą być te nieistniejące i te istniejące )
						os.makedirs('nowyKatalog1/nowyKatalog2/nowyKatalog3')
						os.makedirs(path, exist_ok=True) 	#nie stworzy jeśli istnieje folder. W ten
															#sposób działa parametr exist_ok ustawiony 
															#na True, Przy exist_ok=False zwróci błąd 
															#jak folder będzie już wczesniej istniał
		*ZMIANA NAZWY PLIKU LUB KATALOGU 
		 (nie używać na ścieżce z folderami pośredniczącymi tylko być najpierw w docelowym 
		 folderze gdyż inaczej przeniesie ci do folderu w którym aktualnie się znajdujesz):
						os.rename('test','new_one')
		*USUNIĘCIE:
			*usunięcie katalogu lub pliku:
						os.remove('old.txt')
			*usunięcie TYLKO KATALOGÓW:
				*usunięcie ostatniego katalogu w ścieżce:
						os.rmdir('nowyKatalog/nowyKatalog2')
				*usunięcie wszystkich katalogów w ścieżce (łącznie z tymi pośredniczącymi):
						os.removedirs('nowyKatalog/nowyKatalog2')
						
	*PODSTAWY cz3 - UZYSKANIE PODSTAWOWYCH ELEMENTÓW/INFORMACJI:
		*UZYSKANIE:
			*NAZWY PLIKU z pdanej ścieżki (ścieżka może być wyimaginowana)
						os.path.basename('/temp/actual/today/test.txt')			
													#zwróci: test.txt
			*ŚCIEŻKI KATALOGÓW prowadzących do pliku (ścieżka może być wyimaginowana):
						os.path.dirname('/temp/actual/today/test.txt')			
													#zwróci: /temp/actual/today
			*KROTKI SKŁADAJĄCEJ SIĘ ze ścieżki katalogów prowadzących do pliku ORAZ Z pliku 
			 (ścieżka może być wyimaginowana):
						os.path.split('/temp/actual/today/test.txt')				
													#zwróci: ('/temp/actual/today', 'test.txt')
			*KROTKI SKŁADAJĄCEJ SIĘ ze ścieżki katalogów i pliku ORAZ z ROZSZERZENIA PLIKU:
			 (ścieżka może być wyimaginowana):
						#dla ścieżek
						os.path.split('/temp/actual/today/test.txt')				
													#zwróci: ('/temp/actual/today/test','.txt')
						#dla nazw plików:
						os.path.splitext('Earth - #4.txt')
													#zwróci: ('Earth - #4','.txt')
		*SPRAWDZENIE:
			*czy ostatni element ścieżki to PLIK:
						os.path.isfile('/temp/actual/today/test')
			*czy ostatni element ścieżki to KATALOG:
						os.path.isdir('/temp/actual/today/test')
						
	*PODSTAWY cz4 - UZYSKANIE ROZSZERZONYCH ELEMENTÓW:
		*UZYSKANIE STATYSTYK/WŁAŚCIWOŚCI dotyczących pliku/katalogu:
						os.stat('nowanazwa')	#zwróci: os.stat_result(
															st_mode=16895, 
															st_ino=1125899906893948, 
															st_dev=4129711001, 
															st_nlink=1, st_uid=0,
															st_gid=0, st_size=0, 
															st_atime=1632847193, 
															st_mtime=1632845994, 
															st_ctime=1632845994)
			*ponieważ większość zmiennych jest wyrażona w sekundach do teraźniejszego momentu to 
			 żeby zamienić je na aktualną datę trzeba użyć metody fromtimestamp()
						import os
						import datetime
						mod_time=os.stat('demo.txt').st_mtime()
						print(datetime.fromtimestamp(mod_time))
		*UZYSKANIE ZMIENNYCH SRODOWISKOWYCH:
			*wszystkich zmiennych:
						os.environ
			*konkretnej zmiennej:
						os.environ.get('TEMP')
		*UZYSKANIE CAŁEGO DRZEWA KATALOGÓW (os.walk('localPath'))
			*przydaję się podczas szukania:
			*pokaże ci ścieżkę w jakiej się znajdujesz (katalog), jego katalogi i pliki. Natępnie
			 przejdzie po każdym katalogu w dół dalej.
						for dirpath, dirname, filename in os.walk('Java - project'):
							print('Current Path:', dirpath)
							print('Folders/directories in the path:', dirname)
							print('Files in the path:', filename)

2* LICZBY LOSOWE - MODULE RANDOM:
	*METODY dla random: https://www.w3schools.com/python/module_random.asp
	*JEŚLI CHESZ UŻYĆ liczb losowych DO KWESTI BEZPIECZEŃŚTWA to nie używaj modułu RANDOM tylko MODUŁ
	 OS.URANDOM() albo SystemRandom 
	*losowanie liczb pseudolosowych 
		*random.random() - zwróci liczbę z zakresu [0 - 1)
				import random
				print(random.random()
		*liczby losowe z danego zakresu
			*random.raindint(1,10) 
				*losuję tylko liczby całkowite (przedział obustronnie zamknięty)			
					from random import randint 
					for i in range(100):
						print(randint(1,10))
			*random.randrange(1,10) -(przedział lewostronnie zamknięty, prawostronnie otwarty)    [1-9]
					import random	
					print(random.randrange(1,10))
			*random.uniform(3,7) - używaj przy rzeczywistym podejściu losowości 
					import random
					print(random.uniform(1,10))	
			*random.normalvariate(0,9)	
				*pobranie wartośći losowej z odchylenia standardowego gdzie pierwszy parametr to 
				 środek odchylenia standardowego a drugi parametr to szerokość odchlenia standardowego
					import random
					print(random.nomralvariate(4,5) 	#liczby będą wybierane z zakresu -1 do 9
		*losowy wybór kilku wartośći z listy:
			*random.sample(lista, k=ilosc_elementów_do_wyboru):
					import random
					deck = list(range(1,25)
					sample = random.sample(deck, k=3)						#wybierze 3 wartośći
					print(sample)											#zwróci np: [23,7,12] 
		*losowe pomieszanie kolejności w liście:
			*random shuffle(lista):
					import random
					deck =list(range(1,10))
					random.shuffle(deck)	#nie przypisujesz tego niczemu
					print(deck)				#zwróci pomieszaną kolejność np: [8, 1, 4, 6, 5, 3, 7, 2, 9]
		*wybór losowy z danej listy:
			*random.choice(list) - ktora z danej sekwencji (np. listy) wybierze losowo jedną wartość:
					import random
					lst=['rock' 'paper', 'scizzors']
					obj=random.choice(lst)
				*żeby zrobić losowanie z dictionary to zamień je wczesniej na listę:
					import random 
					dictionary={'north':[1,0],'east':[0,1],'south':[-1,0],'west':[0,-1]}
					direction=random.choice(list(dictionary.keys()))
			*random.choices(list, k=number) - ktora wybierze z sekwencji tyle losowo wybranych liczb 
			 ile wskazuję parametr k. 
				*można tez dodać pomiędzy tymi argumentami parametr weight=[list] ktory wskazuję na 
				 wagę danego argumentu w liście tzn = że dla czegoś takiego: [2,1,1] pierwszy element 
				 listy będzie 2 razy częściej wybierany niż pozostałe
				*nie zalecane jest uzywanie metody choices - zdecydowanie lepiej jest użyć metody 
				 choice w pętli (nie zalecane głównie dlatego że może dojść do sytuacji że w metodzie 
				 choices wylosuję nawet więcej elementów niż podane jest w parametrze k)
				
1* MODUŁ TIME i TIMEIT oraz MODUŁ DATETIME i CALENDAR:
https://www.w3schools.com/python/python_datetime.asp
https://www.youtube.com/watch?v=eirjjyP2qcQ 
  MODULE TIME	
		*służy do obliczenia różnicy czasowej:
				import time
				begin=time.time()
				...
				end=time.time()
				print(end-begin)
  MODULE TIMEIT:
		*służy do obliczenia czasu przetowrzenia danej kolekcji przy zadeklarowanej liczbie powtórzeń: 
				import timeit
				print(timeit.timeit(stmt="[1,2,3,4,5,6,7]",number=1000000))			# 0.11065
				print(timeit.timeit(stmt="(1,2,3,4,5,6,7)",number=1000000)) 		# 0.01528
				
  MODUŁ DATETIME:
	*w Pythonie nie ma zmiennych typu "DATE" ale poprzez zaimportowanie modułu 'datetime' możesz 
	 pracować na danych typu datetime.
		0)OBIEKTY KLASY DATETIME:
		  A)DATY które NIE DOTYCZĄ AKTUALNEGO CZASU (przeszłość albo przyszłość):
				*datetime.date(year, month, day)	
						import datetime
						dt = datetime.date(2016,7,21)  #liczby podajesz bez zera przed
				*datetime.time(hour, minute, second, microsecond ,tzinfo)
						import datetime
						dt = datetime.time(14,4,23) #wszystkie argumenty są opcjonalne (domyślnie 
												    #00:00:00) możesz podać argumenty takie jak: 
													#godziny, minuty, sekundy, mikrosekundy, 
													#tzinfo (strefa czasowa)
				*datetime.datetime(year, month, day, hour, minute, second, microsecond, tzone)
						import datetime
						dt = datetime.datetime(1990, 1, 21, 22, 45,33)		
												#argumentami obowiązkowymi są 3 pierwsze: rok, 
												#miesiąc, dzień a reszta: godziny, minuty, sekundy, 
												#mikrosekundy, tzinfo (strefa czasowa) są opcjonalne. 
		  B)DATY dotyczące AKTUALNEGO CZASU:
				**now() - pokazywanie aktualnej daty lub czasu lub daty z czasem (jak today() tylko że 
					w funkcji now() możesz wprowadzić argument tz (timezone). Domyślnie ustawiony 
					jest na None. funkcja now() jest zalecana zamiast stosowania today() i utcnow():
						import datetime
						print(datetime.date.now())				#zwroci: 2021-06-22 
						print(datetime.time.now())				#zwroci: 07:35:34.073176
						print(datetime.datetime.now())			#zwroci: 2021-06-22 07:35:34.073176
				**today() - pokazywanie aktualnej daty lub czasu lub daty z czasem (jak now()
					tylko że w funkcji today() nie można wprowadzić argumentu tz (timezone)):
						import datetime
						print(datetime.date.today()				#zwroci: 2021-06-22 
						print(datetime.time.today()				#zwroci: 07:35:34.073176
						print(datetime.datetime.today()			#zwroci: 2021-06-22 07:35:34.073176
				**utcnow() - pokazywanie aktualnej daty lub czasu lub daty z czasem w strefie UTC0
					Mimo że nie możesz wprowadzić argumentu tz to możesz użyć metody replace podmienić
					parametr tzinfo.
						print(datetime.date.utcnow())			#zwroci: 2021-06-22 
						print(datetime.time.utcnow())			#zwroci: 07:35:34.073176
						print(datetime.datetime.utcnow())		#zwroci: 2021-06-22 07:35:34.073176

		1)STREFY CZASOWE:
			*Podstawy:
				 *Są 2 rodzajach obiektów dat: naive - o niskim stopniu detali ORAZ aware - o wysokim 
				  stopniu detali (Takich jak strefa czasowa lub zmiana czasu (letni-zimowy).
				 *Obiekty NAIVE są wtedy kiedy nie sprecyzujesz parameru strefy czasowej. Na nich nie
 				  mozesz zmieniać strefy czasowej (nawet tej domyślnej). 
				 *Do precyzowania strefy czasowej używasz specjalnego modułu - PYTZ. Najpierw musisz 
				  zainstalować pipem poprzez komenede w terminalu (pip install pytz) a pózniej w 
				  programie zaimportowac moduł pytz poprzez import pytz. 
				 *By zobaczyć wszystkie strefy czasowe użyj pola all_timezones :
						import pytz
						for x in pytz.all_timezones:
							print(x)
			*Tworzenie obiektów AWARE czyli precyzowanie strefy czasowej:
				*dla now(..., tz=...) - w parametrze tz, możesz podać albo stałą pytz.UTC albo funkcję 
				 pytz.timezone('timezoneName'):
						import datetime
						import pytz
						myD=datetime.datetime.now(tz=pytz.UTC)
						myD=datetime.datetime.now(tz=pytz.timezone('US/Mountain'))	
				*dla datetime(..., tzinfo=...) - w parametrze tzinfo, możesz podać albo tałą pytz.UTC 
				 albo poprzez funkcję pytz.timezone('timezoneName'):
						import datetime
						import pytz
						myD=datetime.datetime(2020,9,9,11,0,0,tzinfo=pytz.UTC)
						myD=datetime.datetime(2020,9,9,11,0,0,tzinfo=pytz.timezone('US/Mountain'))
				*dla utcnow(...).replace(tzinfo=...) - w utcnow() nie ma parametru tz albo tzinfo ale
				 można użyć funkcji replace i w niej użyć parametru tzinfo
						import datetime
						import pytz
						myD=datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)
						myD=datetime.datetime.utcnow().replace(tzinfo=pytz.timezone('US/Mountain'))
			*Zmiana strefy czasowej w obiekcie {.astimezone()} - 
				A) żeby mogła odbyć się zmiana strefy czasowej w obiekcie to najpierw musi ona być 
				   zadeklarowana (w przeciwnym wypadku przy próbie zmiany strefy czasowej ustawionej 
				   na None zwróci błąd). Deklaracja strefy czasowej może odbyć się w konstruktorze 
				   albo poprzez funkcje localize() wywołaną na obiekcie pytz czyli strefie czasowej:
						import datetime
						import pytz
					#dla obiektów now():
						myD=datetime.datetime.now()
						myD=pytz.UTC.localize(myD)							#ALBO
						myD=pytz.timezone('US/Mountain').localize(myD)		
					#dla obiektów datetime():
						myD=datetime.datetime(2020,9,9,11,0,0)
						myD=pytz.UTC.localize(myD)							#ALBO
						myD=pytz.timezone('US/Mountain').localize(myD)						
				B) Dopiero od tego momentu możesz wywołać funkcje astimezone() 
				   (na now(), datetime() i utcnow()):
						myD=myD.astimezone(pytz.timezone('US/Mountain'))
			 
		2)OPERACJE oraz POLA i METODY związane z obiektami DATETIME:
			*Na obiektach klasy datetime możesz wykonać ODEJMOWANIE i obliczyć różnice czasów:
						import datetime
						a = datetime.datetime.now()
						b = datetime.datetime(1990, 1, 21, 22, 45,33)	
						c =  a - b								#zwróci: 11575 days, 20:19:39.066993
				*możemy obliczyć całkowitą roznicę dwoch czasow biorac pod uwage rozne strefy czasowe 
				 i lata w sekundach:
				 https://stackoverflow.com/questions/4362491/how-do-i-check-the-difference-in-seconds-between-two-dates
						c.total_seconds()					    #zwroci floata: 1000154047.679009
				*możemy też określić co konkretnie nas interesuję odowłując się do pól:
				 days, seconds, microseconds. Jednakże nie będzie to sumować dni, godzin, minut sekund
				 tylko weźmie poszczególne wartośći (np.: pozostałe sekundy po odjęciu wszystkich dni)
						print(c.days)							#zwróci: 11575		
						print(c.seconds)						#zwróci: 74003		
						print(c.microseconds)					#zwróci: 807023	
			*Na obiektach klasy datetime (now(), datetime()) możesz odwołać się do poszczególnych
			 pól jak: year, month, day, hour, minute, second, microsecond							
						import datetime
						dt=datetime.date.now().year				#zwróci: 2016
						dt=datetime.time.now().hour				#zwróci: 07
						dt=datetime.datetime.now().day			#zwróci: 22
			*Na obiektach klasy datetime.datetime (now(), datetime(),utcnow()) możesz odwołać się do metod:
				*date() - zwraca całą datę dla obiektu datetime:
						import datetime
						print(datetime.datetime(2016,7,9,14,0,0).date())	#zwróci: 2016-07-09
						print(datetime.datetime.now().date())				#zwroci: 2021-06-22
				*time() - zwraca cały czas dla obiektu datetime:
						import datetime
						print(datetime.datetime(2016,7,9,14,0,0).time()		#zwroci: 14:00:00:000
						print(datetime.datetime.now().time())				#zwróci: 10:48:04.930
				*weekday() - zwraca numer dnia tygodnia liczony od zera jako Monday
						import datetime
						dt=datetime.date.now().weekday()					#zwróci 3 (czwartek)
				*isoweekday() - zwraca numer dnia tygodnia liczony od jedynki jako Monday
						import datetime
						dt=datetime.date.now().isoweekday()					#zwróci 4 (czwartek)
			   !*datetime.strftime(regex) - (string format date) zwroci stringa sformatowanego z obiektu 
					typu datetime (.strftime("%...") w miejsce wykropkowania wpisujesz REGEXOWE parametry:
					https://www.programiz.com/python-programming/datetime/strftime 
						import datetime
						myD = datetime.datetime.now()
						year_and_month = myD.strftime("%Y,: %B")
						print(year_and_month)								#zwróci: 2021,: October
				    *możesz też podejśc do tego w inny sposób tzn: stworzyć obiekt datetime
					 oraz stringa który wewnątrz bedzie miał zapisane {: ... } a wśrodku tych nawiasów
					 będziesz miał specjalne oznaczenia (te powyżej) + następnie to formatujesz funkcją 
					 format wstawiając do niej zmienną którą wczesniej stworzyłeś
						import datetime
						dt=datetime.date(1956, 1, 31)
						message="Your datetime is {: %A, %B, %d, %Y}".format(dt)
													#zwróci Your datetime is Tuesday, January, 31, 1956		
						
		3)KLASA DATETIME ma też FUNKCJE NIEWYWOŁYWANE NA OBIEKTACH jak:
			   !**datetime.strptime(string, regex)- (string parse date) zamiana stringa na obiekt datetime:
					https://www.programiz.com/python-programming/datetime/strptime  
						import datetime
						dateString = 'Sun 10 May 2015 13:54:36 -0700'
						date_Object= datetime.datetime.strptime(dateString, '%a %d %b %Y %H:%M:%S %z')
						print(date_Object)							#zwróci: 2015-05-10 13:54:36-07:00
						
				**timedelta(integer) - zadeklarowanie specjalnego przedziału domyślnie liczonego w dniach:
						import datetime
						dt=datetime.timedelta(100)				#deklarujesz zmienną o wielkości 100 dni
						myD=datetime.date(2000, 1, 31) + dt 	#zwroci 2000-05-11
					*w argumencie możesz też przypisać inne wartości niż dni jak:
					 year, month, day, hour, minute, second, microsecond			
						import datetime
						dt=datetime.timedelta(minutes=10)		#deklarujesz zmienną o wielkości 10 minut
						myD=datetime.datetime(2000, 1, 31,14,4,23) + dt 	#zwroci 2000-01-31 14:14:23
				**fromtimestamp(mod_time) - przeliczenie sekund od momentu utworzeniu/modyfikacji pliku 
				  na datę i godzinę:
						import os
						import datetime
						mod_time=os.stat('demo.txt').st_mtime()
						print(datetime.fromtimestamp(mod_time))
					
		4)STRING REGEXY wykorzystywane w metodach strptime(string, regex) oraz strftime(regex):	
		  https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior 
		  https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
				  %a		Weekday, short version					Wed	
				  %A		Weekday, full version					Wednesday	
				  %w		Weekday as a number 0-6, 0 is Sunday	3	
				  %d		Day of month 01-31						31	
				  %b		Month name, short version				Dec	
				  %B		Month name, full version				December	
				  %m		Month as a number 01-12					07	
				  %y		Year, short version, without century	18	
				  %Y		Year, full version						2018	
				  %H		Hour 00-23								17	
				  %I		Hour 00-12								05	
				  %p		AM/PM									PM	
				  %M		Minute 00-59							41	
				  %S		Second 00-59							08	
				  %f		Microsecond 000000-999999				548513	
				  %z		UTC offset								+0100	
				  %Z		Timezone								CST	
				  ----------------------------------------------------------------------
				  %j		Day number of year 001-366				365	
				  %U		Week number of year, Sunday as the
							first day of week, 00-53				52	
				  %W		Week number of year, Monday as the 
							first day of week, 00-53				52	
				  %c		Local version of date and time			Mon Dec 31 17:41:00 2018	
				  %x		Local version of date					12/31/18	
				  %X		Local version of time					17:41:00	
				  %%		A % character							%	
				  %G		ISO 8601 year							2018	
				  %u		ISO 8601 weekday (1-7)					1	
				  %V		ISO 8601 weeknumber (01-53)				01			
						
	MODULE CALENDAR:
		*wyswietlenie dnia tygodnia z podanej daty 
			--> funkcje weekday(int(year),int(month),int(day)) i day_name(int)
			https://docs.python.org/2/library/calendar.html#calendar.weekday - weekday() method
			https://www.w3resource.com/python/module/calendar/weekday.php - weekday() method
			https://www.alpharithms.com/python-datetime-weekday-name-482616/ - how to show name of weekday
				import calendar
				day, month, year=input().split()
				name=calendar.weekday(int(year),int(month),int(day))
				print(calendar.day_name[name].upper())
		*sprawdzenie od jakiego dnia tygodnia zaczyna się miesiąc w danym roku (0=Monday, 1=Tuesday ...)
 		 oraz ile dni ma dany miesiąc w danym roku:		calendar.monthrange(year, month)
				import calendar
				import datetime
				today=datetime.datetime.today()
				weekdayName_of_start_of_month, days_in_month = calendar.monthrange(today.year, today.month)
		*sprawdzenie czy rok jest przestępny (ma 29 dni):
				import calendar
				isLeap = calendar.isleap(2020)						#zwróci: True

0* MODUŁY i ich importowanie:
	*PODSTAWY:
		*w innych jezykach programowania moduly sa nazywane bibliotekami
		 [moduly moga byc tez czescia biblioteki]
		*biblioteki/moduly domyslne - zestaw funkcji juz wbudowane w jezyk Python
		*z modulu mozesz tez pobrac nie tylko funkcje ale tez zmienna albo kolekcje albo stale np.:
					from math import pi     
					print(pi)
		*jakbys chciał stworzyć SWÓJ WŁASNY moduł to wystarczy że zapiszesz go w pliku z 
		 rozszerzeniem .py
		*do modułów możesz stosować też alias i pozniej zapiast spisywac pełne imie modułu 
		 to używać ten aliasowy:
						import mymodule as mx
						a = mx.person1["age"]
	*sa 2 opcje pobierania modułów:
		a)	importujesz cale moduly -> wtedy przy wywolaniu funkcji musisz 
			przedtem zapisac nazwe modułu i kropkę a po niej nazwe funkcji z modulu np.:
					import random
					random.randint(1,10)
		b)	importujesz tylko dana funkcje z modulu -> wtedy juz nie musisz 
			przedtem zapisywac nazwy modulu i kropki przed wywolaniem dunkcji
					from random import randint
					randint(1,10)
		C)	nie wolno pobierać funkcji z modułu za pomocą gwiazdki tj:
					from math import *
			tworzy to trudnodebugowalny kod i można zbyt łatwo nadpisać funkcje z modułą swoją. 
	*ROZSZERZENIE:
		*wszystkie bilbiotwki domyslnie wbudowane w pythona mozesz sprawdzic na python.org 
		 lub wpisujac slowko from i wybierajac jedna z podpowaidanych bibliotek 
		*gdy importujesz jakiś moduł w jakims innym module to oprócz tego że możesz korzystać z jego
		 klas i funkcji to automatycznie jest on kompilowany od góry do dołu tzn że wszystkie wywołane 
		 funkcje w tym importowanym module są automatycznie wywoływane (łącznie z drukowaniem wszystkich 
		 printów) 
			#jeżeli chciałbyś wywoływać jakieś funkcje tylko podczas bezpośredniego wywołania danego 
			 modułu a nie podczas jego importowania to powinineś je zawrzeć w bloku:
					if __name__=='__main__':
						...
			 gdyż przy kompilacji każdego modułu na początku sa przypisywane zmienne, m.in zmienna __name__
			 która przyjmuję nazwę modułu (jeżeli został on gdzieś zaimportowany) lub __main__ jeśli 
			 jest plik odpalany bezpośrednio.
			 Więcej na:		 https://www.youtube.com/watch?v=sugvnHA7ElY
		*NAZYWANIE MODUŁÓW, FUNKCJI  I ZMIENNYCH W IMPORTOWANIU MODUŁÓW:
			*gdybyś stworzył moduł o tej samej nazwie co moduł z biblioteki standardowej pythona lub 
			 moduł instalowany z zewnątrz to python w wyniku pierszeństwa zaimporuję twój wewnętrznie 
			 stworzony moduŁ.
			*do tego gdybyś stworzył funkcje która ma taką samą nazwę co jakaś funkcja z bibliotek 
			 standardowych to python również w wniku pierszeństwa będzie brał tę funkcje z TWOJEGO modułu.
					from math import raidians
					def radians():				#zadeklarowanie funkcji o nazwie funkcji z modułu math 
						print('blablabla')
					print(radians(90))			#python będzie próbował uruchomić naszą funkcję 
												#zamiast funkcji radians z modułu math
			*do tego gdybyś stworzył zmienną o tej samej nazwie co nazwa jakieś funkcji z biblioteki 
			 standardowej i chciał wywołać tę funkcję to python w wyniku pierszeńśtwa potraktuję to jak 
			 próbę użycia funkcji z tej zmiennej  np:
					from math import radians
					radians = radians(90)		#zadeklarowanie zmiennej o nazwie funkcji z modułu math
					print(radians(90))			#wywołanie zmiennej radians jako funkcji 
												#zamiast radians z modułu math
		*gdy importujesz jakiś moduł Python odwołuję się do modułu sys i zmiennej path:   sys.path  
		 Python wyszukuję go w ścieżkach które sys.path przechowuję. Jest tam ścieżka do folderu 
		 pliku jak i ścieżki środowiskowe (environments path): 
					import sys
					for path in sys.path:
						print(path)	  
					#zwróci:
					 d:\marek\PROJECTS_PYTHON\0.Corey_Shaffer\remembering
					 C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.9_3.9.2032.0_x64__qbz5n2kfra8p0\python39.zip      
					 C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.9_3.9.2032.0_x64__qbz5n2kfra8p0\DLLs
					 C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.9_3.9.2032.0_x64__qbz5n2kfra8p0\lib
					 C:\Users\Kalina\AppData\Local\Microsoft\WindowsApps\PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0
					 C:\Users\Kalina\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0\LocalCache\local-packages\Python39\site-packages
					 C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.9_3.9.2032.0_x64__qbz5n2kfra8p0
					 C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.9_3.9.2032.0_x64__qbz5n2kfra8p0\lib\site-packages 
					#zwróci:
					 *ścieżkę do folderu pythona w któym znajduję się plik
					 *python path environment variable (ścieżki środowiskowa)
					 *śćieżki do standardowych bibliotek
					 *zewnętrzne paczki w site-packages			
			*jeżeli masz jakiś plik poza tymi ścieżkami to:
				*możesz dodać daną ścieżkę poprzez funkcję append()
					sys.path.append('/users/corey/Desktop/my_folder_module')
				 ale nie jest to dobre rozwiązanie gdyż jeżeli będziesz w każdym pliku .py dodawał
				 w ten sposób moduły to gdy zmienisz folder takiego modułu to będziesz musiał w 
				 każdym pliku .py zmieniać tę ścieżkę w metodzie append DLATEGO:
				*lepiej jest dodać scieżkę do zmiennych środowiskowych (czyli do listy sys.path)
					*na Macu w terminalu:
						nano ~/.bash_profile
						export PYTHONPATH="/users/corey/Desktop/my_folder_module"
						#ctrl+x ;; Y ;; ENTER
					*na Windowsie poprzez ustawiwenia:
						start -> computer -> properties -> advanced system settings -> environment 
						variables -> NEW: np.: PYTHONPATH, C:/users/corey/Desktop/my_folder_module

			
############## LOGGING | UNIT TESTS | PYTEST | PYDOC | PIP | VENV + VIRTUALENV | PIPENV ####################
PIPENV:					https://www.youtube.com/watch?v=6Qmnh5C4Pmo
PIP MANAGING: 			https://www.w3schools.com/python/python_pip.asp
PYDOC:					https://www.youtube.com/watch?v=URBSvqib0xw
ASSERTS in UNITTESTS:	https://www.mattcrampton.com/blog/a_list_of_all_python_assert_methods/	
LOGGING BASICS:			https://youtu.be/jxmzY9soFXg
LOGGING INTERMEDIATE:	https://www.youtube.com/watch?v=p0A4CV4MWd0

7* PIPENV:
   https://www.youtube.com/watch?v=6Qmnh5C4Pmo
	*to rekomendowany sposób do instalacji paczek/modułów oraz jednoczesnego działania na wirtualce. 
	 Nie tylko służy do automatycznego zainstalowania wirtualki ale również zarządzania nią. Tak samo z 
	 paczkami - nie tylko instalacja ale też zarządzanie.
	*W przypadku korzystania z samego pipa wszystkie paczki instalowane są globalnie (w miejscu gdzie masz 
	 zainstalowanego pythona w katalogu \Lib\site-packages) a w przypadku pipenv'a każdy osobny projekt 
	 będzie miał instalowane paczki na osobnej wirtualce.
	*KOMENDY PIP'a rozpoczynające pracę z pipenvem:
		*instalacja pipenv'a:		 
						pip install pipenv		|		pip3 install pipenv
		*zrzut wszystkich globalnie zainstalowanych paczek/modułów (NIE na wirtualce):
						pip freeze		 | 		pip3 freeze
												#zwróci np:	certifi==2021.5.30
															charset-normalizer==2.0.6
															idna==3.2
															pipenv==2021.5.29
															platformdirs==2.4.0
															pytz==2021.3
															urllib3==1.26.6
															virtualenv==20.8.1
															virtualenv-clone==0.5.7								
	*KOMENDY pipenv'a:
		*UTWORZENIE WIRTUALKI i AKTYWACJA:	
			*utworzenie wirtualki odbywa się poprzez pierwsze użycie jakiejkolwiek komendy związanej 
			 z pipenv (pod warunkiem że będziesz znajdował się w folderze projektu). Oprócz utworzenia
 			 wirtualki we wskazanym osobnym folderze powstaną 2 pliki:
				**pipfile - plik .toml, zawierający wszystkie nazwy paczek/modułów z wersjami tychże 
				  paczek/modułów. Najważniejszy jest klucz [packages] gdzie masz wykaz wszystkih 
				  poinstalowanych modułów/paczek/dependencies wg schematu:
				  (camelcase = "==2.4" lub camelcase = "*" (* -oznacza że najnowsza wersja)) 
				**pipfile.lock - plik, którego się NIE MODYFIKUJĘ, który jest automatycznie generowany i
				  zawiera hierarchie poinstalowanych modułów/paczek. 
			*aktywacja środowiska wirtualki:
							pipenv shell 	 lub      wpisanie ścieżki do wirtualki + \bin\activate
							pipenv lock -r
				**nastęnie wpisujesz 		python	 	 i już działasz na interpreterze zainstalowanym 
				  lokalnie (w wirualce) a nie globalnie.
				**żeby wyjść z tego środowiska musisz użyć komendy   	 exit 		(inaczej ciągle 
				  będziesz w wirtualce i będzie ona aktywna)
			*możesz też działać na wirtualce nie aktywując jej. Wtedy nie trzeba jej zamykaĆ żadną 
			 komendą exit. Robisz to poprzez:
							pipenv run python 		|  		pipenv run python script.py
		*ODTWORZENIE WIRTUALKI NA OTRZYMANYM GOTOWYM PROJEKCIE:
			*przy przekazywaniu komuś kodu ogólnie wirtulka nie ma znaczenia i jej się nie przesyłA. 
			 Najważniejsze są pliki pipfile oraz pipfile.lock .Dzięki nim można można odtworzyć nową
			 wirtualkę wraz ze wszystkimi potrzebnymi instalacjami i ich wersjami, których nazwy i wersje
			 są zapisane w tychże plikach. W terminalu musisz być wewnątrz projektu i najpierw stworzyc
			 wirtualkę a później odtworzyć wszystkie instalacje z pliku pipfile: 
							pipenv shell
							pipenv lock --requirements 	      | 		pipenv install
			*możesz też odtworzyć instalacje z pliku pipfile.lock gdzie zamiast najnowszych wersji 
			 będziesz miał dokładne wersje na których projekt jest stabilny (w ten sposób powinno się 
			 to robić)
							pipenv shell
							pipenv install --ignore-pipfile			
		*INSTALACJA, UPDATOWANIE:
			*instalacja konkretnej paczki/modułu:
				**używanej w produkcji końcowej aplikacji (będzie widoczne w pliku pipfile w kluczu 
				  [packages]):
							pipenv install camelcase
				**używanej tylko środowisku developerskim (tj przy np testach)( --dev):
							pipenv install pytest --dev
			*instalacja dependencies (czyli wymaganych modułów/paczek) z pliku requirements.txt używanego 
			 w pip'ie, czyli jak dodać dodatkowe moduły/paczki których używają inni programiści używający 
			 na codzień pipa zamiast pipenva:
							pipenv install -r  ../ścieżka_do_requirements/requirements.txt
			*updatowanie wersji paczek/modułów lub instalacja wielu modułów/paczek (które wcześniej trzeba
 			 wpisać do pliku pipfile w kluczu [packages] (muszą być one dodane wg składni pliku 
			 requirements.txt (używanego w pip'ie do określania dependencies czyli potrzebnych 
			 moułów/paczek) tj.:	   nazwaPaczki = "==2.4"   )) i zatwierdzenie poprzez komende:
							pipenv install
			*odinstalowanie konkretnej paczki/modułu (oprócz tego że zostanie odinstalowany ze środowiska
			 wirtualki to jeszcze zostanie usunięty z pliku pipfile (i automatycznie z pliku pipfile.lock)
							pipenv uninstall camelcase
		*ZMIANA WERSJI PYTHONA W PROJEKCIE (w wirtualce):
			*najpierw zmieniasz numer wersji pythona w pliku pipfile a potem zatwierdzasz to przez komende:
			 pipenv --python 3.8.2			(3.8.2 - czyli wpisujesz numer wersji którą chcesz i ponadto
			 masz zainstalowaną na swoim komputerze) 
			*drugą metodą jest usunięcie środowiska wirtualnego poprzez komende: 		pipenv --rm 	
			 zmiena numeru wersji w pliku pipfile i następnie komenda:		   pipenv install
		*WYKAZ ZAINSTALOWANYCH MODUŁÓW/PACZEK/DEPENDENCIES i innych:	
			*wykaz wszystkich zainstalowanych paczek/modułów w wirtualce (w PIP'e byłoby to pip freeze)
							pipenv lock -r			
			*wykaz dependencies i ich dependenciesw wirtualce (w formie drzewa):
							pipenv graph
			*wykaz ścieżki do środowiska wirtualnego gdzie zapisane są wszystkie dependencies:
							pipenv --venv
		*SPRAWDZANIE LUK BEZPIECZEŃSTWA w pobranych paczkach/modułach (security vulnerabilities):
							pipenv check
  !!*SOFTWARE DEPLOYMENT - KOŃCOWE WYDANIE APLIKACJI 		!!!!!!!!!!!         :
	 przy wydaniu aplikacji chcesz żeby aplikacja pracowała na wersjach paczek/modułów które przeszły
	 przygotowane przez Ciebie testy i nie chcesz żeby widniała informacja że masz 'najnowsze wersje' 
	 paczek/modułów (czyli tak jak jest to określone w pliku pipfile poprzez gwiazdkę (*)), gdyz po 
	 jakims dłuższym czasie wersja paczki może tak się diametralnie zmienić że aplikacja przestanie 
	 chodzić. Dlatego przy końcowym oddaniu projektu musisz zaktualizować plik pipfile.lock gdzie 
	 jest zapisywana dokładna wersja paczki i nakazać ignorowanie pliku pipfile (gdzie masz odwołanie
	 że ma być najnowsza) Robisz to poprzez:
							pipenv lock 
							pipenv install --ignore-pipfile
	*WRAŻLIWE ZMIENNE ŚRODOWISKOWE:
		*musisz stworzyć w katalogu projektu plik o nazwie 	 .env	,gdzie możesz przetrzymywać klucze 
		 do API albo jakies inne dane wrazliwe, któe będziesz wykorzystywał do wielu plików.
		*plik będzie automatycznie uruchmiany za każdym razem gdy będziesz uruchamiał interpreter 
		 pythona ze swojej wirtualki.
		*ten plik należy wpisac na listę pliku .gitignore żeby nie był wysyłany na repozytorium
		
6* VENV + VIRTUALENV
	VENV WINDOWS: 		https://www.youtube.com/watch?v=APOPm01BVrk
	VENV LINUX + MAC: 	https://www.youtube.com/watch?v=Kg1Yvry_Ydk
	VIRTUALENV:
		0* INSTALACJA:
					pip install virtualvenv
		1* UTWORZENIE:
					virtualenv name_project
			** -p - instalacja z konkretną wersją pythona:
					virtualvenv -p /scieżk_do_pythona_zainstalowanego_lokalnie nazwa_projektu
		2* AKTYWACJA - musisz aktywować za każdym razem gdy chcesz działać na pythonie/pipie/bibliotekach 
		   znajdujących się w wirtualce (najlepiej poprzez konsole UNIXową (czyli linuxową) bo w windowsowej 
		   coś nie działa) i deaktywować po zakończonej pracy)
					source path_project_ven/Scripts/activate
					deactivate
		   Możesz sprawdzić która wersja pythona lub pipa (i gdzie się znajdująca) jest wykorzystywana:
					which python				#pokaże Tobie scieżkę do miejsca gdzie używany jest python
		   (Odpalona wirtualka będzie widoczna przede wszystkim poprzez nazwę projektu w nawiasach):		
		3* ZAPISANIE paczek w pipie znajdujących się w wirtualce i wgranie ich do nowej wirtualki:
					pip freeze --local > requirements.txt
					pip install -r requirements.txt

5* PYPI.ORG oraz PIP:
  PYPI:
	*miejsce gdzie możesz pobrać wszystkie interesujące cię biblioteki i moduły.
  PIP MANAGING: 	https://www.w3schools.com/python/python_pip.asp
	*jest to module/package manager - jest to program do zarządzania modułami
	*od wersji 3.4 Pythona is included by default -> sprawdz w konsoli: commend(pip --version)
	*przy zarządzaniu modułami musisz znajdować się w folderze projektu a nie w folderze 
	 gdzie jest zainstalowany python (poradnik jest pokazany tak jakbyś nie pracował na 
	 wirtualce)
	*TWORZENIE SWOICH WŁASNYCH MODUŁÓW I PACKAGES wraz z ICH ZARZĄDZANIEM znajdziesz w:
			https://www.programiz.com/python-programming/package
	*KOMENDY:
		*pip list - będąc w konsoli (znajdując się w katalogu projektu) wyswietlenie wszystkich 
		 zainstalowanych modulów
					pip list
			** --outdated / -o  - wyświetla wszystkie moduły które nie mają najnowszej wersji 
					pip list --outdated
		*pip freeze / pip freeze > requirements.txt - robi zrzut wszystkich poinstalowanych 
		 paczek w specjalnym formacie. Można zapisać tenże zrzut to poprzez znak '>' w pliku
		 requirements.txt dzięki któremu na innym komputerze w łatwy sposób można odtworzyć 
		 instalację tychże paczek (poprzez: pip install -r requirements.txt)
					pip freeze
					pip freeze > requirements.txt
		*pip install / pip uninstall - najlepiej używać na wirtualce (w pycharmie domyslnie 
		 tworzy ci wirtualke) bo inaczej będąc we folderze programu na zwyklej ogolnej konosli 
		 to zainstaluje ci w głównym katalogu zainstalowania programu i przy wiekszej liczbie 
		 projektow bedzie ci się mylic do ktorego projektu jest ktory moduł potrzebny) (wtedy 
		 obojętnie w jakim katalogu projektu bedziesz gdyż pip i tak będzie wiedział żeby 
		 poinstalować moduł w katalogu site-packages) i tam zostanie zainstalowany jakis modul:
					pip install 'jakismodul'		//lub 
					python3 -m pip install 'jakismodul'
			** --upgrade / -U  - upgrade do najnowszej wersji zainstalowanego wcześniej modułu
					pip install -U 'jakisModul'
			** --requirement / -r - instalacja wszystkich bibliotek z pliku requirements.txt 
			   (zawierającego zrzut paczek w odpowiednim formacie)
					pip install -r requirements.txt					
		*pip help / pip help komenda - wyswietla wszystki komendy używane w pipie albo flagi do 
		 tychże komend.
					pip help
					pip help install
		*pip search 'jakisModul' - wyswietla ci informacje o tym do czego służy dany moduł.
4* PYDOC:
   https://www.youtube.com/watch?v=URBSvqib0xw
	*przy tworzeniu klas i metod zawsze po zadeklarowaniu warto w trójcudzysłowiu umieścić 
	 komentarz który de facto staję się dokumentacją. 
	*Module PyDoc służy do tego żeby automatycznie wygenerować ładną i uporządkowaną stronę 
	 tejże  dokumentacji. 
	*Działa to jak funkcja help(methodexample) ale pydoc ma więcej dodatków:
		*przy pydoc nie musisz pobierać danego modułu jeżeli nie jest on wbudowany (przy help
		 musisałbyś to zrobić.
		*ma funkcje które pozwalają wygenerować dokumentację własnego modułu i udostępnić go innym 
	*FUNKCJE PYDOC:
	 #otwórz konsolę i wpisz tam     python -m pydoc    wyświetlą ci się wszystkie funkcje
	  modułu pydoc. Pamiętaj o opcji '-m' żeby wyświetliło się to Tobie jako skrypt. 
			*python -m pydoc <name>  - pod <name> wpisz nazwę modułu/klasy/metody/funkcji
			 i wyświtlą ci się wzystkie istotne informacje z tym związane. 
			*python -m pydoc -k <keword> - pod <keyword> wpisz nazwę modułu/klasy/metody/funkcji
			 a wyświetlą ci się wszystkie moduły/klasy/metody/funkcje które zawierają
			 daną fraze - działa jak wyszukiwarka
			*python -m pydoc -p <nrPortu> / python -m pydoc -b   - pod <nrPortu> wpisujesz 
			 numer portu na którym wyświetli ci się stronę http w twojej przeglądarce (po
			 wciśnieciu b)(dla drugiej opcji port zostanie dobrany automatycznie) ze wszystkimi
			 modułami które masz pobrane na swoim komputerze. Wszystko w ładnej graficznej 
			 oprawie podzielonej na moduły/klasy/metody/funkcje.
			*python -m pydoc -w <nameModule> - pod <nameModule> wpisujesz nazwe modułu który
			 zostanie zapisany w pliku html jako wytworzona automatycznie dokumentacja.
			 W ten sposób jesteś w stanie stworzyć plik.py (który jest od razu modułem) 
			 i zapisać go w formie dokumentacji w pliku html. Musisz w konsoli znajdować się
			 w odpowiednim folderze (czyli tam gdzie plik się znajduję):
					python -m pydoc -w plik.py	#pokaze się informacja: 'wrote plik.html
												#i następnie dlaej w konsoli wystarczy wpisać
					start plik.html				#start plik.html
			 teraz możesz wysłać innym taki plik html z wytworzoną automatycznie dokumentacją. 
			 
3* WAŻNE FUNKCJE POMOCNICZE (wstęp do PYDOC)
  *PODSTAWOWE:
	*dir() - wymieni wszystkie główne elementy, czyli: wbudowane moduły, zadeklarowane
			przez Ciebie klasy, zadklarowane przez Ciebie funkcje któe nie są zadeklarowane 
			w klasie wszystkie zadeklarowane zmienne przez Ciebie które nie są w w klasie 
			oraz wszystkie moduły które zaimportowałeś.
	*dir(__builtins__) - wymieni wszystkie funkcje które znajdują się wewnątrz 
			danego modułu - w tym przypadku wbudowanego modułu builtins. 
	*dir(object) - Pokaże Tobie nie tylko funkcje danego mdułu ale wszystkie których będziesz
			mógł użyć na danym obiekcie (te z builtinsów również)	
	*help(functionName) - pokaże czego dotyczy dana funkcja, co zwraca i jakich 
			argumentów wymaga. Te w nawiasach kwadratowych sa argumentami opcjonalnymi. 
			Dodatkowo na samym dole znajdziesz też przykład użycia. 
     w przypadku gdybyś chciał sprawdzić jakiś moduł który nie jest wbudowany to najpierw 
	 musisz go zaimportować. Dopiero od tego momentu możesz na nim korzystać z funkcji dir() 
	 i help() TYLKO że z założeniem że dla wszystkich funkcji które są z zaimportowanych 
	 modułów musisz podać wpierw ścieżkę czyli nazwę modułu i nazwę funkcji np:
					import math
					dir(math)
					help(math.radians)
  *MODUŁ INSPECT - sprawdza w danym module które elementy są klasami a które funkcjami
	*trzeba pobrać odpowiednio wcześniej daną klasę 
	*korzysta z 3 ważnych funkcji: getmembers  któy wykorzystuję isclass i isfunction
					import xml.etree.ElementTree as ET
					from inspect import getmembers, isclass, isfunction
					for (name, member) in getmembers(ET, isclass):
						if not name.startswith('_'):
							print(name, member)

2*PYTEST:



1*UNIT TESTS:
ASSERTS in UNITTESTS:	https://www.mattcrampton.com/blog/a_list_of_all_python_assert_methods/	
	1)Najlepsze praktyki:
		*SĄ 2 konwencje nazywania unit-testów:
			*nazwanie ich z przodu test później podkreślnik i na samym końcu nazwa klasy którą 
			 testujesz: -> dzięki temu grupuję się testy w jednym miejscu.
				circles.py
				ellipsses.py
				test_circles.py
				test_ellipsses.py
			*najpierw wpisujesz nazwę klasę, podkreślnik i na samym końcu test -> dzięki temu
			 za zawsze bezporednio pod klasą z którą są związane. 
				circles.py
				circles_test.py
				ellipsses.py
				ellipsses_test.py
		*Test-driven-development - najlepszą praktyką jest pisa testy zanim zaczniesz pisać 
			właścwiwy kod.
	2)STRUKTURA:
		*importujesz moduł 'unittest' oraz moduł którego funkcje będziesz testował.
		 (poniżej moduł circle.py który będziesz póżńiej sprawdzał unittestami):
							import math
							def circle_area(r):
								return math.pi*(r**2)
							def add(a,b):
								return a+b
		*tworzysz klasy o nazwach zaczynających się od Test... gdzie będą unit testy dla 
		 danych funkcji pochodzących z testowanego modułu.
		*Te klasy mają dziedziczyć po klasie TestCase z modułu unittest (unittest.TestCase)
		*FUNKCJE TESTUJĄCE w tejże klasie będą unit testami dla tej jednej funkcji która 
			będzie przez całą klasę unittestów testowana -> muszą one zaczynać się od 
			słowa test...
							import unittest
							import circle
							class TestCircleArea(unittest.TestCase):
								def test_area(self):
									...
								def test_values(self):
									...
							class TestAdd(unittest.TestCase):
								def test_positive(self):
									...
								def test_negative(self):
									...
				***może być też tak że cała klasa będzie testowała cały moduł zamiast funkcji 
				   a wtedy funkcje test_... w tej klasie będą odpowiedzialne za testowanie 
				   poszczególnych funkcji w module docelowym:
							import unittest
							import circle
							class TestCircle:
								def test_circleArea(unittest.TestCase):
									...
								def test_add(unittest.TestCase):
									...
	3)FUNKCJE w klasie:
		*FUNKCJE TESTUJĄCE:
			*w tychże funkcjach testujących (test_...) będziesz korzystał z różnych ASERCJI.
			*żeby dowiedzieć się więcej o danej asercji to najlepiej skorzystąc z funkcji help. 
			 pamiętaj żeby wcześniej zaimportować moduł unittest. 
			 (WSZYSTKIE ASERCJE:	 https://www.mattcrampton.com/blog/a_list_of_all_python_assert_methods/ )
			*ASERCJE wykonujesz na polu self i są metodami sprawdzającymi czy 'nasza' funkcja 
			 zwróci wynik który został jej przedstawiony. Albo czy zwróci odpowiedni dany typ 
			 wyjątku, np:
				*assertAlmostEqual(functionWithArg, result) - sprawdza czy podana funkcja z 
					podanymi w niej argumentem zwróci taki sam wynik jak w drugim argumencie.
								def test_result(self):
									from math import pi
									self.assertAlmostEqual(circle_area(2.5),(2.5**2)*pi)
				*assertRaises(ExceptionShouldBeRaised, function, argToFunction) - sprawdza czy 
					czy dla specjalnego argumentu podanego do naszej funkcji podniesie się 
					wyjątek (który wcześniej w naszej podstawowej funkcji trzeba obsłużyć). 
						*Podajesz nazwe wyjątku, nazwę funkcji, argumenty po przecinku:
								def test_values(self):
									self.assertRaises(ValueError, circle_area,-2) 
														#-2 gdyż promień nie może być ujemny
								def test_types(self):
									self.assertRaises(TypeError, circle_area, 3+5j)
									self.assertRaises(TypeError, circle_area, [1,2,3])
									self.assertRaises(TypeError, circle_area, 'number')
						*Możesz też to ogarnąć poprzez contex managera:
								def test_types(self):
									with self.assertRaises(TypeError):
										circle_area(3+5j)
					przez ten unittest musisz zmienić schemat działania swojej funkcji 
					podstawowej dodając do niej obsługę sytuacji wyjątku ValueError. 
												#def circle_area(r):
												#	if r < 0:
												#		raise ValueError("Cannot be < 0")
												#	if r not in [float, int]:
												#		raise TypeError('Only int or float')
												#	return math.pi*(r**2)
			*MOCKING do testowania czy linki są dobrze tworzone:
			 https://www.youtube.com/watch?v=6tNS--WetLI - 28:30 - 37:00
			 
		*FUNKCJE DODATKOWE na użytek funkcji testujących - czasami potrzebujesz stworzyć 
		  jakieś obiekty przed każdą z funkcji testującej albo potrzebujesz raz przed 
		  wszystkimi testami załadować jakąs podręczną bazę danych. Do tego slużą funkcję:
			*setUp(self)  	;; 	  tearDown(self) 
				**funkcje wewnątrz klasy które będą się odpalać za każdym razem przed każdą
				  funkcją testującą i po niej. 
				**dzięki temu będziesz mógł stworzyć przed każdą funkcją testującą jakieś 
				  obiekty które będziesz poddawał testom [teoretycznie mógłbyś to zrobić 
				  poprzez argument klasowy jednakże przy każdym teście będzie on 
				  modyfikowany a ty chciałbyś żeby przed każdym testem był tworzony od zera]
				  ; oraz po każdym teście wykonywać jakieś działania podsumowujące
							import unittest
							import circle
							import employee
							class TestCircle:
								def setUp(self):
									self.emp_1=new Employee('Marek', 'Darek')
								def tearDown(self):
									self.emp_1=None
			*@classmethod 	    		 @classmethod
			 setUpClass(cls) 	 ;;  	 tearDownClass(cls) 
				**metody klasowe wewnątrz klasy które odpalą się tylko raz przed i po 
				  wszystkich testach
				**dzięki temu będziesz mógł załadować jakąc próbną bazę danych przed 
				  wszystkimi testami i skasować ją po wszystkich testach:
							import unittest
							import circle
							class TestCircle:
								@classmethod
								setUpClass(cls):
									...
								@classmethod
								tearDownClass(cls):
									...
	4)ODPALENIE UNITTEST'ów:
		*żeby odpalić te unittesty to musisz wejść przez konsolę cmd w folder w którym 
		 znajdują się te pliki oraz testy i następnie wpisać komende:
					python -m unittest test_circles				#LUB
					python -m unittest test_circles.py
		 gdzie '-m' oznacza to że odapli się to w postaci skryptu. W tej komendzie możesz 
		 wpisywać nazwę pliku z testem ale też nie musisz gdyż jezeli tego nie zrobisz to 
		 python i tak wyszuka wszystkie pliki z nazwą test i je odpali.
					python -m unittest 
		*możesz też odpalić unittesty bezpośrednio z edytora wpisując w klasie testującej:
					if __name__=='__main__':
						unittest.main()
		 i odpalenie poprzez ctrl+F5 lub w konsoli tym razem bez odpalenia przez unittest:
					python test_circles.py
		*unittesty (funkcje testujące) odpalają się w LOSOWEJ KOLEJNOŚCI
		*Zarówno w konsoli jak i w IDE będzie widać które unittesty się wysypały: kropka 
		 oznacza że test się udał znak F że nie. Ponadto będzie widoczny napis FAIL z 
		 wymienioną nazwą testu oraz podsumowanie FAILES z ilością nieudanych testów. 

0* LOGGING:
	*Przeznaczenie:
		*zamiast wszędzie używać printa do sprawdzania postępów w programie (czy cos działa)
		*służy głównie do raportowania: postępu prac aplikacji i wyjątków/errorów w kodzie np:
			- wysyła potwierdzenie przy tworzeniu obiektów 
			- śledzi błedy w errorach w bloku try except
			- wysyła potwierdzenie zrealizowania kodu na każdym etapie tworzenia aplikacji 
		*pozwala nie tylko na wyświetlenie tychże raportów w konsoli ale także (i przede 
		 wszystkim) w osobnym utworzonym pliku, a nawet poprzez wysyłanie e-maili
	*Główne założenia:
		*LOG-MESSAGES:
			*Mają swoje 'levele' którym odpowiadają liczby (powiększane co 10)
			*Służą one do ustalenia typu danego raportu co przydaję się przy późniejszym ich 
			 filtrowaniu podczas wysyłania do pliku lub konsoli. 
			*Filtrowanie działa na zasadzie "większe niż" to znaczy że jeżeli ustalisz log-level
			 na INFO to będzie pokazywać tylko log messages większe lub równe INFO (tj INFO,
			 WARNING, ERROR, CRITICAL). Domyślnie ustalony log-level jest na WARNING.
			*TYPY LOG-MESSAGES - (są to stałe, więc moduł logging trzeba dodać przed nimi):
				**(not-set) - 0 (nieustalony - nie bierzesz pod uwagę)
				**DEBUG		- 10	- do podstawowych operacji czy została zrealizowana czy nie
				**INFO		- 20	- potwierdzenie że wszystko działa jak należy, przy 
									  tworzeniu obiektu albo przy tworzeniu zmiennych
				**WARNING	- 30	- coś niespodziewanego (jakis problem)
				**ERROR		- 40	- poważny problem, nie można wykonywać niektórych funkcji
				**CRITICAL  - 50	- błąd krytyczny, program nie może dalej funkcjonować
		*musisz pobrać moduł logging:
							import logging
		*można utworzyć 2 typy LOGGING'u:
			*DLA PROSTYCH PROGRAMÓW - (składających się z max 1 pliku z rozszerzeniem .py:
				*pobranie moduło logging oraz podstawowa konfiguracja loggingu poprzez metodę 
				 basicConfig() któa zawiera argumenty:
					*level - podajesz level log-messages: level=logging.DEBUG
					*filename - możesz podać nazwę pliku lub ścieżkę bezwzględną, jeśli plik
						nie istnieje to zostanie utworzony. Rozszerzenie pliku to '.log'. 
						Jeśli nie podasz parametru filename to logi będą wyświetlać się Tobie
						w konsoli.
					*format - podajesz format loga na który mogą się składać:
							* %(levelname)s - level/typ log-message
							* %(message)s - zwrócony typ błędu lub treśc raportu
							* %(name)s - nazwa loggera (domyślnie pokazuję root'a)
							* %(asctime)s - data i godzina w formacie: 'yyyy-mm-dd hh:mm:ss,mss'
							*pozostałe parametry: https://docs.python.org/3/library/logging.html#logrecord-attributes
					*datefmt='%Y/%m/%d %H:%M:%S' - format daty
					*filemode - domyślnie działa to w trybie 'append' i nie trzeba podawać tego
						parametru. Jeżli chcesz żeby plik '.log' był tworzony za każdym razem 
						od nowa to przypisz literę 'w': filemode='w';
					  1)	import logging
					  2)	logging.basicConfig(level=logging.DEBUG, 
												format="%(levelname)s %(asctime)s - %(message)s"
												filemode='w', 			
												filename="lumber.log")	
					  3)	logging.info("INFO message")
										#zwróci: INFO 2021-09-07 22:25:00,495 - INFO message
					*reszte znajdziesz w dokumentacji Pythona o loggingu:
						https://docs.python.org/3/library/logging.html
				*możesz też dodatkowo utworzyć loggera (logger=logging.getLogger()) i to nim 
				 się posługiwać zamiast nazwą modułu 'logging'. Wcześniejsza konfiguracja 
				 metody basicConfig() jest taka sama:
							import logging
							LOG_FORMAT="%(levelname)s %(name)s %(asctime)s - %(message)s"
							logging.basicConfig(level=logging.DEBUG, 
												filemode='w', 
												format=LOG_FORMAT, 		#kolejność parametrów
												filename="lumber.log")	# nie ma znaczenia
							logger=logging.getLogger()

							logger.debug("DEBUG message")
							logger.info("INFO message")
							logger.warning("WARNING message")
							logger.error("ERROR message")
							logger.critical("CRITICAL message")
					
			*DLA ROZBUDOWANYCH PROGRAMÓW (importujących wiele klas)
				*praktyka jest taka że przy większych projektach tj większych niz jeden plik z 
				 rozszerzeniem .py nie robi się tak jak powyżej (czyli nie stosuję się 
				 konfiguracji loggingu przy pomocy metody basicConfig(). 
				*Głównie ze względu na to że przy imporcie klasy która też ma logging, import
				 tejże klasy powoduję jej kompilacje (tak - instrukcja import jakisModule 
				 powoduje kompilacje całego jakisModul'u) i ustawienie domyślne loggingu z tejże 
				 pobranej klasy i jej metody basicConfig().
					*ponadto samo zaimportowanie jakiegoś  modułu/plikuZrozszerzeniem .py   może 
					 spowodować że wyświetlone zostaną wszystkie log-messages  z tegoż
					 modułu/plikuZrozszerzeniem .py   
					 Teoretycznie dla takich sytuacji mógłbyś wpisać logger.propagate=False ale
					 to spowoduje że log-messages z tego pobranego modułu/plikuZrozszerzeniem 
					 .py nie zostaną wyświtlone wogóle:
							<  helper.py  >
							import logging
							logger=logging.getLogger(__name__)
							logger.setLevel(logging.DEBUG)
							loger.propagate=False
							logger.info('hello from helper')
							
							<  main.py  >
							import logging
							LOG_FORMAT="%(levelname)s %(name)s %(asctime)s - %(message)s"
							logging.basicConfig(level=logging.DEBUG, format=LOG_FORMAT)
							import helper			# normalnie spowodowałoby że wywietliłoby 
													# 'hello from helper' ale 
													# logget.propagate=False na to nie pozwoli 
					 DLA ROZBUDOWANEGO PROGRAMU NAJLEPSZĄ PRAKTYKĄ jest towrzenie osobnego 
					 loggera dla każdego pliku wraz z HANDLERAMI --->
				*Dobrą praktyką jest tworzenie własnego loggera dla każdego modułu (pliku 
				 z rozszerzeniem .py) który nie jest rootem (choćby po to żeby odróżnić z 
				 którego modułu są dane messages). 
							import logging
							logger=logging.getLogger(__name__)	
											#w metodzie getLogger() specjalnie podajesz 
											#nazwę w postaci atrybutu __name__ żęby odwołać 
											#się do nazwy pliku (z rozszerzeniem .py) i tym
											#samym do nazwy modułu - po to żeby łatwo dało 
											#się później to odróźnić (taka jest dobra praktyka)
				 Następnie konfigurujesz logging poprzez FileHandler'a (dodaje do pliku) lub 
				 StreamHandler'a (dodaje do konsoli) którego póżniej dodajesz do tego loggera:
					*Z UŻYCIEM FileHandler'a: 
							logger.setLevel(logging.DEBUG)				# filtracja podstawowa
							file_h = logging.FileHandler('files.log')	# przypisanie pliku
							FORMATTER='%(levelname)s %(name)s %(message)s'
							file_h.setFormatter(logging.Formatter(FORMATTER))
																		# ustawieniu formatu
							file_h.setLevel(logging.ERROR)				# filtracja dodatkowa
							logger.addHandler(file_h)					# dodanie handlera
							
							logger.error('this is ERROR message')
					*Z UŻYCIEM StreamHandler'a:
							logger.setLevel(logging.DEBUG)				# filtracja podstawowa
							stream_h = logging.StreamHandler()	
							FORMATTER='%(levelname)s %(name)s %(message)s'
							stream_h.setFormatter(logging.Formatter(FORMATTER))
																		# ustawieniu formatu
							stream_h.setLevel(logging.ERROR)				# filtracja dodatkowa
							logger.addHandler(stream_h)					# dodanie handlera
							
							logger.error('this is ERROR message')
					*Z UŻYCIEM RotatingFileHandler'a (który pozwala na podzielenie wyników które
					 idą do plików .log względem albo ilości miejsca w pliku:
							import logging
							logger=logging.getLogger(__name__)
							logger.setLevel(logging.INFO)
							
							handler=logging.RotatingFileHandler('app.log', 
																maxByte=2000,  #ilosc miejsca
																backupCount=5) #ilość kopii po
																			   #ktorej pliki sa
																			   #nadpisywane
							
							logger.addHandler(handler)
							logger.INFO("Info message log")	 # po 2 tysiącach powstanie nowy 
															 # plik gdzie w nazwie na samym 
															 # końcu będzie dodatkowa cyfra
					*Z UŻYCIEM TimeRotatingFileHandler'a (który pozwala na podzielenie wyników 
					 które idą do plików .log względem czasu:
							import logging
							logger=logging.getLogger(__name__)
							logger.setLevel(logging.INFO)
							
							handler=logging.TimeRotatingFileHandler('app.log', 
																	when='m',  #wybrany interwał
																			   #czasowy m=minute
																			   # (s,m,h,d)
																	interval=1,#po ilu minutach
																	backupCount=5)
							
							logger.addHandler(handler)
							logger.INFO("Info message log")	 # po 2 tysiącach powstanie nowy 
															 # plik gdzie w nazwie na samym 
															 # końcu będzie dodatkowa cyfra
			*WYKORZYSTUJĄC OSOBNY PLIK KOFIGURACYJNY
					https://www.youtube.com/watch?v=p0A4CV4MWd0 (od 10:30 - 14:00)
					*plik konfiguracyjny o nazwie logging.conf:
							[loggers]
							keys=root.simpleExample
							[handlers]
							keys=consoleHandler
							[formatters]
							keys=simpleFormatter
							[logger_root]
							level=DEBUG
							handlers=conoleHandler
							[logger_simpleExample]
							level=DEBUG
							handlers=consoleHandler
							qualname=simpleExample
							propagate=0
							[handler_consoleHandler]
							class=StreamHandler
							level=DEBUG
							formatter=simpleFormatter
							args=(sys.stdout,)
							[formatter_simpleFormatter]
							format=%(asctime)s - %(name)s - %(levelname)s - %(message)s1
					*wykorzystanie w naszym pliku .py:
							import logging
							import logging.config
							
							logging.config.fileConfig('logging.conf')
							logger = logging.getLogger('simpleExample')	#nazwa loggera z 
																		#pliku konfiguracyjnego
							logget.debug('this is a debug message')
							
		*DODATKOWE INFORMACJE:
			**w przypadku loger.error('...') o wiele lepiej jest zastosować 
							loger.exception('...') 
				 bo wtedy w przypadku klauzuli try except oprócz tekstu wpisanego w nawiasy
				 do logu dodawany jest TraceBack.
							...							#zdefiniowanie loggingu i loggera
							def divide(x,y):
								try:
									result=x/y
								excpect ZeroDivisionError:
									logger.exception('Tried to divide by zero')
								else:
									return result
							divide(5,0)		#zwróci: ERROR - __main__ - this is ERROR message
													 ERROR - __main__ - Tried to divide by zero
													 Traceback (most recent call last):
													   File "D:\Programy\Thonny\próbne\wstep.py" 
																,line 15, in divide result=x/y
													 ZeroDivisionError: division by zero
			**inną opcją jest:	 logging.error(nameError, exc_info=True)
							import logging 
							def divide(x,y):
								try:
									result=x/y
								except ZeroDivisionError as ZDE:
									logging.error(ZDE, exc_info=True)
								else:
									return result	
							divide(5,0)		
							#zwróci ERROR __main__ 2021-09-14 01:12:22,434 - division by zero
							#	Traceback (most recent call last):
							#	  File "D:\Programy\Thonny\próbne\drugi.py", line 15, in divide
							#		result=x/y
							#	ZeroDivisionError: division by zero
			  lub w przypadku gdy nie znasz nazwy erroru któego chcesz złapać to importujesz
			  moduł traceback i dodajesz w wyjątku logging.error(traceback.format_exc())
							import logging
							import traceback
							def divide(x,y):
								try:
									result=x/y
								except:
									logging.error(traceback.format_exc())
								else:
									return result	
							divide(5,p)		
							#zwróci:	ERROR:root:Traceback (most recent call last):
							#  File "D:\Programy\Thonny\próbne\drugi.py", line 15, in divide
							#	result=x/y
							# TypeError: unsupported operand type(s) for /: 'int' and 'str'
			
			**oprócz modułu logging jest jeszcze opcja modułu Jsonlogging w przypadku gdy 
			  masz mnóstwo modułów gdzie używasz loggingu:
			  https://github.com/madzak/python-json-logger#integrating-with-pythons-logging-framework
			
			
################# LAMBDA | CONTEXT MANAGER | DEKORATORY | ITERTOOLS - PRAWDOPODOBIEŃSTWO ####################
CONTEXT MANAGER:				https://www.youtube.com/watch?v=-aKFBoZpiqA
ITERTOOLS - PRAWDOPODOBIEŃŚTWO	https://docs.python.org/3/library/itertools.html

4*PROGRAMOWANIE FUNKCYJNE: LAMBDA 
	*w innych jezykach programowania takie wyrazenia mozemy utozsamiac z funkcjami anonimowymi
	*sa to zazywyczaj krotkie funkcje mieszczace sie w jednej linijce
	*zaczynamy ja od slowa lambda gdyz jest to funkcja ktora nie ma swojej nazwy
	*po slowie lambda sa wypisane argumenty ktore bedzie przyjmowac lambda
	 nastepnie dwukropek i dzialanie jakie ma sie odbyc na podanych argrumentach
		**taka lambda moze byc funkcja ktora podajesz jako argument w innej funkcji LUB
				def funkcja(f, liczba):
					return f(liczba)
				print(funkcja(lambda x: x**2),4)
		**mozesz wywolac lambde poprzez okalanie jej w okragle nawiasy i w kolejnym nawiasie
		  okraglym podanie wczesniej zadeklarowane argumenty:
				print((lambda x,y: x*y)(3,2))	#musi byc ten pierwszy nawias na lambdzie
		**mozesz tez lambde przypisac jakies zmiennej i wtedy mozesz ja wywolac poprzez zmienna 
		  dokladajac nawiasy 
				lam = lambda x,y : x*y
				print(lam(2,5))
		**wywołanie funkcji zawierającą lambde odbywa się poprzez wpisanie 2 nawiasów po sobie:
				def myfunc(n):
					return lambda a : a * n
				print(myfun(2)(3))									#zwroci Tobie liczbe 6

3* CONTEXT MANAGER:
	1. PODSTAWY - normalnie chąc otworzyć jakiś plik (w celu wczytania go lub zapisania go) musisz pamiętać 
	   o tym by po wszystkim go zamknąć (co jest bardzo ważne).
					f=open('sample.txt','w')
					f.write('cos tam')
					f.close()
	   Jednakże powyższy sposób nie jest rekomendowany - choćby ze względu na to że można zapomnieć o tym
	   by zamknąć tenże plik lub dlatego że gdy pojawi się gdzieś błąd po drodze to nie będzie można 
	   zamknąć tego pliku właściwie. Dlatego powinno korzystać się z context managera:
					with open('sample.txt','w')as f:
						f.write('cos tam')
	2. PRZYDATNOŚĆ - Z context managera możesz korzystać nie tylko przy odczycie i zapisie różnego rodzaju 
	   plików. Przydaję się to przy operacjach takich jak: 
			*otwarcie i zamknięcie połączenia z bązą danych
			*zmiany ścieżek, załatwienia czegoś w danym folderze i cofnięcia sie do poprzedniej ścieżki
			*do pozyskiwania i publikacji logów
	   Wtedy zamiast korzystać z wbudowanej funkcji open() musisz:
			*ALBO stworzyć klasę która będzie dostarczała metody które POPRZEZ SŁOWO KLUCZOWE 'WITH' będą
			 AUTOMATYCZNIE WYWOŁYWANE i automatycznie realizowały odpowiednie funkcje jak inicjalizacje,
			 otwarcie pliku oraz jego zamknięcie:
					class OpenSample:
						def __init__(self, filename, mode):
							self.filename=filename
							self.mode = mode
						def __enter__(self):
							self.file = open(self.filename, self.mode)
							return self.file
						def __exit__(self, exc_type, exc_val, traceback):
							self.file.close()
					with OpenSample('sample.txt', 'w') as f:
						f.write('Testing')					
			*ALBO użyć dekoratora contextmanager który musisz pobrac z modułu contextlib. Tenże dekorator 
			 powinien zostać przypisany do funkcji w której musisz zaimplementować odpowiednie działania.
			 DODATKOWYM KONIECZNYM warunkiem jest użycie generatora (czyli opcji zwracającej yield):
					from contextlib import contextmanager
					@contextmanager
					def open_file(file, mode):
						f=open(file,mode)
						yield f
						f.close()
					with open_file('sample.txt','w') as f:
						f.write('Testing2')
	   WIĘCEJ W FILMIE:
	   https://www.youtube.com/watch?v=-aKFBoZpiqA&list=PL-osiE80TeTt2d9bfVyTiXJA-UTHn6WwU&index=49
	3. PRZYKŁAD PRAKTYCZNY - zlokalizowanie aktualnej ścieżki, zmiana tejże ścieżki, <odpowiednie 
	   działanie w tejże ścieżce--> tutaj: wylistowanie katalogów>, i powrót do ścieżki początkowej:
			A) opcja zwykła - za każdym razem musisz zmieniać ścieżke poprzez powtarzanie kodu
					import os
					cwd = os.getcwd()
					os.chdir("1stAnotherCATALOG")
					os.chdir(cwd)

					import os
					cwd = os.getcwd()
					os.chdir("2ndAnotherCATALOG")
					os.chdir(cwd)
			B) opcja z context managerem - możesz to zapisać poprzez dekorator @contextmanager który da
			   Tobie możliwośc zmiany ścieżek poprzez słowo kluczowe 'with'. Jeżeli chodzi o słowo kluczowe 
			   'yield' to za jego pomocą będziesz mógł wykonać jakieś operacje wewnątrz bloku 'with':
					import os 
					from contextlib import contextmanager
					@contextmanager
					def change_dir(destination):
						try:
							cwd = os.getcwd()
							os.chdir(destination)
							yield 
						finally:
							os.chdir(cwd)
					with change_dir('1stAnotherCATALOG'):
						print(os.listdir())
					with change_dir('2ndAnotherCATALOG'):
						print(os.listdir())
	4*Słówko YIELD 
			*Użycie generatora (słówko 'yield' wewnątrz dekoratora contextmanager ma za zadanie dać 
			 możliwość robienia jakiś operacji wewnątrz bloku 'with'.
			*użycie samego słówka yield oznacza brak możliwość przypisania w bloku with do jakięś 
			 zmiennej (czyli nie ma tam  'as f' w 'with open('file.txt','r') as f:' (Jest tylko:
			 'with open('file.txt','r').
			*użycie słówka yield ze zwracaną jakąś wartością daję możliwośc przypisania do jakieś 
			 zmiennej (czyli  'as f' występuję w 'with open('file.txt','r') as f:'

2*DEKORATORY:
  A) PODSTAWY:
	   1*Dekorator to funkcja ktora wewnątrz siebie ma definicję innej funkcji (funkcji wewnętrznej 
		 zwanej wrapperem) i która zwraca referencje (nie wywołanie!) tejże funkcji wewnętrznej. 
	   2*Dekorator przyjmuje inną funkcje jako argument. Funkcje przyjumuję jako REFERENCJE a nie 
		 jako wywołanie funkcji.
				def decorator(func):
					def wrapper():      							#wewnętrzma funkcja
						print("-np nawiazanie polaczenia z baza danych-")
						func()
						print("-np zakonczenie pracy z baza danych -")
					return wrapper
				def hello():
					print("hello world")
				decorator(hello)()
	   3*Działanie dekoratora polega na tym że wykorzystuje funkcje podaną w argumencie funkcji 
		 zewnętrznej. Najpierw wykonuję jakieś operacje wewewnątrz wrappera i pózniej uruchamia podaną 
		 w argumencie funkcje. Najlepsze w dekoratorach jest to że do tegoż argumentu można podać 
		 różne funkcje i zadziała on dla każdej. Njczęstsze przykłady użycia dekoratorów:
			*PRZY LOGGINGU:	
				def logger(func):
					import logging
					logging.basicConfig(filename='{}.log'.format(func.__name__), level = logging.INFO)
					def wrapper(*args, **kwargs):
						logging.info('Running {} with arguments {}'.format(func.__name__, args))
						return func(*args, **kwargs)
					return wrapper
				def add(x,y):
					return x+y
				def sub(x,y):
					return x+y
				add_logger = logger(add)(3,4)			#zwróci: Running add with arguments 3,4
				add_logger = logger(add)(5,2)			#zwróci: Running sub with arguments 5,2
			*PRZY MIERZENIU CZASU DZIAŁANIA JAKIES FUNKCJI:
				def my_time(origin_func):
					import time
					def wrapper(*args, **kwargs):
						t1=time.time()
						result = origin_func(*args, **kwargs)
						t2 = time.time()
						tSub= t2-t1
						print('{} ran in: {} sec'.format(origin_func.__name__, tSub)
						return result
	   4*ARGUMENTY OPCJONALNE WE WRAPPERZE - chcąc wywołac dekoratora dla jakies funkcji z argumentami 
		 (lub dla wielu różnych funkcji ze zmienną liczbą argumentów) musisz pamiętac żeby we wraperze
		 użyć *args, **kwargs (tj niezaleznie czy podasz argumenty czy nie to funkcja nie wywali bledu). 
		 [argumenty dla funkcji dekorowanej podajesz w drugim nawiasie]
				def decorator2(func):
					def wrapper(*args,**kwargs):
						return func(*args,**kwargs).upper()
					return wrapper
				def foo():
					return 'Marek'
				def foo2(zmienna):
					return zmienna
				print(decorator2(foo)())
				print(decorator2(foo2)('Darel'))
  B) SPOSOBY WYWOLANIA DEKORATORA:
		** 1 sposob wywolywania dekoratora poprzez dodanie nawiasu okraglego na samym koncu, 
			 wywolujacego funkcje wrapper
				decorator(hello)()
		** 2gi sposob wywolywania dekoratora poprzez przypisanie dekoratora do zmiennej i 
		   wywolanie jej jako funkcja
				zmiennoFUNKCJA = decorator(hello)
				zmiennoFUNKCJA()
		** 3ci sposob wywolywania dekoratora poprzez dodanie znacznika o nazwie dekoratora 
		   -> od tego momentu funkcja majaca znacznik dekoratora nad soba, wywolana jak zwykla 
		   funkcja zawsze bedzie wywolywana przez dekorator. Czyli funkcja witaj zostanie przekazana
		   jako argument do funkcji decor. 
				def decor(func):
					def wrapper(arg):
						print('===')
						func(arg)
					return wrapper
				@decor
				def witaj(ar):
					print("czesc",ar)
				
				argument='swiecie'	
				witaj(argument)										#zwroci: ==='\n' czesc swiecie 
		  *jeżeli zdecydujesz się na tę trzecią opcję to wywołanie funkcji witaj(argument) odpowiada
		   decor(witaj)(argument), czyli w wywołaniu witaj(argument) częśc nawiasowa czyli (argument) 
		   część przeznaczona dla wywołania wrappera i przekazania mu argumentu. 
  C) ROZSZERZENIE:	
       0*DLA JEDNEJ FUNKCJI MOŻESZ UŻYĆ KILKU DEKORATORÓW - wtedy ten zmajdujący się najwyżej będzie 
	     wywoływany jako ostatni: 			https://www.youtube.com/watch?v=FsAPt_9Bf3U [od 23min]
				def logger(func):
					import logging
					logging.basicConfig(filename='{}.log'.format(func.__name__), level = logging.INFO)
					def wrapper(*args, **kwargs):
						logging.info('Running {} with arguments {}'.format(func.__name__, args))
						return func(*args, **kwargs)
					return wrapper
				def my_time(origin_func):
					import time
					def wrapper(*args, **kwargs):
						t1=time.time()
						result = origin_func(*args, **kwargs)
						t2 = time.time()
						tSub= t2-t1
						print('{} ran in: {} sec'.format(origin_func.__name__, tSub)
						return result			
				@my_logger					#najpierw zostanie wywołany @my_timer a pózniej @my_logger
				@my_timer
				def display_info(name, age):
					print('DISPLAY_INFO run with arguments: {} {}'.format(name,age))
				display_info('Marek', 24)			Zwróci: DISPLAY_INFO run with arguments: Marek 24
															display_info ran in: 0.0018 sec
															Running wrapper with arguments 
		 Odpowiada to wywołaniu:
				zmienna = my_logger(my_timer(display_info('Marek', 24)))
		 Dlatego żeby NIE BYŁO  RZADNEJ KOLEJNOŚCI w wyoływaniu dekoratorów tylko wszystkie uruchomiły 
		 się w tym samym czasie używaj w każdym wrapperze w kazdym dekoratorze dekoratora wraps z modułu 
		 functools i podaj w nim swoją orginlną funkcję:
				from functools import wraps										
				def logger(func):
					import logging
					logging.basicConfig(filename='{}.log'.format(func.__name__), level = logging.INFO)
					
					@wraps(func)
					def wrapper(*args, **kwargs):
						logging.info('Running {} with arguments {}'.format(func.__name__, args))
						return func(*args, **kwargs)
					return wrapper
				def my_time(origin_func):
					import time
					
					@wraps(origin_func)
					def wrapper(*args, **kwargs):
						t1=time.time()
						result = origin_func(*args, **kwargs)
						t2 = time.time()
						tSub= t2-t1
						print('{} ran in: {} sec'.format(origin_func.__name__, tSub)
						return result			
				@my_logger					#najpierw zostanie wywołany @my_timer a pózniej @my_logger
				@my_timer
				def display_info(name, age):
					print('DISPLAY_INFO run with arguments: {} {}'.format(name,age))
				display_info('Marek', 24)			Zwróci: DISPLAY_INFO run with arguments: Marek 24
															display_info ran in: 0.0018 sec
															Running display_info with arguments 
	   1*ZMIENNA JAKO ARGUMENT ZAMIAST FUNKCJI - Dekorator może przyjąc nie tylko funkcje jako argument 
		 ale także zmienną:							https://www.youtube.com/watch?v=KlBPCzcQNU8
			  *przyklad 1:
				def dec1(zmienna):
					def wrapper():
						print(zmienna)
				def dec2(zmienna):
					def wrapper(tag):
						print(f'<{tag}>{zmienna}</{tag}>')
				dec1("moj message")()							#zwróci moj message
				dec2("moj message")("h1")						#zwróci <h1>moj message</h1>		
			  *przyklad 2:
	   2*PRZY ZWROCIE WRAPPERA (a konkretnie jego referencji), wartości ze zmiennych które powstaną 
		 w funkcji zewnętrznej ZOSTANĄ ZAPAMIĘTANE PRZEZ funkcję wewnętrzną. 
				def decorator(msg)
					message = msg
					def wrapper():
						print(message)
					return wrapper
				dec_1 = decorator('HI')			#mimo tego że zwróciłem tylko referencje do wrappera  
				dec_1()	  	   #zwróci 'HI' 	#który teoretycznie nie powininen przetrzymywac 
												#wartości zmiennej message to jednak to robi.
	   3*DEKORATOR JAKO KLASA - oprócz klasycznego użycia dekoratora może go także utworzyć poprzez 
		 klasę. Wtedy podczas wywołania funkcji (z przypisanym dekoratorem) masz automatyczne 
		 wywołanie funkcji call():
				class decorator_class(object):
					def __init__(slef, original_func):
						self.original_func = original_func
					def __call__(self, *args, **kwargs):
						print("to co normalnie byłoby we wrapperze")
						return self.original_func(*args, **kwargs)
				@decorator_class
					def display(name):
						print(name)
				display('Marek')  			  #zwróci: to co normalnie byłoby we wrapperze /n Marek
	   4*OPCJA UŻYCIA GENERATORA - wewnatrz dekoratora tj wewnątrz wrappera zamiast słowa return 
		 można uzyc generatora (słowo 'yield') wywołując funkcje podaną do argumentu dekoratora   
		 (tutaj jest to f). Robi sie to w sytuacjach gdy zamiast konieczności pojedyńczego zwrotu 
		 wywołania funkcji z argumentu dekoratora) musisz (np w petli for) zwracać wiele wywołań 
		 funkcji (z argumentu dekoratora).
				from operator import itemgetter
				def person_lister(f):
					def wrapper(people):
						for p in sorted(people, key=itemgetter(2)):
							yield f(p) 
					return wrapper
				@person_lister
				def name_format(person):
					return ("Mr. " if person[3] == "M" else "Ms. ") + person[0] + " " + person[1]

0* MODULE ITERTOOLS - KOMBINATORYKA - MODUŁ DO LICZENIA PRAWDOPODOBIEŃSTWA  
	https://docs.python.org/3/library/itertools.html
	*funkcje tworzące iteratory do lepszego chodzenia po pętli
	*są Iteratorami i ma jego cechy tj.: jest strumieniem więc można tylko raz po nim przejść, gdyz
	 jest WYCZERPOWALNY (exhausted). 	

	KOMBINATORYKA:
	kalkulator prawdopodobieństwa - https://www.naukowiec.org/kalkulatory/kombinatoryka.html
	algorytm wybierania sposobu oblicznia pradopodobieńśtwa - https://www.math.edu.pl/kombinatoryka
	-------------------------------------------------------------------------------------------------------  
						    KOLEJNOŚĆ -> POWTÓRZENIA -> CZY WSZYSTKIE ELEMENTY
					
						-------------------CZY LICZY SIĘ KOLEJNOŚĆ------------------
						|NIE													|TAK
						V														V
			CZY WYSTĘPUJĄ POWTÓRZENIA 								    CZY WYSTĘPUJĄ POWTÓRZENIA
			|						|									|						|
			|NIE					|TAK								|NIE					|TAK
			V 						V									V 						V
  KOMBINACJE BEZ POWTÓRZEŃ   KOMBINACJE Z POWTÓRZENIAMI		CZY WSZYSTKIE ELEMENTY	WARIACJE Z POWTÓRZENIAMI
	   n!/(k!*(n-k)!)			(n+k-1)/(k!*(n-1)!)			|					 |             n**k
        itertools 					 itertools				|					 |
      combinations() 	  combinations_with_replacement()   |					 |
															|NIE				 |TAK
															V 					 V 
												WARIACJE BEZ POWTÓRZEŃ	     PERMUTACJE
													   n!/(n-k)!				 n!
									   itertools.permutations(A,k-elem.)    itertools.permutations(A)
		
	***NAJWAŻNIEJSZE TO: sprawdzić czy liczy się kolejność w pojedyńczej krotce która reprezentuję 
	   wariant danego pojedyńczego ustawienia --> patrz czy pary (1,2) i (2,1) rónią się od siebie
       (tak jest w permutacjach, wariacjach bez powtórzeń i wariacjach z powtórzeniami) czy nie różnią
       się od siebie (tak jak jest w kombinacjach bez powtórzeń i w kombinacjach z powtórzeniami)
	-------------------------------------------------------------------------------------------------------  
	  
	0. MACIERZE:
	    **Ponieważ w macierzach jest więcej niż jeden zbiór to nie zalicza się tego do kombinatoryki
		A) JEDNOZBIOROWE - A*A - liczy się kolejnośc w jednej krotce GDYŻ pary (1,2) i (2,1) różnią się  
				 - itertools.product 		(patrz w Funkcjach itertools poniżej):
							list(product([1,2,3],repeat = 2))
				 - W tym przypadku nie ma tak na prawdę jednego zbioru tylko są dwa takie same
				   czyli: A*A -> ten specyficzny przypadek można podpiąć pod 2elementowe 
				   wariacje z powtórzeniami -> n**2 Gdyby wymnożyć zbiór A 3 razy przez siebie 
				   czyli A*A*A to miałbyś 3elementowe wariacje z powtórzeniami -> n**3
		B) WIELOZBIOROWE - A*B - są to 2 wymnożone przez siebie zbiory
				 - itertools.product 		(patrz w Funkcjach itertools poniżej):
							list(product([1,2,3],[2,4])
							
	1. PERMUTACJE [liczy sie kolejność; jest bez powtórzeń; wszystkie elementy są brane pod uwagę]:
				 - itertools.permutations(A) 		(patrz w Funkcjach itertools poniżej):
							list(permutations(['1','2','3','4','5'])
				 -    [5*4*3*2*1]     czyli wykorzystujesz wzór n!
					   = = = = =
				 - najlepszym przykładem są rózne warianty wyników wyśigów konnych
				
	2. WARIACJE BEZ POWTÓRZEŃ [liczy sie kolejność; bez powtórzeń; tylko k elementóW z n ]:
				 - itertools.permutations(A) 		(patrz w Funkcjach itertools poniżej):
							list(permutations(['1','2','3','4','5'],2)	
				 -    [5*4*3] 2 1     czyli wykorzystujesz wzór n!/(n-k)!
					   = = =  = =
				 - najlepszym przykładem są warianty wyników wyśigów konnych 3 pierwszych koni z 5
								
	3. WARIACJE Z POWTÓRZENIAMI [liczy sie kolejność; Z powtórzeniami; tylko k elementów z n]:
				 - itertools.product(A,repeat)		(patrz w Funkcjach itertools poniżej):
							list(permutations(['1','2','3','4','5'],2)	
				 -    [5*5*5] 5 5    czyli wykorzystujesz macierze wzór n**k
					   = = =  = =
				 - najlepszym przykładem są macierze - np 2 elementowa macierz jednozbiorowa 
				 
	4. KOMBINACJE BEZ POWTÓRZEŃ [NIE liczy sie kolejność; bez powtórzeń; tylko k elementóW z n ]:
				 - itertools.combinations(A,repeat)		(patrz w Funkcjach itertools poniżej):
							list(combinations(['1','2','3','4','5'],2)	
				 -     4+3+2+1+0    czyli wykorzystujesz macierze wzór n!/(k!*(n-k)!)
					   = = = = =   (każde z pól może się połączyć w 2elementową krotkę z tyloma elementami)
				 - najlepszym przykładem jest totolotek czyli warianty 6 liczb z 49 gdzie nie liczy 
				   się kolejność ułożenia

	5. KOMBINACJE Z POWTÓRZENIAMI [NIE liczy sie kolejność; Z powtórzeniami; tylko k elementóW z n ]:
				 - itertools.combinations_with_replacement(A,repeat) (patrz w Funkcjach itertools):
							list(combinations_with_replacement(['1','2','3','4','5'],2)	
				 -     5+4+3+2+1    czyli wykorzystujesz macierze wzór (n+k-1)/(k!*(n-1)!)
					   = = = = =   
				 - najlepszym przykładem jest - losujesz 2 cyfry z 4 - po pojedyńczym losowaniu 
				   wrzucasz kule z powrotem

  1.FUNKCJE:
	*itertools.product:
		*działa tak jak zagnieżdzone pętle - zwraca listę krotek PAR każdego elementu z jednej listy 
		 z każdym elementem innej listy czyli MACIERZ LIST (elementy mogą się powtarzać
		*PRZYKŁAD TEORETYCZNY -  product(A, B) zwraca to samo co [(x,y) for x in A for y in B]
					A = [1 ,2]
					B = [2, 4, 5]
					AxB = [(1, 2), (1, 4), (1, 5), (2, 2), (2, 4), (2, 5)]
		*zwraca obiekt itertools dlatego przekonwertowuję się go na listę 
		*są różne opcje podania argumentów do tejże funkcji 
			*jedna lista z parametrem repeat który zwielokratnia ilosć tychże list:
				list(product([1,2],repeat = 2) #zwroci: [(1, 1), (1, 2), (2, 1), (2, 2)]
			*kilka list
				list(product([1,2,3],[3,4])) #zwroci: [(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]
			*klilka list zawartych w jednej liscie:
				B = [[1,2,3],[3,4,5],[7,8]]
				list(product(*B))
					#zwroci: [(1, 3, 7), (1, 3, 8), (1, 4, 7), (1, 4, 8), (1, 5, 7), (1, 5, 8), 
							  (2, 3, 7), (2, 3, 8), (2, 4, 7), (2, 4, 8), (2, 5, 7), (2, 5, 8), 
							  (3, 3, 7), (3, 3, 8), (3, 4, 7), (3, 4, 8), (3, 5, 7), (3, 5, 8)]
	*itertools.permutations:
		*musisz pobrać wcześniej moduł: 
				from itertools import permutations
		*możesz użyć do permutacji
				print list(permutations(['1','2','3']))
										#zwróci:[('1', '2', '3'), ('1', '3', '2'), ('2', '1', '3'), 
												 ('2', '3', '1'), ('3', '1', '2'), ('3', '2', '1')]
		*możesz użyć też do wariacji bez powtórzeń podając 2gi parametr ktory symbolizuję 
		 k elementów z n elementowego zbioru/listy:
				print list(permutations('abc',3))
										#zwróci:[('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), 
												 ('b', 'c', 'a'), ('c', 'a', 'b'), ('c', 'b', 'a')]
		*jeżeli podany zbiór był uporządkowany (w postaci uporządkowanej listy) to permutacje są 
		 zwracane w uporządkowanej kolejności
		 
	*itertools.combinations:
		*musisz pobrać wcześniej moduł: 
				from itertools import combinations
		*możesz użyć do kombinacji bez powtorzen:
				print list(combinations('12345',2))
					#zwroci: [('1', '2'), ('1', '3'), ('1', '4'), ('1', '5'), ('2', '3'), ('2', '4'),
					('2', '5'), ('3', '4'), ('3', '5'), ('4', '5')]
		*(poniżej przypadek gdzie zbiór ma dublujące się elementy - wbrew pozorom nadal jest bez 
		 powtorzen bo każda powtarzająca się liczba jest traktowana jako osobny obiekt
				print list(combinations([1,1,3,3,3],4))
					#zwroci: [(1, 1, 3, 3), (1, 1, 3, 3), (1, 1, 3, 3), (1, 3, 3, 3), (1, 3, 3, 3)]
	
	*itertools.combinations_with_replacement:
		*musisz pobrać wcześniej moduł: 
				from itertools import combinations_with_replacement
		*możesz użyć do kombinacji bez powtorzen:
				print list(combinations_with_replacement('12345',2))
					#zwroci: [('1', '1'), ('1', '2'), ('1', '3'), ('1', '4'), ('1', '5'), ('2', '2'), 
							  ('2', '3'), ('2', '4'), ('2', '5'), ('3', '3'), ('3', '4'), ('3', '5'), 
							  ('4', '4'), ('4', '5'), ('5', '5')]
		*(poniżej przypadek gdzie zbiór ma dublujące się elementy - wbrew pozorom nadal jest bez 
		 powtorzen bo każda powtarzająca się liczba jest traktowana jako osobny obiekt
				print list(combinations([1,1,3,3,3],2))
					#zwroci: [(1, 1), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (1, 3), (3, 3), (3, 3), (3, 3)]



  MODULE ITERTOOLS - funkcje tworzące iteratory do lepszego chodzenia po pętli:
  https://docs.python.org/2/library/itertools.html
  https://www.geeksforgeeks.org/itertools-groupby-in-python/
  https://docs.python.org/2/library/itertools.html#itertools.groupby

  2. Inne funkcje itertools:
	*groupby(collection, key_func) - GRUPUJĘ WZGLĘDEM ZADANEJ WARTOŚCI AŻ DO NASTEPNEGO KLUCZA
		https://docs.python.org/2/library/itertools.html#itertools.groupby
		https://www.geeksforgeeks.org/itertools-groupby-in-python/
		*W przypadku listy krotek lub slownika zwraca pojedyńczy klucz i grupę wszystkich par (klucza 
		 i wartośći) wystąpień tego danego klucza.
			lst = [("a", 1), ("a", 2), ("b", 3), ("b", 4), ("a", 1)]
			for key, group in itertools.groupby(lst, lambda x:x[0]):
				print(key, list(group)) 
															#zwroci:		a [('a', 1), ('a', 2)]		
																			b [('b', 3), ('b', 4)]
																			a [('a', 1)]
		 jeżeli podasz w lambdzie wskazanie nie na klucz ale na wartość (która ma zostać potraktowana 
		 jako klucz) to wyświtetli się Tobie wartości jako klucze wraz ze wszystkimi występowaniami
		 w krotce:
			import itertools
			lst = [("a", 1), ("a", 2), ("b", 2), ("b", 4),('a', 1)]
			for key, group in itertools.groupby(lst, lambda x:x[1]):
				print(key, list(group)) 					#zwróci:		1 [('a', 1)]
																			2 [('a', 2), ('b', 2)]
																			4 [('b', 4)]
																			1 [('a', 1)]
		 jeśli w liscie zamiast krotki par podasz zwykłą listę argumentów, a w funkji funkcje zwracającą
		 wartość prawde lub falsz to group by pogrupuję Tobie listę na elementy odnoszące się do wartości
		 prawdziwej i elementy odnoszące się do wartości fałszywej:
			from itertools import groupby
			a=[1,2,3,4,1]
			for k,v in groupby(a, key=(lambda x:x<3)):
				print(k,list(v))							#zwroci:		True [1, 2]
																			False [3, 4]
																			True [1]
		 w przypadku słownika w lambdzie trzeba pamiętać aby podać klucz do słownika:
			import itertools
			lst= [{'name':'Tim', 'age': 25},{'name':'Tom', 'age': 25},
				  {'name':'Tim', 'age': 27},{'name':'Tum', 'age': 25}]
			for key, group in itertools.groupby(lst, lambda x:x['age']):
				print(key, list(group))		
									#zwróci: 25 [{'name': 'Tim', 'age': 25}, {'name': 'Tom', 'age': 25}]
											 27 [{'name': 'Tim', 'age': 27}]
											 25 [{'name': 'Tum', 'age': 25}]
		*w przypadku stringa albo zwyklej listy kazdą wartosc wezmie za pojedyńczy klucz tak długo jak
		 POD RZĄD będzie się ona powtarzać. Z kolei te powtorzenia POD RZĄD zostaną zgrupowane i 
		 przzedstawione jako wartość:
			[k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B
			[list(g) for k, g in groupby('AAAABBBCCDAABBB')] --> AAAA BBB CC D AA BBB
		

###### LEKCJA 20-22 ITERATORY: GENERATOR | MAPA | FILTER | FUNKCJE REDUCE() i ACCUMULATE() ########
https://www.w3schools.com/python/python_iterators.asp
https://www.programiz.com/python-programming/methods/built-in/iter
https://www.tutorialsteacher.com/python/iter-method
https://www.geeksforgeeks.org/reduce-in-python/
https://www.geeksforgeeks.org/python-itertools-accumulate/

0*ITERATORY
https://www.w3schools.com/python/python_iterators.asp
	*Iterator to obiekt reprezentujący strumień danych po ktorym mozna przejsc przez 
	 wszystkie jego wartosci ktore zawiera. Obiekt na którym chcę się stworzyć obiekt klasy
 	 Iterator musi być iterowalny. Przykłądem są wszystkie kolekcje które są iterowalnymi 
	 pojemnikami na dane.
	*Iteratory są WYCZERPOWALNE (exhausted) co oznacza że gdy przejdziemy po nich raz to nie
	 można przejśc po nich powtórnie. Trzeba wtedy na nowo go zaladować i dopiero po nim przejść.
	*Żeby przejść na nowo przez niego to trzeba go załadować na nowo chyba że skastujesz go na 
	 listę zaraz przy utworzeniu. Jeżeli skastujesz go na listę, wyprintujesz ją i na nowo 
	 będziesz chciał się do niego odwołać to nie uda ci się bo podczas kastowania dochodzi
	 do przejścia przez cały Iterator. 
	*Iterowalnym może się stać jakikolwiek obiekt, gdyż do stworzenia obiektu klasy Iterator
	 pottrzebna jest implementacja 2 metod: __iter()__ 	oraz (  __next()__ albo __getitem()__  )
				class PrintNumber:
				def __init__(self, max):
					self.max = max
				def __iter__(self):
					self.num = 0
					return self
				def __next__(self):
					if(self.num >= self.max):
						raise StopIteration
					self.num += 1
					return self.num
				print_num = PrintNumber(3)
				print_num_iter = iter(print_num)
				print(next(print_num_iter))  
				print(next(print_num_iter))  
				print(next(print_num_iter))  									#zwróci: 1,2,3
				
	*METODY KLASY ITERATORA:
		*__iter()__ ,która zwróci nam obiekt klasy Iterator dla podanego w jej argumencie obiektu		
		 (np jakieś kolekcji) po którym będzie można iterować/przejść po jednym elemencie na raz.
		 Metoda iter() , musi zwracać samą siebie (słówko self).Ponadto przyjmuję 2 argumenty 
					iter(object, sentinel):
			**obiekt na bazie którego ma powstać obiekt klasy Iterator
			**sentinel - (jest to ARGUMENT OPCJONALNY) i jest to specjalna wartość ktora ma 
			  reprezentować zakończenie sekwencji. Jeżeli sentinel jest zaimplementowany to 
			  metoda __iter()__ zwroci nam obiekt klasy Iterator ktorego elementy będą kończyć 
			  się na wartości sentinela
		* __next()__ która jest wywoływana na obiekcie Iteratora zwraca kolejny element ze 
		 strumienia danych iteratora. Przy definiowaniu trzeba zadbać by zwracała nastęny element
	*Wykorzystanie sentinela przy 
				class DoubleIt:
					def __init__(self):
						self.start = 1
					def __iter__(self):
						return self
					def __next__(self):
						self.start *= 2
						return self.start
				my_iter = iter(DoubleIt(), 16)
				for x in my_iter:
					print(x)							#zwróci: 2,4,8 (i na 16 się zatrzymalo)
	
	*Jednakże w pętli for która robi się dla kolekcji albo dla stringa albo dla funkcji range()
 	 metoda __iter()__ jest wywoływana automatycznie wraz z metodą __next__() dlatego nie trzeba
	 ich przeciążać (chociaż można). Jednakże to działa tylko dla pętli for bo inaczej trzeba 
	 wywoływać metode iter. W przypadku kolekcji tez trzeba przeobrazić kolekcje w Iterator 
	 poprzez metode __iter()__ Przykład dla listy:
				# list of vowels
				vowels = ['a', 'e', 'i', 'o', 'u']
				vowels_iter = iter(vowels)
				print(next(vowels_iter))    # 'a'
				print(next(vowels_iter))    # 'e'
				print(next(vowels_iter))    # 'i'
				print(next(vowels_iter))    # 'o'
				print(next(vowels_iter))    # 'u'
	*ERROR StopIteration - poprzez podniesienie tego wyjątku za pomoca raise jesteśmy w stanie 
     zatrzymać pobieranie kolejnych elementów za pomocą metody __next()__ 	
				class MyNumbers:
				  def __iter__(self):
					self.a = 1
					return self
				  def __next__(self):
					if self.a <= 20:
					  x = self.a
					  self.a += 1
					  return x
					else:
					  raise StopIteration
				myclass = MyNumbers()
				myiter = iter(myclass)
				for x in myiter:
				  print(x)	 				#po 20 petlach się zatrzyma nie przerywając programu
											 ale zrobi tak tylko dlatego że przechodzimy po iteratorze
											 a nie po np funkcji range() albo liście
	
	
1*GENERATORY (YIELD) - remedium do ogromnych list liczb i bledu OUT OF MEMORY ERROR, 
					 - POLEGA NA zdefiniowaniu specjalnej funkcji używającej SPECJALNEGO SŁOWA 
					   KLUCZOWEGO YIELD zamiast RETURN i następnie wykorzystania jej jako 
					   ITERATORA do funkcji for
https://www.youtube.com/watch?v=VMJK9JhNxEM
	*normalnie gdybysmy chcieli przejsc po liscie ktora bedzie miala ogromne rozmiary moze 
	 pojawic sie blad: out of memory error -> wtedy zamiast listy jako iteratora lepiej posluzyc
	 sie generatorem
				x =[]
				for i in range(999999999999999):
					x.append(i**2)
					print(x[i])							[w tym przypadku zapcha ci sie pamiec]
	*dlatego lepiej posluzyc sie generatorem ktory wykorzysta sie jako iterator do funkcji 
	 for ORAZ ktory bedzie zwracal wartosci "NA BIEZĄCO" i pauzowal swoje dzialanie do kolejnego 
	 momentu gdy go poprosimy o jego kolejna wartosc:
			Przyklad 1:
				x=[]
				def gen2(n):
					for i in range(n):
						yield i**2
				for a in gen2(99999999999999999999):
					print(a)
					x.append(a)
			Przyklad 2:
				x=[]
				def gen(lst):
					for x in lst:
						yield x*x
				for a in gen([1,2,3,4,5]):
					print(a)
					x.append(a)
	*możesz stworzyć generator comprehension expresion POPRZEZ NAWIASY OKRĄGŁE - tak samo jak w 
	 listach tyle że nawiasy okrągłe:
			Przyklad 1:
				nums = 10
				my_gen = (n*n for i in range(nums))
			Przyklad 2:
				lst= list(range(10))
				my_gen = (n*n for n in lst)
	*mozemy tez wywolac generatora i za pomoca metody next(arg) ktora przyjmuje obiekt generatora
	 jako argument wyswietlic kolejne wartosci z funkcji/generatora
				g = gen2(999999999999)
				print(next(g))
				print(next(g))
				print(next(g))
	*mozesz tez uzyc wielu yieldow ale jezeli zrobisz wiecej wywolan funkcji next(g) od yieldow
	 to dostaniesz blad: StopIteration
				def gen3(n):
					yield 10
					yield 23
					yield 99
				g=gen3(1)
				print(next(g))
				print(next(g))
				print(next(g))
				print(next(g)) 								#stopIteration Error
	*przydaje sie to przy naprawde duzych plikach: - przyklad praktyczny
				def reader(file):
					for row in open(file,"r"):
						yield row
				r = reader("test19.txt")
				for i in r:
					print(i)
				
2*PROGRAMOWANIE FUNKCYJNE: FUNKCJA MAPA czyli mapowanie listy podana funkcja:
	*jest Iteratorem i ma jego cechy tj.: jest strumieniem więc można tylko raz po nim przejść, gdyz
	 jest WYCZERPOWALNY (exhausted). 
	*funkcja map() dostaje 2 argumenty - pierwszy to funkcja ktora przeiteruje po calej liscie 
	 elementow ktore zostana podane jako lista w drugim argumencie i przerobi je wedlug zadanej
	 gunkcji podanej w pierwszym argumencie
				lista = list(range(1,6))
				mapa = map(lambda x : x**2,lista)						[zwroci: [1,4,9,16,25]]
	*map() to specjalna funkcja ktora zwraca typ danych o nazwie mapa (dlatego gdy chcesz sie
	 odwolac do wyniku ktory zostal zwrocony musisz przekonwertowac to na typ danych typu lista)
				print(list(mapa))
	*mimo wszystko na obiekcie mapy może przeiterować elementy (nie trzeba wtedy kowertować na liste)
	*chociaż map() zwraca obiekt mapy (ktory jest zbiorem(ale nie setem) obiektow) to nie trzeba go zawsze 
	 konwertować na listę gdyż jeżeli do przypisania podamy mu tyle zmiennych ile dostaję w argumencie to 
	 przypisze nam je do siebie:
				K,M = map(int,('34 45'.split()))
				K,M = map(len,('mama length'.split())) #zwroci dlugosc slow: 'mama' i 'length'
	*w mapie możemy nie tylko mapować na jakiś konkretny typ danych ale także na jakaś funkcję podaną
	 również jako lambde:
				results = map(lambda x: sum(i**2 for i in x)%M,product(*N))
				print(max(results))
	*funkcja może być też wcześniej zadeklarowana - wtedy podajesz ją jak zmienną:
				import math
				def area(r):
					return math.pi *(r**2)
				lst=[2,5,7.1,0.3,10]
				print(list(map(area, lst)))
 
3*PROGRAMOWANIE FUNKCYJNE: FUNKCJA=FILTER czyli filtrowanie listy przez podana funkcje:
	*jest Iteratorem i ma jego cechy tj.: jest strumieniem więc można tylko raz po nim przejść, gdyz
	 jest WYCZERPOWALNY (exhausted). 
	*funkcja filter() dostaje 2 argumenty - pierwszy to funkcja ktora przeiteruje po calej liscie 
	 elementow ktore zostana podane jako lista w drugim argumencie i zwroci tylko te elementty 
	 ktore beda True dla wczesniej podanej funkcji (podanej w pierwszym argumencie ktora wynikiem
	 musi byc wartosc typu boolean (True albo False))
				lista = list(range(1,6))
				filter = filter(lambda x: x%2==0,lista)							#zwroci: [2,4]
	*filter() to specjalna funkcja ktora zwwraca typ danych o nzw: filter (dlatego gdy chcesz sie 
	 odwolac do wyniku ktory zostal zwrocony musisz przekonwertowac to na typ danych typu lista)
				print(list(filter))
	*filter() może odfiltrować dane żeby otrzymać tylko te które należą do danego typu np int:
				lst=[1,"",0,"argentina"]
				print(list(filter(lambda x: type(x)==int, lst)))				#zwróci: [1,0]
	*filter() może odfiltrować dane tak żeby nie były False w stosunku do typu boolean czzyli 
		pozbywa się zer, pustych stringów, pustych list, pustych krotek, pustych słowników, 
		wartości False, wartości None, instancji które są puste:
				lst=[1,"",0,"argentina", False, None, [],{},()]
				print(list(filter(None, lst)))							#zwróci: [1,'argentina']

4* FUNKCJE REDUCE() i ACCUMULATE:
	https://www.geeksforgeeks.org/reduce-in-python/
	https://www.geeksforgeeks.org/python-itertools-accumulate/
	FUNKCJA reduce() (module functools) i accumulate() (module itertools):
	*są Iteratorami i mają jego cechy tj.: są strumieniami więc można tylko raz po nim przejść, gdyz
	 są WYCZERPOWALNE (exhausted). 
	*do reduce() trzeba pobrać moduł functools:
		from functools import reduce()
	*do accumulate() trzeba pobrać moduł itertools
		from itertools import accumulate
	*funkcje ktore przechodza przez całą liste wykonując operacje wskazanej jako funkcja (lambda zazwyczaj)
	 w argumencie na 2 elementach - pierwszy to wynik operacji poprzednich elementow a drugi to nastepny
	 element (najpierw na 2 pierwszych elementach pozniej na wyniku 2pierwszych i 3cim elemencie, nastepnie 
	 na wyniku poprzednich 3 elementow i 4tego elementu)
	*te 2 funkcje robią to samo ale zwracają co innego:
		*reduce zwraca wynik końcowy wszystkich operacji 
			functools.reduce(lambda a, b: a+b, [1,2,3,4,5,6])				#zwroci: 21
		*accumulate zwraca liste wyniku operacji na kazdym elemencie
			itertools.accumulate([1,2,3,4,5,6], lambda x, y: x+y)			#zwroci: [1,3,6,10,15,21]
	*konstrukcja
		**reduce():
			reduce(funkcja, kolekcja)
		***mozna tez dodac 3 argument ktory bedzie dodatkowym elementem od ktorego bedzie się zaczynać
		   te operacje 
			reduce(funkcja, kolekcja, integerElement)
		**konstrukcja accumulate():
			accumulate(kolekcja, funkcja)
	*operators zamiast funkcji - zamiast funkcji możesz pużyć modułu operator (patrz: operatory w SETcie) 
	 i wykorzystać operacje jako argument gdzie powinna znajdować się funkcja :
	 https://www.geeksforgeeks.org/operator-functions-in-python-set-1/
			import operator
			functools.reduce(operator.add, [1,2,3,4,5,6])				#zwroci: 21) 
	 dla funkcji accumulate z modułu itertools:
			from itertools import accumulate
			import operator
			a=[1,2,3,4]
			acum=accumulate(a,func=operator.mul)
			print(list(acum))
		
################################## DESTRUKTOR | HERMETYZACJA | Gettery i Settery ############################

1* CYKL ŻYCIA OBIEKTU I DESTRUKTOR
	*destrukktor dziala w momencie konca zycia obiektu i wykonuje sie zawsze pod koniec 
	 dzialania programu (gdy obiekt nie jest juz nam potrzebny)
			class Test:
				def __del__(self):			#destruktor
					print("Bye Class")
			
	*Obiekt konczy swoje istnienie kiedy nie posiada referencji przypisanej do zadnej zmiennej. 
	 Mozemy wiec wymusic wywolanie destruktora poprzez usunięcie zmiennej do ktorej jest 
	 przypisana referencja za pomoca slowa kluczowego del np.: del obj
				obj = Test()
				del obj

2* HERMETYZACJA
    *pola prywatne uzyskuje sie poprzez dodanie do nawy zmiennej pojedynczego podkreslnika
 	 wtedy zmienną nazwywa sie ukrytą
	*mimo wszystko nadal mozna sie dostac do tej zmiennej poza klasa

    *w Pythonie ten podkreslnik jest tylko informacja dla programistow ze to powinna byc 
	 zmienna prywatna.
    *mozna tez dodac dwa podkresliniki przed argumentem i wtedy zeby dostac sie do takiego
	 argumentu bedac poza klasa to trzeba przed nazwą argumentu(z dwoma podkreslnikami) 
	 wpisac nazwe klasy z podkreslnikiem (z jakiej pochodzi)(obj._Hermetyzacja__lista)
			class Hermetyzacja:
				_lista = []
				__lista = []
				def dodaj(self,arg):
					self._lista.append(arg)
					self.__lista.append(arg)
				def zdejmij(self):
					if len(self.__lista)>0:
						self.__lista.pop(len(self.__lista)-1)
					if len(self.__lista) > 0:
						self._lista.pop(len(self._lista)-1)
				def __str__(self):
					return "Lista1: "+str(self._lista)+ \
						   "\nLista2: "+str(self.__lista)
			obj =Hermetyzacja()
			obj.dodaj("A")
			obj.dodaj("B")
			obj.dodaj("C")
			obj.zdejmij()
			print(str(obj))
			print(obj._lista)
			print(obj._Hermetyzacja__lista)	
								#tak, dobrze jest to zapisane ==> obj._Hermetyzacja__listy
								
3*Gettery i Settery	i Deletery
	https://www.youtube.com/watch?v=jCzT9XFZ5bw
	*Róźnice w stosunku do JAVY:
		*Gettery i Settery w Pythonie zdecydowanie się różnią od tych w Javie. W javie gettery i
		 settery mają za zadanie zwrocenie lub ustawienie pojedyńczych prywatnych pól. W pythonie
		 przez to że możesz dostać się do pól obiektu w każdej chwili poprzez wywołanie ich po 
		 nazwie to taki getter lub setter nie ma sensu.
	*GETTERy w Pythonie DOTYCZĄ PÓL SKŁADAJĄCYCH SIĘ Z INNYCH PÓL,
		*tworzy się je poprzez dekorator @property i można je wywołać tak samo jak się wywołuję zmienne\
 		 (nie wywołuję się jak funkcji przez nawiasy tylko jak zmienną! - co jest ogromną zaletą)
			##zamiast tworzyć pole email w konstruktorze (metoda __init__())
				class Employee:
					def __init__(self, first, last)
						self.first=first
						self.last=last
						self.email = f'{seld.first}.{self.last}@email.com'
			##możesz zrobić to poprzez dekorator @property:
				class Employee:
					def __init__(self, first, last)
						self.first=first
						self.last=last
					@property
					def email(self)
						return f'{seld.first}.{self.last}@email.com'
			##od teg omomentu poprzez wywołanie tak jak się wywołuję zmienne dostaniesz pole email
				emp_1= Employee('Marek', 'Kucharek') 
				print(emp_1.email)						#zwróci: Marek.Kucharek@email.com
			#podejście z dekoratorem @property jest lepsze gdyż jeżeli przypisałbyś do pola first 
			 jakąś inną wartość to w pierwszym przypadku pole email się nie zaaktualizuję a w drugim 
			 przypadku przy chęci odwołania się do pola email  
	*SETTERy w Pythonie DOTYCZĄ PÓL SKŁADAJĄCYCH SIĘ Z INNYCH PÓL, 
		*do pól pojedyńczych jesteś w stanie dostać się bez problemu poprzez wywołanie ich i 
		 przypisanie do nich wartośći. W przypadku pól składających się z innych pól musisz zadabać o 
		 zaktualizowanie tych pojedyńćzych pól z których się składa. 
		*Robi się to poprzez dekorator o nazwie: 'nazwa_pola.setter' (nazwa dekoratora musi być taka 
		 sama jak nazwa funkcji(czyli nazwa pola)) i stworzeniu funkcji która będzie przyjmować TYLKO 
		 JEDEN! argument, który później, w wewnątrz funkcji będzie się splitować. 
		*Później do takiego settera możesz się dostać poprzez wywołanie go jak zmiennej (tak samo jak
		 w getterze). Pamiętaj! Żeby mógł powstać setter to najpierw musi zostać stworzony getter.
			##tworzysz najpierw gettera dla fullname żeby póxniej móc utworzyć settera:
					@property
					def fullname(self):
						return f'{self.first} {self.last}'
			##tworzysz settera poprzez dekorator o nazwie fullname.setter, przyjmujący tylko jedną wartość:
					@fullname.setter
					def fullname(self, name):
						self.first, self.last = name.split(" ")
			##teraz możesz mofyfikować zmienną fullname jednocześnie aktualizuąc pola z których się składa:
				emp_1 = Employee('Marek', 'Kucharek') 
				print(emp_1.fullname)						#zwróci 'Marek Kucharek'
				print(emp_1.first, emp_1.last)				#zwróci 'Marek' 'Kucharek'
				emp_1.fullname = 'Darek Jurek'				#SETTER
				print(emp_1.fullname)						#zwróci 'Darek Jurek'
				print(emp_1.first, emp_1.last)				#zwróci 'Darek' 'Jurek'				 
	*DELETERy w Pythonie DOTYCZĄ PÓL SKŁADAJĄCYCH SIĘ Z INNYCH PÓL.
		*Deleter ma za zadanie przypisać wartość None, polom z których składało się nasze pole
		 które chcemy usunąć
		*Deleter'a tworzy się poprzez dekorator o nazwie 'nazwa_pola.deleter'. W Deleter'ze nie 
		 podajemy żadnych argumentów. JDeleter jest swostym przeciążeniem alaisu del gdyż wywołuję 
		 się go właśnie poprzez alias del
					@fullname.deleter
					def fullname(self):
						self.first=None
						self.last=None
				emp_1 = Employee('Marek', 'Kucharek') 
				del emp_1
	***INNA OPCJA GETTER'a:
		*Możnaby się także zastanowić po co nam inna opcja skoro adekorator property powinien 
		 kompletnie nam wystarczyć - tak na prawde to nie wiem i trzewba przyjąć że druga opcja 
		 gettera to to samo co @property:
			class Pracownik:
				def __init__(self, imie, nazwisko):
					self.imie=imie
					self.nazwisko=nazwisko
				@property										#I opcja gettera 
				def pelne_imie(self):
					return self.__imie+" "+self.__nazwisko
				@pelne_imie.getter								#II opcja gettera 
				def pelne_imie(self):
					return self.__imie+" "+self.__nazwisko
				@pelne_imie.setter								#SETTER
				def pelne_imie(self, zmienna):
					imie,nazwisko=zmienna.split(" ")
					self.__imie=imie
					self.__nazwisko=nazwisko
		*Wywołanie setterow i getterow poprzez przypisanie im wartośći jak do zmiennych:
			k2=Pracownik()
			k2.pelne_imie="Darek Jozwik"
			print(k2.pelne_imie)								#dojście do gettera z I i II opcji

########## KLASY I OBIEKTY OOP | METODY KLAS I METODY STATYCZNE | DZIEDZICZENIE | METODY MAGICZNE #########
https://www.programiz.com/python-programming/object-oriented-programming
METODY MAGICZNE: https://www.youtube.com/watch?v=IkWrlRei0uA
1* KLASA I OBIEKTY
			class Czlowiek:
				imie = "Domyslny"	#argument klasowy
	*KONSTRUKTOR czyli, def __inif__(self):
		*pola/argumenty dla klasy wpisywane są tylko w metodzie inicjalizacyjnej. Można je przypisać 
		 przed init ale wtedy będą to argumenty klasowe a nie obiektowe przez co będzie się można do
		 nich odwołać z każdego obiektu i będą przetrzymywać wartość wspólną dla wszystkich obiektów 
		*domyslny konstruktor jako definiowanie specjalnej funkcji inicjalizacyjnej (z dwoma 
		 'podlogami' z przodu i z tylu, w ktorej pierwszy argument self jest domyslny
		*jezeli nie stworzymy konstruktora to czy tak czy tak bedzie mozna stworzyć obiekt bo
		 wtedy jest tworzony konstruktor domyślny
					def __init__ (self):
						self.x, self.y, self.r = 0, 0, 1
					
					def __init__(self, imie, wiek):
						self.imie= imie
						self.wiek = wiek	
		*niezależnie od tego czy stworzymy konstruktor czy nie to czy tak czy tak będzie można utworzyć do
		 niego pole dla danej instancji:
				class User:
					def __init__(self, imie)"
						self.imie=imie;
				user1=User("Marek")
				user1.firstName="Darek"			#mimo że pole firstName nigdy wcześniej nie istniało
												#i nie było zadeklarowane w klasie ani w konstruktorze  
												#to Python pozwala w ten sposób tworzyć nowe pola
	*Argument SELF w __init__(self):
		*The self parameter is a reference to the current instance of the class, and is used to 
		 access variables that belong to the class.				
		*self jako predefiniowany argument, jest to argument ukryty. Self jest aliasem dajacym
		 dostep do pol klasy. Slowko self mozna zmiennic na inna nazwe ale przyjete jest self	
		*self wewnatrz funkcji/konstruktora jest jak 'this' w Javie ale nie jest opcjonalny 
		 tylko konieczny gdyz inaczej pycharm potraktuje zmienna bez self jak nowa zmienna.
		*self musi być użyte jako pierwszy argument ponieważ inaczej wywali błąd a poza tym dzięki
		 slef można dostać się do metod obiektu w dwojaki sposób:
		*w funkcji w klasie pierwszy argument self jest domyslny i przy wywolaniu funkcji nie podaje
 		 się go.
				class Employee:\
					raise_amount=1.04					#argument klasowy
					def __init__(self, first, last)
						self.first=first
						self.last=last
					def fullname(self)
						return f'{self.first} {self.last}'
				emp_1=Employee('Marek', 'Kozarek')
				print(emp_1.fullname())					#wywołanie poprzez odwołanie się do obiektu
				print(Employee.fullname(emp_1))			#wywołanie metody poprzez odwołanie się do klasy
														#i podanie w pierwszym argumencie obiektu
	*ARGUMENTY/POLA KLASOWE:
		*zamiast podawania ich w konstruktorze ( __init__(self)) to podajesz je wewnątrz klasy
		*POLE KLASOWE jest tylko jedno i jest takie samo (ma taki sam adres w pamięci) dla wszystkich 
		 obiektów, tzn że jak zmodyfikujesz w którymś obiekcie to zmodyfikujesz we wszystkich.
		*wewnątrz klasy możesz dostać się do pola klasowego albo poprzez odwołanie się do nazwy 
		 klasy albo poprzez odwołanie się do argumentu self:
				class Employee:
					raise_amount=1.04
					...
					def change_raise_amount():
						Employee.raise_amount=1.06		#odwołanie się poprzez nazwę klasy
						self.raise_amount=1.05			#odwołanie się poprzez argument self
		*możesz wywołać argument/pole klasowe albo poprzez klase albo przez jakikolwiek obiekt:
				Employee.raise_amount = 1.05			#wywołanie przez nazwę klasę (zalecane)
				emp_1.raise_amount = 1.06				#wywołanie przez obiekt
		 jednakże jak przypiszesz jakąś nową wartość poprzez dostanie się przez obiekt to musisz liczyć
		 się z tym że argument klasowy zostanie zmieniony tylko dla tego obiektu tj:
				print(emp_1.raise_amount)				#zwróci 1.06
				print(Employee.raise_amount)			#zwróci 1.05 zamiast 1.06 !!!
		 co oznacza że MODYFIKACJA ARGUMENTU KLASOWEGO POPRZEZ odwołanie się do niego przez OBIEKT
		 sprawia że NIE MA ON TAKIEJ SAMEJ WARTOŚCI DLA WSZYSTKICH TYLKO DLA TEGO JEDNEGO OBIEKTU !!!
		 
	*DODATKOWE:
		*jeżeli tuż pod klasą wpiszesz w trójcudzysłów komentarze to przy wpisaniu w funkcje help 
		 nazwy klasy ten komentarz wyświetli ci się w dokumentacji. Tak samo możesz robić pod metodami:
				class User:
					'''Komentarz co robi klasa User'''
					pass
				help(User)							#wyswietli się: '''Komentarz co robi klasa User'''
		*argumenty w funkcji w klasie mozna podawac juz z domyslnymi wartosciami:
					def przedstawSie(self, powitanie="Czesc"):
						self.imie = "zmianaImienia"
						return "{}, imie {}, wiek {}".format(powitanie, self.imie, self.wiek)
		*PRZEKAZANIE OBIEKTU JAKO ARGUMENT DOMYŚLNY DO FUNKCJI:
			*tworzenie obiektu podczas przekazania go jako argument domyślny do funkcji (czyli gdy do 
			 argumentu domyślnego w funkcji jest przekazywana wartość w postaci obiektu) --> wtedy 
			 wewnątrz tej funkcji musisz ZRESETOWAĆ konstruktor poprzez wywołanie go:
				class ObiektKlasy(object):
					def __init__(self):
						self.current = 0
					def get_next(self):
						return self.current+=2
						
				def func(n, arg=ObiektKlasy()):
					arg.__init__()
					for i in range(n):
						print(arg.get_next())

2* METODY KLAS I METODY STATYCZNE
	1*PODSTAWY:
		*METODA KLASY i METODA STATYCZNA różnią się od zwyczajnych metod w klasie tym że mogą 
		 zostać wywoałane nie tylko na obiekcie ale przede wszystkim na klasie
				class Czlowiek:
					raise_amount=1.05
					def __init__(self,imie, nazwisko):
						self.imie=imie
						self.nazwiko=nazwisko
					def przedstawSie(self):
						print("Nazywam sie "+ self.imie + self.nazwisko)
		*METODE KLASY - tworzy się poprzez nadpisanie aliasu @classmethod nad funkcje:				
					@classmethod
					def change_raise_amount(cls, amount):
						cls.raise_amount=amount				#zmamiast cls mógłbyś tutaj 
															#użyć Czlowiek.raise_amount=amount
					Czlowiek.change_raise_amount(1.07)		#pol eklasowe raise_amount przypisze 1.07
		*METODA STATYCZNA - tworzy się poprzez nadpisanie aliasu @staticmethod nad funkcje
					@staticmethod
					def przywitaj(arg):
						print("Czesc "+arg)
					Czlowiek.przywitaj('mama')				#zwróci "Cześć mama"
	2*RÓŻNICE między metodą KLASOWĄ a STATYCZNĄ:
		*Metoda statyczna działa bardzo podobnie do metody klasy ale metodę statyczną tworzy się przede 
		 wszyskim wtedy gdy nie odwołuję się ona w rzaden sposób do klasy albo do obiektu. Jest ona w 
		 jakiś sposób związana z klasą ale nie odwołuję się ona do niej!!!
		*Tym co głównie odroznia metode klasy od metody statycznej to slowa kluczowe cls podane jako 
		 pierwszy argument w metodzie klasy
			 ##slowo kluczowe 'cls' jest odwolaniem do klasy(class) i jest tym samym co slowko 'self'
			   dla metod obiektowych (self jest dla tych metod odwolaniem do obiektu)(a tutaj cls 
			   jest odwolaniem do klasy). Przy odwołaniu się zamiast słówka cls mógłbyś użyć nazwy klasy. 
		*ALTERNATYWNY KONSTRUKTOR - poprzez metodę klasową możesz stworzyć 'alternatywny konstruktor':
				@classmethod
				def nowy_czlowiek(cls, imie, nazwisko):
					return cls(imie, nazwisko)				#działa tak samo jak konstruktor Czlowiek(imie)
				@classmethod								#drugi przykład:
				def nowy_czlowiek_2(cls, string):			#taka sama metoda tylko że z przetwarzaniem
					imie, nazwisko =string.split('-')
					return cls(imie, nazwisko)
				Czlowiek.nowy_czlowiek_2('marek-darek'):	#zwróci Czlowiek('marek', 'darek')
	3*WYWOŁANIA: 
		*wywołanie metody klasowej i statycznej na klasie:
				cz1 = Czlowiek.nowy_czlowiek("marek",'Darek')   
				Czlowiek.przywitaj(" Andrzeju!!!")  
		*wywołanie metody klasowej i statycznej na obiekcie (nie robi się tak):
				cz2 =cz1.nowy_czlowiek("Adrian",'Darek')    
				cz2.przywitaj(" Kamilu!!!")        

3* Dziedziczenie
	*PODSTAWY:	
		*Dziedziczenie odbywa sie poprzez wpisanie w nawiasy za nazwą klasy, klasy rodzica 
		 po której nasza klasa odziedziedziczy wszystkie metody i atrybuty.
		*w pierwszej kolejności python szuka argumentów i metod w naszej klasie a jeżeli
		 nie może ich znaleźć to szuka ich w klasie rodzica.
				class Animal:
					color='white'
					def __init__(self, name, age):
						self.name=name
						self.age=age
					def printParent(self):
						return "AnimalParent"
					def voice(self):
						return "hrrrrr"
				class Wolf(Animal):			#od tego momentu klasa Wolf odziedziczyła
					pass					#wszystkie atrybuty i metody z klasy Animal
				w1	= Wolf('Zbyszek',19)			
				print(w1.printParent())		#zwróci: 'hrrrrr' i 'white' - metoda 
				print(w1.color)				#printParent() oraz argument color wystepują
											#tylko w klasie Animal ale jakakolwiek klasa 
											#dziedziczaca moze sie do nich odwolac
		*tak samo może być z metodą __init__() albo z jakakolwiek inna metoda lub argumentem.
		 Jeżeli nie przesłonisz w klasie dziedziczącej metody lub argumentu to wszystkie 
		 klasy będą się odwoływać do tej metody/argumentu z klasy gdzie ostatnia zostały 
		 zdefiniowane (czyli klasy rodzica).
	*PRZESŁONIĘCIE/NADPISANIE + SUPER():
		*jeżeli zdefiniujesz metode __init__() w klasie dziedziczacej to wtedy metoda z 
		 klasy dziedziczącej przesłoni (override) metode z klasy rodzica. Poprzez wywołanie
		 metody super() w konstruktorze odwołasz się do __init__() klasy rodzica. Ponadto 
		 mozesz dodac w __init__() dodatkowe pola ktore inicjujesz normalnie poprzez self:
				class Wolf(Animal):
					def __init__(self, name, age, speed):
						super().__init__(name, age)
						self.speed = speed
		*mozesz przesłaniać nie tylko __init__() ale tez metody w klasach dziedziczacych (jak 
		 metode voice() poniżej) i dodac do nich to co sie dzialo w tych metodach w klasie 
		 rodzica (poprzez super()):
					def voice(self):
						return super().voice() +" auuuu"
		*nie potrzebujesz metody super() żeby odwołać się do metody rodzica. Możesz to zrobić
		 poprzez nazwe klasy i wywołania tejze metody: parentClass.__init__(self,...):
				class Werewolf(Wolf):
					def __init__(self, name, age, speed, height):
						#super().__init__(name, age, speed)		 #nie trzeba metody super()
						Wolf.__init__(self, name, age, speed) 	 #konstruktora mozna też	
																 #przesłonić w ten sposób
						self.height=height
					def __str__(self):
						return str(self.name) +" "+ str(self.age)+" "+\
								str(self.speed)+" "+str(self.height)
				werewolf1 = Werewolf("Reksio",22, 100, 1.82)
				print(werewolf1.printParent())
				print(str(werewolf1))
				print(werewolf1.voice())
								#zwroci:AnimalParent; Reksio 22 100 1.82;* hrrrrr auuuu
	*Metody wykorzystywane do sprawdzenia dziedziczenia:
		*isinstance(obj, class/type) - sprawdza czy obiekt jest obiektem danej klasy (może
		 być to klasa dziecka lub rodzica) lub sprawdza czy obiekt jest danego typu:
				isinstance(werewolf1, Werewolf)
				isinstance(werewolf1, Wolf)
				isinstance(werewolf1, Animal)
				isinstance([1,2,3], list)					#wszędzie zwróci True
		*issubclass(obj, class) - sprawdza czy klasa jest podklasą dla rodzica:
				issubclass(Werewolf, Wolf)					
				issubclass(Werewolf, Animal)				#w obu przypadkach zwróci True
				
4*Metody Magiczne:
  METODY MAGICZNE: https://www.youtube.com/watch?v=IkWrlRei0uA
  ##Przeciążenie(overloading) - Mamy z nim doczynia w chwili gdy wiele metod w klasie, 
    posiada tą samą nazwę metody ale inną sygnaturę. ... 
  ##Przesłanianie(overriding) - Mamy z nim do czynienia gdy klasa bazowa jak i pochodna 
    posiadają tą samą sygnaturę metody.
	*PODSTAWY:
		*zaczynaja sie 2 podkreslnikami i koncza 2 podkreslnikami
		*maja specjalne zastosowanie zwiazane z przeciazaniem niektorych metod w celu uzycia
		 np operatorow matematycznych do dzialan na obiektach albo wywolania tych przeciazaonych
		 metod przy niektorych sytuacjach
	*METODY PODSTAWOWE:
		0.if __name__ == '__main__': - pozwala uruchomić blok funkcji i obiektów z poziomu
			otwarcia danego pliku/modułu. (Otwierając plik .py w konsoli zostaną autmatycznie
			uruchomione pewnego funkcje z niego (te któe będą w bloku tego if'a) - nie trzeba
			ich uruchamiać ręcznie (np dla pliku sendX.py) 
					if __name__ == '__main__':
						func1()
						print('uruchomiono func1')
				(w konsoli): python -i sendX.py 	#automatycznie zostanie uruchomiona funkcja 
													# func1() oraz wyświetli się napis, i nie
													# trzeba jej wywołyać ręcznie (func1())
		1.__init__() jest zawsze wywolywana w momencie tworzenia obiektu na bazie danej klasy
					import math
					class Punkt2d:
						def __init__(self, x, y):
							self.x=x
							self.y=y
							self.odleglosc= math.sqrt(x**2 +y**2)
		2.__doc__() - pozwala dostać się do dokumentacji danego obiektu (biorącego się z klasy):
					class Snowflake:
						'''Snowflake opis'''
						pass
					s1=Snowflake()
					s1.__doc__()					#zwróci:'''Snowflake opis'''
		3.__dict__ - nie jest metodą ale pozwala zobaczyć wszystkie argumenty danego obiektu 
			wypisane w postaci słownika.
			*pozwala dostać się do pól stworoznych poprzez przypisanie:
					s1.name='marek'
					print(s1.__dict__)						#zwróci: {'name':'marek'}
			*oraz do pól stworznych w konstruktorze __init__() (ale nie pól klasowych!):
					class Martian:
						raise_amount=1.04
						def __init__(self,fn, ln):
							self.first_name=fn
							self.last_name=ln
					m1=Martian('Tomek','Borek')
					print(m1.__dict__)		#zwróci: {'first_name':'Tomek','last_name':'Borek'}
			*do pola klasowego w __dict__ możesz dostać się tylko poprzez nazwę klasy:
					print(Martian.__dict__)	
										#zwróci pole raise_amount ale nie zwróci pól obiektów
		4.__str__() oraz __repr__() (od representation) - metody string, która będą zwracane gdy 
			będziesz chciał wyświetlić obiekt w print'cie. 
			*nieprzeciążone będzie zwracać nazwę klasę i adres hexadecymalny w pamięci. Dla id
			 zwróci ten sam adres tylko w formie dziesiętnej:
					print(m1)					    #zwróci: <__main__.Martian object at 0x0371D2D0>
					print(m1.__str__())		#zwróci to samo: <__main__.Martian object at 0x0371D2D0>
					print(m1.__repr__())	#zwróci to samo: <__main__.Martian object at 0x0371D2D0>
					print(id(m1))	  	    #zwróci: 57791184 (odpowiada to hexadecymalnemu powyżej)
			*Działają prawie tak samo ale __str__() jest używana tylko dla end-usera a __repr__() 
			 przy debugowaniu i loggingu. Różnią się tym że __repr__() zwraca dokładnie to czym są 
			 obiekty czyli gdy skastujesz na stringa to __str__ ci tego nie pokaze a __repr__ juz tak:
					m1=Martian('Tomek','Borek')
					b=str(m1)
					print(m1.__str__())		#zwróci: <__main__.Martian object at 0x0000028566A12F40>
					print(m1.__repr__())	#zwróci: <__main__.Martian object at 0x0000028566A12F40>
					print(b.__str__())		#zwróci: <__main__.Martian object at 0x0000028566A12F40>
					print(b.__repr__())		#zwróci: '<__main__.Martian object at 0x0000028566A12F40>'
			*przeciążone będą zwracać to co sobie ustalisz:
					class Martian:
						...(konstruktor jak powyżej)...
						def __str__():
							return f'Imie: {first_name}, Nazwisko: {last_name}'
						def __repr__():
							return f'Imie: {first_name}, Nazwisko: {last_name}' 
					m2=Martian('Lolek','Musinski')
					print(m2)			#zwróci Imie: Lolek, Nazwisko: Musinski				
		5.__setattr__() - jest wywoływana zawsze podczas tworzeniu nowego przypisania wartości
			do pola czyli:
				a)podczas tworzenia obiektu:
					class Martian:
						...(konstruktor jak powyżej)...
						def __setattr__(self, name, value):
							print('setting: ',name,':', value) #zawsze podczas tworzenia
															   #obiektu po przypisaniu każdego 
															   #pola będzie wyswietlać się 
															   #'setting nazwaPola : wartosc
					m1.Martian("Radek","Maniek")	#zwróci: 'setting: first_name : Radek'
															 'setting: last_name : Maniek'
				b)podczas przypisania wartosci do pola:
					m1.arrival_Date='2038-12-15' #zwróci: 'setting: arrival_Date : 2038-12-15'
		 #! ponieważ przeciążasz tę metodę __setattr__(self, name, value) to musisz tam
			dodać również dodawanie elementów do słownika atrybutów. Inaczej nie zostaną one
			automatycznie dodane i przy wywołaniu pola __dict__ nie zostaną one pokazane:
					class Martian:
						...(konstruktor jak powyżej)...
						def __setattr__(self, name, value):
				#!!! 		self.__dict__[name]=value			#!!!
							print('setting: ',name,':', value)
		6.__getattr__() - służy do tego żeby pobierać pola niestandardowe czyli o takich 
			nazwach które nie znajdują się w słowniku zawierającym wszystkie pola (__dict__) 
			(metoda __getattribute__() służy do pobierania pól które znajdują się w __dict__
			a tejze metody (__getattribute__()) się nie przeciąża). 
					class Martian:
						...
						def __getattr__(self, name):
							print('getting: ',name)
							if name=='fullname':
								return f"{self.first_name} {self.last_name}"
							else:
								raise AttributeError("No attribute{0}".format(name))
			Metodę __getattr__() używa się do precyzowania niestandardowych znaczników/pól 
			które nie zostały ani sprecyzowane ani w konstruktorze ani podczas przypisania.
					print(m1.fullname) 		#wywołanie pola fullname pozwoli na zwrócenie
											#pola first_name oraz pola last_name
			raczej nie przeciąża się metody __getattr__(). O wiele lepiej jest przeciążyć 
			stringa czyli metodę __str__(). Chyba że zależy ci na jakieś specjalnej nazwie
			którą użyjesz do zwracania jakiegoś miksa kilku pól. 
	*METODY DO PORÓWNANIA - gdy je przeciążysz to będą one wykorzystywana nie tylko 
		podczas porównywania ale także podczas sortowania. Wystarczy że przeciążysz
		metodę less than __lt__(self, other) (przeciazenie znaku '<'):
					class Martian:
						def __init__(self, fn, ln):
							self.first_name=fn
							self.last_name=ln
						def __lt__(self, other):
							return self.first_name < other.first_name
					m1=Martian('Denek','zumb')
					m2=Martian('Zenek','zumb')
					m3=Martian('Cenek','zumb')
					martians=[m1, m2, m3]
					martians.sort()			#zwróci posortowane obiekty względem imienia 
											#czyli: [ m3, m1, m2 ]
		
	*INNE Przyklady roznych magicznych metod ktore przeciazasz:
        *DODAWANIE add: bedziemy przeciazac znak '+' dla obiektow Punkt2d
						def __add__(self, p2):
								return Punkt2d(self.x + p2.x, self.y + p2.y)
        *POROWNANIE equal eq: bedziemy przeciazac znak '==' dla obiektow Punkt2d
						def __eq__(self, p2):
							return self.x == p2.x and self.y==p2.y
        *LENGTH len - bedziemy przeciazac metode len() tak by pokazywala odleglosc od srodka 
		 ukladu wspolrzednych
						def __len__(self):
							return int(round(self.odleglosc))
        *POROWNANIE LESS/ EQUAL THAN:przeciazenie znaku '<=' dla obiektow Punkt2d
						def __le__(self, p1):
							return self.odleglosc <= p2.odleglosc
    *Inne ZNAKI/METODY ktore mozna przeciazyc poprzez metody magiczne":
        #greater equal '>=': ge ;; greater than '>': gt ;;
        #less equal '<=': le ;; less than '<': lt ;;
        #not equal '!=' : ne ;; equal '==' : e ;; absolute: abs
        #adding:add ; substraction:sub ; dividing:div ; multiplying:mul
        #mozna przeciazyc metody odpowiadajace za konwersje na rozne typy np: int, float, str
				p1 = Punkt2d(5,8)
				p2 = Punkt2d(4,5)
	*Wywolanie metod magicznych odbywa sie poprzez uzycie danego operatora matematycznego przy 
	 obiekcie ALBO uzycie przeciazonej funkcji na obiekcie
		#przy dodawaniu 2 obiektow zostanie wywolana metoda magiczna ktora wczesniej sobie 
		 zdefiniowalismy jako __add__ ktora bedzie dodawac pola tych obiektow i tworzyc nowy 
		 obiekt o tej samej klasie co te obiekty
				p3 = p1 + p2
				print(p3.x, p3.y)
				print(p1<p2)
				print(len(p1))


######### LEKCJA 16 i 37 PODSUMOWANIE KOLEKCJI | WYCINKI KOLEKCJI | UNBOXING KOLEKCJI ####################
UNBOXING KOLEKCJI: 		https://www.w3schools.com/python/python_tuples_unpack.asp

0* PODSUMOWANIE KOLEKCJI: (apart of tuples all are mutable) 
	*List (lista) []		- mozliwe DUPLIKOWANIE elementow, mozna modyfikowac, uporzadkowana
	*Tuple (krotka) () 		- mozliwe DUPLIKOWANIE elementow, nie zmienna      , uporzadkowana
	*Set (zbior) {}			- NIE mozna DUPLIKOWAC elementow, mozna modyfikowac, nieuporzadkowany
	*Dictionary (slwonik) {}- NIE mozna DUPLIKOWAC elementow, mozna modyfikowac, uporzadkowany 

1* WYCINKI - SLICING COLLECTIONS:
	*zwracaja czesc danej kolekcji (wycinaja czesc elementow z kolekcji)
	*te nowa kolekcje (w postaci czesci elementow mozemy przypisac do zmiennej
	*w nawiasach kwadratowych nie podajemy jednego indeksu tylko poczatek indeksu rozdzielamy
	 dwukropkiem od koncowego elementu indeksu (ktory nie jest brany pod uwage)
				print(krotka[0:3])		[zwroci nam krotke z 3 elementami o nr: 0,1,2]
	*jezeli podamy koncowy element taki ktory nie istnieje to funkcja nie zwroci nam bledu 
	 tylko potraktuje to jako ostatni element 
				print(krotka[0:100])	[zwroci nam wszystkie elementy mimo ze jest ich 6]
	*mozesz tez zostawic drugi parametr pusty co sprawi ze zostanie to potraktowane jako 
	 "lacznie z ostatnim elementem"
				print(krotka[0:])		[zwroci wszystkie elementy]
	*mozesz tez zostawic pierwszy parametr pusty co sprawi ze zostanie to potraktowane jako 
	 "od zerowego elementu do numeru podanego za dwukropkiem
				print(krotka[:4]		[zwroci od zerowego elementu do 3ciego]
	*mozemy tez podac parametry wycinku liczac od konca - wtedy wpisuje liczby z minusem
	 i liczysz od -1 elementu (a nie od zerowego) (element koncowy tez nie jest brany pod uwage)
				print(krotka[-4:-2])
	*mozesz jeszcze podac 3ci parametr czyli wartosc skoku jaki bedzie brany pod uwage w 
	 wycinku (np co 2gi element)
				print(krotka[1:8:2])	[zwroci co drugi element]
	*w 3cim parametrze mozemy tez zapisac wartosc ujemna co sprawi ze WYCINEK bedzie 
	 odwrotnie posortowany 
				print(krotka[:4:-1])	[zwroci elemtny od 3ciego do zerowego]

	######LEKCJA 37 
	https://www.w3schools.com/python/python_tuples_unpack.asp

2* Zamiana LISTY/KROTKI na ARGUMENTY, ktore są potrzebne do funkcji (wszystko podane w 1 linii)
	używasz do tego '*' przed listą:
	https://note.nkmk.me/en/python-argument-expand/ 
				def func(arg1, arg2, arg3):
					print(arg1, arg2, arg3)
				list1 = ['one', 'two', 'three']
				func(*list1)  					#ALBO
				func(*['a1','a2','a3'])			#ALBO
				func(*('a1','a2','a3'))
	
3* ROZPAKOWANIE DOWOLNEJ KOLEKCJI (UNBOXING) - KROTKI, LISTY, SŁOWNIKA i ZBIORU:
		*w poniższy sposob jestesmy w stanie bardzo latwo przypisac do zmiennych wartosci 
		 z krotki lub inne kolekcji np.: z listy
				a,b,c = (2,4,3)
				print(a)
				print(b)
				print(c)
		*Normalnie przy zamianie wartosc w zmiennych musiałes stworzyc zmienna tymczasowa w
		 pythonie nie musisz tego robic wystarczy ze zrobisz rozpakowanie krotki
				x=10
				y=20
				x,y=y,x
				print(str(x)+" "+str(y))		#wyswietli ci sie 20 10
		*Using Asterisk* - gdy masz w krotce wiecej wartosci do rozpakowania niz zmiennych to 
		 jedną ze zmiennych mozesz zapisać z gwiazdką czyli zeby wzięło to Tobie jakąs 
		 liczbe parametrow do listy:
				start,*wszystko,koniec=(1,2,3,4,5,6,7)		#wyniki:
				print(start)								#1
				print(wszystko)								#[2, 3, 4, 5, 6]
				print(koniec)								#7


########## BUILT-INS | *ARGS **KWARGS | KOPIOWANIE W PYTHONIE | MODULE COLLECTIONS #######################
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
https://www.programiz.com/python-programming/methods/built-in
https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/

https://www.geeksforgeeks.org/python-collections-module/
https://www.geeksforgeeks.org/defaultdict-in-python/
https://www.geeksforgeeks.org/counters-in-python-set-1/
https://www.geeksforgeeks.org/ordereddict-in-python/

https://www.geeksforgeeks.org/namedtuple-in-python/
https://www.geeksforgeeks.org/chainmap-in-python/	
https://www.geeksforgeeks.org/python-collections-module/#deque

0*BUILT-INS - FUNKCJE WBUDOWANE:						
  *FUNKCJE PODSTAWOWE:
  	*len(collection) - zwraca długośc całej kolekcji lub Stringa (dla Dictionary zwraca ilosc kluczy)
	*del collection - usuwa całą kolekcję lub Stringa lub jakikolwiek obiekt
	*type(collection) - zwraca typ klasy jaką reprezentuję obiekt <class 'dict'>	
				if(type(mylist)==list):						#[type(mylist) zwróci: <class 'list'>]
					print("To lista")
				type(mylist) 			# <class 'list'>
				type(mytuple) 			# <class 'tuple'>
				type(myset) 			# <class 'set'>
				type(mydictionary) 			# <class 'dict'>
	*isinstance() sprawdza czy obiekt jest danego typu zwracając True or False:
				print(isinstance(200, int))
				if isinstance(to_emails, list):
					print(True)
				def send_mail(text="hello world", to_emails):
					assert isinstance(to_emails, list)				#podniesie wyjątek jeśli 
					...												#to_emails nie będzie listą
	*słowo kluczowe in - pozwala sprawdzić czy dany element(ew.klucz) znajduję się w kolekcji lub  
		w Stringu poprzez zwrócenie prawdy lub fałszu:
				print("j" in "To jest zdanie")								[zwroci: True]
				print("mama" not in "tata jest super")						[zwroci: True]
			  #2gi przykład:
				mylist = ["apple", "banana", "cherry"]
				if "apple" in mylist:
					print("Yes")
	*funkcja all()- zwraca prawde gdy wszystkie argumenty beda spelniac warunek 
				lista = [10,20,23,30]
				if all([i % 2==0 for i in lista]): #list comprehension zwroci[True, True, False, True]
					print("Wszystkie parzyste")		
	*funkcja any() - zwraca prawde gdy jakikolwiek argument bedzie spelniac warunek 
				lista = [10,20,25,35,40]
				if any([i % 2==0 for i in lista]):
					print("niektore parzyste")	
	*funkcje sum('list'), max('list'), min('list') pozwalaja odpowiednio na zsumowanie elementow listy, 
		znalezienie największego i najmniejszego elementu listy ALE tylko w liscie ktora bedzie zawierac 
		same liczby
  *FUNKCJE ZAAWANSOWANE:
	*enumerate() 
		*jest Iteratorem i ma jego cechy tj.: jest strumieniem więc można tylko raz po nim przejść, gdyz
		 jest WYCZERPOWALNY (exhausted). 
		*z podanej listy zwroci nam liste par krotek z ktorych pierwszy element bedzie indexem a 
		 drugi wartoscia z listy
				lista = [10,20,25,35,40]
				for i in enumerate(lista):
					print(i)					[zwroci nam :(0, 10);(1, 20);(2, 25);(3, 35);(4, 40)]
		*możemy zmienić indeksowanie podając w argumencie start odpowiednią wartość (jeżeli 
		 chciałbyś zacząć indeksowanie od 1 zamiast od zera to podaj w parametrze start 1)
				lista = [10,20,25,35,40]
				for i in enumerate(lista):
					print(i)					[zwroci nam :(1, 10);(2, 20);(3, 25);(4, 35);(5, 40)]
	*zip(Iterable1,Iterable2,...)  
		*jest Iteratorem i ma jego cechy tj.: jest strumieniem więc można tylko raz po nim przejść, gdyz
		 jest WYCZERPOWALNY (exhausted). 
		*przyjmuję w argumencie wiele kolekcji i zwraca krotki elementow o danym miejscu z kazdej 
		 poszczegolnej kolekcji. 
			pierwsza krotka - krotka pierwszych elementow z kazdej kolekcji	
			druga krotka - krotka drugich elementow z kazdej kolekcji	
			trzecia krotka - krotka trzecich elementow z kazdej kolekcji	itd
				zip([1,2,3,4,5,6],'Hacker')
								#zwroci: [(1, 'H'), (2, 'a'), (3, 'c'), (4, 'k'), (5, 'e'), (6, 'r')]
		*jeżeli kolekcje róznią się ilościa elementow to jest tworzone tyle krotek ile ma
		 najkrotsza kolekcja:
				zip([1,2,3],[0,9,8,7,6,5,4,3,2,1])					#zwroci: [(1, 0), (2, 9), (3, 8)]
		*można tez wypakować kolekcje poprzez gwiazdkę *
				A,B,C = [1,2,3],[6,5,4],[7,8,9]
				X = [A] + [B] + [C]
				zip(*X)										#zwroci: [(1, 6, 7), (2, 5, 8), (3, 4, 9)]
 
 *FUNKCJE DO SEKWENCJI:
	https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
	*DO SEKWENCJI MOZNA ZALICZYĆ 4 TYPY DANYCH:
		*range() (to co zwroci funkcja range)
		*string
		*lista
		*tuple (krotka)
		*do sekwencji nie zalicza się Dictionary (które musiałbyś zamienić na liste krotek poprzez
 		 metode items() gdybys chciał posortować, ani SET gdyż nie zawiera w sobie kolejności)
	*reversed(sekwencja) 
		*odwraca kolejność podanej sekwencji
		*zwraca obiekt list_reverseiterator ktory trzeba przekonwertowac na listę. 
				print(list(reversed(tuple)))
	*sorted(sekwencja) 
		*sortuję dany obiekt(kolekcję) Iterable. Posortuję Tobie każdą kolekcje łącznie z krotką i
		 set'em(zbiorem) gdyż zwraca obiekt listy w tych przypadkach i nie działa na orginale tylko 
		 na kopii. 
		*POSORTUJE tobie (tylusamoelementowe) krotki/listy zawarte w duzej LISCIE wzgledem 1wszego 
		 wyrazu od lewej(a jak dany wyraz taki sam w jednej i drugiej krotce to porownuje drugi i 
		 nastepne jesli sytuacja sie powtarza)
		 https://www.py4e.com/html3/10-tuples
				b=('r',10,22)
				c=('g',33,21)
				d=('r',9,55)
				e=('r',9,56)
				f=('z',1,1)
				list_of_tuples=[b,c,d,e,f]
				print(sorted(list_of_tuples)) 	#LUB: list_of_tuples.sort()
				for m1,m2,m3 in sorted(list_of_tuples):
					print(m1,m2,m3)		#zwwroci: g 33 21 ; r 9 55 ; r 9 56 ; r 10 22 ; z 1 1
		    *takie sortowanie krotek przydaje się przy sortowaniu SŁOWNIKA gdyż dzięki funkcji 
		     items() dostajesz krotki dwuelementowe składające się z byłych klucza i wartości:
				slownik={'c':10, 'a':1, 'b':22}
				for key, value in slownik.items():
					print(key, value)
				print(sorted(slownik.items()))						#zwroci: a 1 ; b 22 ; c 10
		*Można ten element wzgledem ktorego ma się odbyć sortowanie wskazać poprzez parametr key gdzie 
		 trzeba przypisać lambde ktora bedzie przyjmowac argument (kolekcje) i zwracać element tej 
		 kolekcji stanowiacy klucz do sortowania ( key=lambda x:x[1] (sortowanie wzgledem drugiego 
		 elementu)) ORAZ zamiast sortowania rosnącego możesz ustawić parametr reverse na True i 
		 zrobić sortowanie MALEJĄCE:
				print(sorted(slownik.items(),key=lambda x: x[1], reverse=True)	
			**do parametru key możesz także przypisać wartość w postaci itemgetter'a któego trzeba 
			  z modułu operator --> wskazując w jego argumencie numer miejsca argumentu w liscie 
			  posortuje według niego. 
				x = [
					 ['4', '21', '1', '14', '2008-10-24 15:42:58'], 
					 ['3', '22', '4', '2somename', '2008-10-24 15:22:03']
					]
				from operator import itemgetter
				print(sorted(x,key=itemgetter(1)))		#posortuję względem drugeij liczby
			  więcej na: 
			  https://stackoverflow.com/questions/409370/sorting-and-grouping-nested-lists-in-python?answertab=votes#tab-top
			**w tymżę parametrze key możesz także użyć funkcji attrgetter w przypadku gdy zmiast 
			  sekwencji (listy, krotki, słownika) podajesz jakiś OBIEKT. Wtedy dzięki 
			  attrgetter('atr') jesteś w stanie pole tegoż obiektu:
				class Employee:
					def__init__(self,name, age):
						self.name=name
						self.age=age
				emp1=('Marek',24)
				emp2=('Kamil',29)
				from operator import itemgetter
				print(sorted(x,key=attrgetter('age')))	#posortuję względem wieku pracownika
			**do key możesz też podać referencje do danej funkcji np abs (absolute):
				li = [5,-3,-2,8,-9,72,-1,0]
				s_li = sorted(li, key=abs)
				print(s_li)
				
  *FUNKCJE CZĘSTO UŻYWANE PRZY ZAMIANIE LIST NA ARGUMENTY:
    *ARBITRARY ARGUMENTS *ARGS **KWARGS --> patrz ARGUMENTY *args, **kwargs (poniżej)
	*eval() / exec() 
	 https://www.programiz.com/python-programming/methods/built-in/eval
	 https://www.programiz.com/python-programming/methods/built-in/exec
		*wykorzystywane do zamieniania stringow o nazwach funkcji na zwykle funkcje - przyjmują za 
		 argument stringa ktory zostanie przekonwertowany i wywolany jako funkcja lub obiekt.
				mainList=list()
				command="insert("+",".join([3,4,5)+")"	#przy pomocy tej składni joina mozesz dodac
				eval("mainList."+command)				#wiele argumentow po rzecinku 
		*w string podanym jako argument moze znajdować się nazwa zmiennej/argumentu tzn:
				x=2
				eval('x+3')								#zwroci 5
		*exec i eval są praktycznie takie same ale exec daje wieksze mozliwosci gdyz mozna w nim 
		 zapisać więcej linijek i to z enterem \n miedzy tymi linijkami :
				program = 'a = 5\nb=10\nprint("Sum =", a+b)'
				exec(program)
		zarownow jednym i durgi przypadku trzeba uwazac na sytuacje gdzie w evale robisz inputa
		eval(input()) - wtedy uzytkownik ma możliwośc zrobienia ataku podobnego do SQLInjection
		tylko że poprzez pobranie modulu os i skasowania plikow:  os.system('rm -rf *')
	
	*SKRÓT DO SETATTR() i GETATTR()?
		*podejście przydające się przy korzystaniu z metod SETATTR() i GETATTR() (szczególnie w pętlach): 
			*setattr():
					class Person:
						pass
					p1=Person()
					info_dict={'firstname': 'Corey', 'lastname':'Shafer', 'age':23}
					for key, value in info_dict.items():
						setattr(p1,key,value)
					print(p1.firstname)
			*getattr():
					for key in info_dict.keys():
						print(getattr(p1,key))
	*setattr(object, name, value)
	 https://www.programiz.com/python-programming/methods/built-in/setattr
			*pozwala na dynamiczne utworzenie atrybutu do obiektu (który jest pierwszym argumentem 
			 funkcjio nazwie która jest drugim argumentem i o wartości która jest trzecim argumentem. 
					class Person:
						age=23
					p1=Person()	
					setattr(p1, "name", "Marek")
					print(p1.name) 					#zwróci: Marek
			*największą zaletą stosowania metody setattr() jest to że w drugim argumencie możesz 
			 zamiast wartości podać już istniejącą zmienną o jakieś wartośći.
					class Person:
						age=23
					p1=Person()	
					a1="name"								#ponieważ nie możesz zrobić p1.a1=a2
					a2="Marek"								#gdyż chcesz żeby pole miało nazwę 'name'
					setattr(p1, a1, a2)						#więce wywołujesz metodę setattr()
						print(p1.name) 							#zwróci: Marek
	*getattr(object, name) 
	 https://www.programiz.com/python-programming/methods/built-in/getattr
			*pozwala na dostanie się do atrybutu lub metody danego obiektu getattr(obj, attr) jest 
			 rownoznaczne z obj.name
					class Person:
						age = 23
					person = Person()
					print('The age is:', getattr(person, "age"))
					print('The age is:', person.age)
			*najieksza zaleta związana z używaniem getattr() jest związana z tym że możęsz wywołać pole
			 w obiekcie przez wartość zmiennej którą podasz w argumencie funkcji:
					class Person:
						age=23
					p1=Person()
					first_argument = 'age'
					print(getattr(p1, first_argument))		#zwróci: 23
			*można też wywołać metodę z argumentami w dodatkowym nawiasie ale te argumenty trzeba wypakować z 
			 listy: getattr(d1, command)(*arg). Pod spodem wykorzystanie takiej metody wraz z pokazaniem 
			 innych opcji rozwiązania (w inputcie przyjmujesz komende i argument (czasami jest bez argumentu):
				#opcja 1
					from collections import deque
					d1=deque()
					for i in range(int(input())):
						command, *arg = input().split()
						getattr(d1, command)(*arg)
					[print(x,end=" ") for x in d1]
				#opcja 2
					from collections import deque
					d1 =deque()
					[eval("d1.{0}({1})".format(*input().split()+[""])) for i in range(int(input()))]
					[print(x, end=" ") for x in d1]
				#opcja 3
					from collections import deque
					de1=deque()
					for i in range(int(input())):
						#print(*input().split())
						command,*arg = input().split()
						exec("d1.{0}({1})".format(command, *arg+[""]))
					[print(x,end=" ") for x in d1]

1*ARGUMENTY *args,**kwargs - LISTY PARAMETROW W FUNKCJI:
	# ARBITRARY ARGUMENTS *args **kwargs - co zrobić gdy funkcja ma przyjmować wiele argumentow ale 
	  nie wiesz ile - tworzysz liste argumentow ktore sa nieskonczone w postaci krotki *args (czyli
	  mozesz podac odpowiednia liczbę argumentow a one zamienią się w krotke)(to nie musi być słowko 
	  args tylko jakiekolwiek ale przyjelo sie wpisywanie *args)
		*1 gwiazdka oznacza że :
			*stworzy z tego krotke argumentow ALBO
					def func(*args):
						print(args)
					func("Hello","Marek")							[#zwroci: ('Hello','Marek')]
			*rozpakuje sekwencje tak jak to masz ponizej:
					print(*range(1,10),sep="")
		*2 gwiazdki przed argumentem tj **kwargs - key words arguments (to nie musi być słowko 
		 **kwargs tylko jakiekolwiek ale przyjelo sie wpisywanie **kwargs) - wtedy wszystkie 
		 argumenty z przypisaniem (podane jako klucz i wartosc) stworzą słownik klucza i wartosci
		 mu odpowiadającej
					def func(arg1,arg2="World",*args, **kwargs):
						print(arg1,arg2,args, kwargs)
					func("Hello")										#ZWROCI: Hello World () {}
					func("Hello","Marek")								#ZWROCI: Hello Marek () {}
					func("Hi", "Arek", " ! ", " costam "," x")	
													 #ZWRÓCI: Hi Arek (' ! ', ' costam ', ' x') {}
					func("Hi", "Arek", " ! ", " costam ",rek="elza")	
											  #ZWRÓCI: Hi Arek (' ! ', ' costam ') {'rek': 'elza'}
				 #2gi przyklad:
					def myFun(**kwargs):
						for key, value in kwargs.items():
							print ("{} == {}".format(key, value))
					myFun(first ='Geeks', mid ='for', last='Geeks')   
	# *args SŁUŻY także ZAMIANIE LISTY NA ARGUMENTY WYMIENIONE PO SPACJI:
			lista=[1,2,3]
			print(*lista)			#zwroci: 1 2 3 
	# jeżeli znasz ilość potrzebnych argumentów do funkcji a masz listę to zamiast się odwoływać
	  do każdego z nich osobna możesz je 'wypakowac' jako argumenty po przecinku 
			lista=[1,2,3]
			def func(arg1,arg2,arg3):
				print(arg1,arg2,arg3)
			func(*lista)			#zwroci: 1 2 3
	# jeżeli masz więcej lub mniej elementów w liscie niż funkcja wymaga argumentow to wystarczy ze
	  uzyjesz w argumencie funkcji arbitrary argumnents *args i przy wywołaniu tej funkcji również
	  wypakujesz daną listę poprzez dodanie * przed tą listą
			def func(arg1,arg2,*args):
				print(arg1,arg2,*args)
			func(*[1,2,3,4])		#zwroci: 1 2 3 4   
			func(*[1,2])			#zwroci: 1 2     
	# jeżeli byś nie dodał tej * przed argumentem args wewnątrz funkcji to zwróciłoby Tobie krotki 	
			def func(arg1,arg2,*args):
				print(arg1,arg2,args)
			func(*[1,2,3,4])		#zwroci: 1 2 (3, 4) 
			func(*[1,2,3])			#zwroci: 1 2 (3,)
			func(*[1,2])			#zwroci: 1 2 ()   
		##dzięki takiej funkcji mozesz wypakować argumenty z listy inputowej 
			func(*input().split())
		##jeżeli chcesz z listy inputowej (input().split()) od razu wypakować argumenty ale dla jednych
		  funkcji bedziesz miał jeden argument a dla innych zero to dodaj do tego listę zawierającą 
		  pustego Stringa - [""] Przyklad gdzie chcesz w inputcie masz podawaną funkcje do wywolania
		  a obok nich argumenty (niektore funkcje przyjmują 1 argument inne zero)
			lst = [1,2,3,4]
			for i in range(2):
				eval("lst.{0}({1}))".format(*input().split()+[""]) 			
			[TERAZ W INPUTCIE NP:
				append 4
				pop				] #zwroci wywołanie evala na stringu: lst.append(4) lst.pop()
		##teoretycznie do wypakowania argumentow z listy inputowej móglbys uzyc joina 
		  ( ", ".input.split() ) ale wtedy musialbys miec pewnosc że albo podawane będą 
		  jednego typu
			mainList=list()
			command="insert("+",".join([3,4,5)+")"	//przy pomocy tej składni joina mozesz dodac
			eval("mainList."+command)				//wiele argumentow po rzecinku 
		  join sluzy też do zamiany listy na stringa - list to string :
		  https://www.geeksforgeeks.org/python-program-to-convert-a-list-to-string/
				' '.join(list)

2* KOPIOWANIE W PYTHONIE:
	 https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/
	*domyślnie na typach prostych odbywa się przez wartośc a przy typach złożonych jak obiekty odbywa
	 się kopiowanie przez REFERENCJE
	*PRZYPISANIE Przy typach prostych - kopiowanie odbywa się poprzez kopiowanie wartosci A NIE poprzez 
	 przypisywanie referencji:
				x=1
				y=2
				y=x		#dla print(y) zwroci: 1
				x=x+1	#dla print(y) NADAL zwroci: 1 czyli kopiowanie przez wartosci!!!
	*PRZY KOLEKCJACH jak listy, krotki, dictionary, słownik:
		**PRZYPISANIE - kopiuję przez referencję czyli jeżeli na pierwotnej kolekcji zrobisz jakies 
			operacje to na tej klasie do której tę pierwotną przypisałeś również zajdą zmiany:
				lst1=[1,2,3,4]
				lst2=lst1 			#dla print(lst2) wyjdzie 1,2,3,4
				lst1.append(5)		#dla print(lst2) wyjdzie 1,2,3,4,5
		**metoda copy() - kopiowanie przez WARTOŚCI (tylko w liście bo w krotce nie działa)
				lst1=[1,2,3,4]
				lst2=lst1.copy() 	#dla print(lst2) wyjdzie 1,2,3,4
				lst1.append(5)		#dla print(lst2) wyjdzie 1,2,3,4
		**SLICING - poprzez wycinki całej kolekcji - [:] - też możesz zrobić kopiowanie przez WARTOŚCI:
				lst1=[1,2,3,4]
				lst2=lst1[:]	 	#dla print(lst2) wyjdzie 1,2,3,4
				lst1.append(5)		#dla print(lst2) wyjdzie 1,2,3,4
	*PRZY TYPACH ZŁOŻONYCH tj. KLASACH i OBIEKTACH:
		**PRZYPISANIE - kopiuję przez referencje czyli jeżeli na pierwotnym obiekcie zrobisz jakies 
			operacje to na tym do ktorego ten pierwotny przypisałeś również zajdą zmiany
				class Hat:
					def __init__(self, size):
						self.size=size
					def setSize(self, size):
						self.size=size
					def __str__(self):
						return str(self.size)
				hat1=Hat(13)	
				hat2=hat1					#dla print(hat2) zwroci: 13
				hat1.setSize(15)			#dla print(hat1) zwroci: 15
				print(hat2)					#dla print(hat1) zwroci TAKŻE: 15 czyli odbyło się kopiowanie 
																						przez REFERENCJE
		**SHALLOW COPY - metoda copy() z modułu copy - trzeba zaimportować moduł copy, i na nowym 
			obiekcie wywołac metode copy z argumentem  w postaci obiektu ktory chce się skopiować. 
			Shallow copy działą tak samo jak przypisanie czyli kopiowanie jest PRZEZ REFERENCJE
				import copy
				hat1=Hat(13)
				hat2=copy.copy(hat1)		#dla print(hat2) zwróci: 13
				hat1.setSize(15)			#dla print(hat1) zwróci: 15
				print(hat2)					#dla print(hat2) zwróci TAKŻE: 15 czyli odbyło się kopiowanie 
																						przez REFERENCJE
		**DEEP COPY - metoda deepcopy() z modułu copy - też trzeba zaimportować moduł copy i na nowym 
		    obiekcie wywołać metodę deepcopy() z argumentem w postaci obiektu ktory chce sie skopiowac.
			Deep copy NIE kopiuję przez REFERENCJE tylko robi to poprzez WARTOŚĆ												
				import copy
				hat1=Hat(13)
				hat2=copy.deepcopy(hat1)	#dla print(hat2) zwroci: 13
				hat1.setSize(15)			#dla print(hat1) zwróci: 15
				print(hat2)					#dla print(hat2) zwróci: 13 CZYLI ODBYŁO SIĘ KOPIOWANIE
																						poprzez WARTOŚĆ	

3* MODULE COLLECTIONS - KOLEKCJE ROZSZERZONE:
https://www.geeksforgeeks.org/python-collections-module/
https://www.geeksforgeeks.org/defaultdict-in-python/
https://www.geeksforgeeks.org/counters-in-python-set-1/
https://www.geeksforgeeks.org/ordereddict-in-python/

https://www.geeksforgeeks.org/namedtuple-in-python/
https://www.geeksforgeeks.org/chainmap-in-python/	
https://www.geeksforgeeks.org/python-collections-module/#deque
		
	  
  **KOLEKCJA defeaultdict - TAKA SAMA JAK DICTIONARY ale GDY NIE MA KLUCZA TO NIE WYSKOCZY KEYERROR TYLKO 
							PODA DOMYŚLNĄ WARTOŚĆ ZADANĄ W FUNKCJI PODANEJ W ARGUMENCIE
							https://www.geeksforgeeks.org/defaultdict-in-python/
		*trzeba pobrać moduł collections:
				from collections import defaultdict
		*jest to kontener taki sam jak Dictionary ale przy inicjalizowaniu go w argumencie podaje się funkcje
		 ktora zwraca wartość która będzie domyślną wartość dla wywoływania klucza który nie istnieje 
		 (normalnie gdybys chciał wywołać klucz ktory nie istnieje to wyskoczy ci KeyError i trzebaby byłoby
		 za każdym razem sprawdzać czy klucz istnieje)
				from collections import defaultdict
				d = defaultdict(lambda: "Not Present")
				print(d['a'], d['b'])								#zwroci: Not Present Not Present
				d['python']="awesome"
				print(d)			 #zwroci: ('a', 'Not Present')('b', 'Not Present')('python', 'awesome')
		*nie trzeba w argumencie podawać funkcji - można też podać typ danych jak np int albo float
				from collections import defaultdict
				d=defaultdict(float)
				d['a']=1
				print(d['c'])								#zwróci: 0.0
		*jezeli w argumencie podasz pusty znacznik list to w przypadku:
			*wywołania niestniejącego klucza zwroci pustą listę, 
			*gdy przypiszesz jakąś wartość do niestniejącego klucza (to tak jak w Dictionary stworzy 
			 ten klucz i przypisze do niego wartość)
			*gdy uzyjesz metody append na nieistniejącym kluczu to zwroci tobie listę 
				from collections import defaultdict
				d = defaultdict(list)				#list - tak to jest pusty znacznik listy
				d['html']
				d['python']="awesome"
				d['java'].append("screwed")
				d['c++'].append("hard")
				d['c++'].append("old")
				for i in d.items(): print(i)		
															#zwróci: ('html', []) ('python', 'awesome')
															('java', ['screwed'])('c++', ['hard', 'old'])
		*NAJWIĘKSZA ZALETA to przy inicjalizowaniu defaultdict podanie w argumencie znacznika list 
		 --> dzięki temu będziesz mógł podać nieistniejący klucz i dopisać do niego wartość ktora 
		 będzie listą zawierającą wiele elementów 
		 --> to się przydaję gdy masz podaną liste elemnetów w której powtarzają się te same elementy
		 a ty chcesz z nich zrobić klucze gdzie wartośćiami będą ich indeksy
				lst=['b','a','a','b','a','b']
				from collections import defaultdict
				dct=defaultdict(list)			
				for i in range(len(lst)): 
					dct[lst[i]].append(i)
				print(dct)				#zwroci: defaultdict(<class 'list'>, {'b': [0, 3, 5], 'a': [1, 2, 4]})
		 
  **KOLEKCJA Counter - DE FACTO JEST TAKA SAMA JAK SLOWNIK TYLKO PORZĄDKUJE ELEMENTY LISTY POD WZGLĘDEM 
    ILOŚCI MALEJĄCO czyli: Counter({2: 4, 3: 4, 1: 3, 4: 2, 5: 1})
	https://www.geeksforgeeks.org/counters-in-python-set-1/
		*jest to kontener ktory przechowuje elementy jako klucze w słowniku a ich liczebność jako wartość do 
		 klucza w tymże słowniku. 
		*Jest to kolekcja iterowalna czyli Iterable. 
		*Trzeba ją zaimportować z modułu collections: from collections import Counter
				from collections import Counter
				myList = [1,1,2,3,4,5,3,2,3,4,2,1,2,3]
				Counter(myList)								#zwróci: Counter({2: 4, 3: 4, 1: 3, 4: 2, 5: 1})
		*funkcjonuje nie tylko na listach ale także na Stringach:
				from collections import Counter
				myString="aaaabbbccccc"
				Counter(myString)							#zwróci: Counter({'a':4, 'b':3, 'c':5})
		*Można na niej wywołąć te same metody co na kolekcji Dictionary czyli:
			* !!!! przy dużym pliku niestety metoda items nie daje rady sortować po wartosciach !!!!!
			*items()
				Counter(myList).items()						#zwroci: [(1, 3), (2, 4), (3, 4), (4, 2), (5, 1)]
			.keys()
				Counter(myList).keys()
			.values()
				Counter(myList).values()
			.get() 
				Counter(myList).get(key,0)
		*oraz inne metody:
			.update(list) - dodaje do istniejącego Countera nową liste ktora do wczesniejszej listy dodaje 
							ilosc wystepowania starych kluczy i ilość występowania nowych kluczy:
				
				coun = Counter([1, 2, 3, 1, 2, 1, 1, 2])		#zwroci: Counter({1: 4, 2: 3, 3: 1})
				coun.update([1,2,4)]					 		#zwroci: Counter({1: 5, 2: 4, 3: 1, 4: 1})
			.most_common(int) - zwraca najczęsciej występujący element danej listy. W argumencie możesz
							podać ile elementów najczęsiej występująćych chcesz by było widocznych.
				from collections import Counter
				a = "aaaaabbbbccc"
				a=Counter(a)
				print(a.most_common(2))							#zwróci: [('a', 5), ('b', 4)]
				print(a.most_common(1)[0][0])					#zwróći a
			.elements() - zwraca obiekt który przekonwertowany na liste daje wszystkie elementy listy:
				print(list(a.elements()))	# ['a', 'a', 'a', 'a', 'a', 'b', 'b', 'b', 'b', 'c', 'c', 'c']
	
  **KOLEKCJA OrderedDict - UPORZĄDKOWANE DICTIONARY (UPORZĄDKOWANE KLUCZE według KOLEJNOŚCI dodawania 
						   elementow). Dodawane elementy o istniejących wcześniej kluczach są nadpisywane
						   ale kolejność kluczy się nie zmienia:
						   https://www.geeksforgeeks.org/ordereddict-in-python/
		*daje możliwość stworzenia kolekcji DICTIONARY która dodatkowo jest uporządkowana według kolejności
		 dodawania elementow  (uporządkowane według kolejności przyoisywania są klucze)
		*w ten sposób jesteś w stanie pozbyć się powtórzeń i jednocześnie zachować kolejność podawanych 
		 elementow (chodzi o klucze w OrderedDict) (czego nie mógłbys zrobić poprzez przekonwertowanie 
		 na set()) (przy samym Dictionary kolejność wysietlanych kluczy jest losowa) 
				from collections import OrderedDict
				ordered_dictionary = OrderedDict()
				ordered_dictionary['a'] = 1
				ordered_dictionary['b'] = 2
				ordered_dictionary['a'] = 5
				print(ordered_dictionary)				#zwroci: {'a': 5, 'b': 2}
		*PRZEKONWERTOWANIE listy/stringa NA OrderDict odbywa się poprzez metodę fromkeys():
				d = OrderedDict.fromkeys('acbbac') 		#OrderedDict([('a', None), ('c', None), ('b', None)])
		*żeby dodać kolejny element na końcu OrderDict lub zmienić kolejność istniejącego uzyj metody move_to_end():
				d.move_to_end('c')						#OrderedDict([('a', None), ('b', None), ('c', None)])
		*a żeby dodać kolejny element ale na początku OrderDict do metody move_to_end() po argumencie dodaj 
		 parametr opcjonalny last=False):
				d.move_to_end('c', last=False)			#OrderedDict([('c', None), ('a', None), ('b', None)])

  **KOLEKCJA namedtuple - POZWALA TWORZYĆ PODRĘCZNE OBIEKTY POSIADAJĄCE TYLKO POLA BEZ METOD. NAMEDTUPLE 
						  DZIĘKI SWOIM METODOM POZWALA KONWERTOWAĆ LISTĘ I DICTIONARY NA TEN WCZESNIEJ 
						  ZDEFINIOWANY OBIEKT. 
						  https://www.geeksforgeeks.org/namedtuple-in-python/
		*namedtule jest idealny jeżeli msz jakiś plik csv (excelowski) i chcesz stworzyć proste obiekty 
		 na ktorych dokonasz jakiś działań
		*Obiekty NAMEDTUPLE są IMMUTABLE
		*musisz pobrać wcześniej moduł collections:
					from collections import namedtuple
		*poprzez swoją specjalną składnię pozwala tworzyć podręczne obiekty do prostych zadan. Obiekty te
		 zawierają tylko pola bez metod. 
		*Składnia polega na tym że w pierwszym argumencie podajesz nazwę obiektu a w drugim podajesz listę
		 nazw argumentów tego obieku lub nazwy argumentów podane jako string, wymienione po spacji albo
		 po przecinku.
			**przykład 1:
					point = namedtuple('Point','x,y')
					pt1 = point(1,3)
					pt2 = point(x=5, y=9)
					sum = pt1.x + pt2.x 				#zwroci 6	
			**przyklad 2:
					Car = namedtuple('Car','Price Mileage Colour Class')
					xyz = Car(Price = 100000, Mileage = 30, Colour = 'Cyan', Class = 'Y')
										#zwroci: Car(Price=100000, Mileage=30, Colour='Cyan', Class='Y')
		*Do poszczególnych pól obiektu namedtuple można się dostać poprzez odwołanie się do numeru pola lub
		 jego nazwy(bez cudzysłowiów):
					from collections import namedtuple
					color = namedtuple("Color",'r g b')
					c1=color(55,155,255)
					print(c1[0])						#zwróci: 55
					print(c1.r)							#zwróci: 55
		*METODY:
			* ._fields() - zwraca krotke wszystkich kluczy takiego obiektu:
					from collections import namedtuple
					Student = namedtuple('Student',['name', 'age', 'indexNumber'])
					s1 = Student('Marek', '24','s14453')
					s1._fields()							#zwroci: ('name', 'age', 'indexNumber')
			* ._replace() - pozwala dostać się do jednego z pól takiego obiektu i zmienić jego wartość:
					print(s1._replace(name='Maciek'))	 
										#zwroci: Student(name='Maciek', age='24',indexNumber='s14453')
			* ._asdict() - pozwala zamienić taki obiekt stworzy poprzez namedtuple na OrderedDict
					s1._asdict()
															#zwróci: OrderedDict([('name', 'Maciek'), 
															('age', '24'), ('indexNumber', 's14453')])
			* ._make(list) - pozwala na przekonwertowanie elementów listy na taki obiekt, Wywołuję się 
							 nią nie na utworzonym obiekcie z obiektu namedtuple tylko na bezpośrednio 
							 namedtuple
					from collections import namedtuple
					Student = namedtuple('Student',['name', 'age', 'indexNumber'])
					lst = ['Andrzej', '34', 's33333']
					Student._make(lst)		#zwroci: Student(name='Andrzej', age='34', indexNumber='')
			* ** [np.: Student(**dict)] - poprzez podanie dwóch gwiazdek i obiektu typu Dictionary mozesz
			                 przekonwertować na obiekt utworzony z obiektu namedtuple. Jedyne co musi się
							 zgadzać to ilośc par i nazwy kluczow który będą takie same jak w obiekcie 
							 namedtuple
					from collections import namedtuple
					Student = namedtuple('Student',['name', 'age', 'indexNumber'])
					dict={ 'name' : "Jurek", 'age' : 19 , 'indexNumber' : '1391997' }
					Student(**dict)			#zwroci: Student(name='Jurek', age='19', indexNumber='1391997')

  **KOLEKCJA ChainMap - TWORZY KONTENER DLA WIELU DICTIONARY
    https://www.geeksforgeeks.org/chainmap-in-python/
		* musisz pobrać wcześniej moduł collections:
					from collections import ChainMap
		* dla wielu obiektów typu Dictionary tworzy kontener i jeżeli chciałbyś się dostać do jakies 
		 wartości odpowiadającej kluczowi to nie musisz znać położenia Dictionary względem innych 
		 Dictonary -> wystarczy że odwołasz się w tym dużym konterze poprzez klucz jednego z Dictionaries
					d1 = {'a': 1, 'b': 2}
					d2 = {'c': 3, 'd': 4}
					c = ChainMap(d1, d2)
					prin( c['a'] )			#zwroci: 1
		* jednakże gdyby klucze się powtórzyły  wróżnych Dictionary to ChainMap zwróci wartość z pierwszego
		 napotkanego klucza
		* Metody znajdziesz na stronce: https://www.geeksforgeeks.org/chainmap-in-python/
	
  **KOLEKCJA deque - LISTA NA KTÓREJ MOŻNA WYKONYWAĆ OPERACJE NIE TYLKO Z PRAWEJ ZTRONY ALE TEŻ Z LEWEJ
					 https://www.geeksforgeeks.org/deque-in-python/
		*ma zdecydowanie lepszą prędkość działania niż zwykła lista. Według Notacji dużego O time complexity
		 dla listy wynosi 0(n) a dla deque wynosi 0(1) czyli tę najlepszą. TIME COMPLEXITY:
		 https://towardsdatascience.com/understanding-time-complexity-with-python-examples-2bda6e8158a7
		*musisz pobrać moduł collections 
				from collections import deque
				queue = deque(['name','age','DOB'])
		*na tego typu liście można dokonywać operacji z dwóch stron, tzn że można nie tylko dodawać na końcu 
		 listy kolejne elementy ale także na początku - działą to tak jak dwustronna kolejka --> by móc to 
		 zrobić to przy odpowiednich metodach musisz z przodu dodać słówko left np.:
			**append(elem)  i  leftappend(elem)
			**pop()  i  leftpop()
		 lub użyć tych specyficznych metod:
			**extend(iterable) - rozszerza listę o podaną w argumencie inną listę lub kolekcję iterowalną
				de = collections.deque([1, 2, 3,])
				de.extend([7,8,9])									#zwroci: deque([1, 2, 3, 7, 8, 9])
			**extendleft(iterable) - rozszerza listę ale z lewej strony odwracając kolejność listy
									podanej w argumencie (lub innej kolekcji iterowalnej) (mozesz tez 
									podać stringa i wezmie każdą literę osobno i appenduję ją na początku
									ale odwracjąc kolejność
				de = collections.deque([1, 2, 3,])
				de.extendleft([7,8,9])					#zwroci: deque([9, 8, 7, 1, 2, 3])
				de.extendleft('234')					#zwróći: deque(['4', '3', '2', 9, 8, 7, 1, 2, 3])
			**rotate(int) - rotuje w zaleznosci od tego jaką liczbę poda się w argumencie 
				de = collections.deque([1, 2, 3, 4, 5 ])
				de.rotate() - domyślnie rotuję o 1 miejsce z prawej strony  #zwroci: deque([5, 1, 2, 3, 4])
				de.rotate(2) - gdy liczba dodatnia to rotuję z prawej strony  #zwroci: deque([4, 5, 1, 2, 3])
				de.rotate(-2) - gdy liczba z ujemna to rotuję z lewej strony bez odwracania kolejnośći:
																			#zwroci: deque([3, 4, 5, 1, 2])
		*możesz też użyć wszystkich pozostałych metod które normalnie działają na listach tzn: 
			**index(elem, begin, end)
			**insert(index, element)
			**remove(element)
			**count()
			**reverse()
			**clear()

###########################  LEKCJA 15 KOLEKCJA DICTIONARY  ##############################################
DICTIONARY INFORMACJE:	https://www.w3schools.com/python/python_dictionaries.asp
DICTIONARY METODY:		https://www.w3schools.com/python/python_dictionaries_methods.asp

1* KOLEKCJA DICTIONARY (SLOWNIK) [w Javie jest to MAPA] 
	*nie pozwala na duplikaty kluczy (wartości już tak); można Modyfikować; i jest to kolekcja
	 uporządkowana (klucze są zaindeksowane)(od wersji PYTHON 3.7 -> we wcześniejszych wersjach 
	 klucze nie były zaindeksowane i cała kolekcja była jak zbiór(nieuporządkowana)
	 !!!!!!! de facto jest tak pół na pół = lepiej traktować domyślnie jako nieuporządkowany
	*składa się z pary wartosci ==> klucza i wartosci
	*utworzenie pustego słownika odbywa się poprzez:
				dictionary=dict()
				dictionary={}							#takie coś NIE deklaruje pustego SETu
	*tworzymy troche jak przy liscie ale zamiast nawiadow kwadratowych sa wasowe
				slownik = {1: "poniedzialek", 7: "niedziela", 4: "czwartek"}
	*bez koniecznosci definiowania jednego typu znakow zarowno dla klucza jak i dla wartosci
				slownik = {1: "pon", "a": "nd", "c": False, True: 4}
				print(slownik) 			[otrzymasz cala kolekcje slownik - klucze i wartosci]
	*jezeli chcesz sie dostac do jakiegos elementu dictionary to nie musisz wpisywac nawiasow 
	 wasowych tylko wystarcza kwadratowe tak jak przy liscie 
		**JEDNAKZE zeby dostac sie do jakies wartosc to w tych nawiasach kwadratowych 
		  nie wpisujesz numeru elementu slownika (tak jak przy liscie) tylko wpisujesz klucz 
				print(slownik[1])
				print(slownik["a"])
		**jezeli przy wywolaniu dany klucz nie istnieje to wyskakuje blad KeyError
		  dlatego lepiej uzywac funkcji get(klucz,"tresc wyswietlona jezeli klucz nie istnieje")
				print(slownik.get(1,"podany klucz przez CB nie istnieje")
	*mozesz przekonwertować dane elementy na słownik ale wtedy muszą to być pary (pary w listach 
	 albo krotkach) w głównej liście:
				listOfLists= [[1,2],[3,4]]
				print(dict(listOfLists))		#zwroci: {1: 2, 3: 4}
	*dict() - ta konwersja musi się odbyć na przypisywanych elementach poprzez konstruktor dict():
				myDict=dict(name="Mary", age="27", city="Boston");		
												#zwróci: {'name': 'Mary', 'age': '27', 'city': 'Boston'}
			  w tym że konstruktorze nazwy kluczy nie musisz zawierać w cudzysłowach, jadnekże gdybyś
			  chciał dodać nowe wartości to odwołując się do nowego klucza (który nie jest liczbą) (co 
			  jest próbą dodania nowego elementu do słownika) już musisz użyć czudzysłowa:
				myDict["zmienna"] = "wartość"
	*tak jak w listach możesz stworzyć słownik poprzez Dictionary Comprehension:
				squares = {x: x*x for x in range(6)}  #zwroci:{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
	*jeżeli chcesz wypisać jakiś element po kluczu i ten klucz nie będzie istniał to wyskoczy 
	 ci błąd KeyError
 **FUNKCJE DICTIONARY:
 https://www.w3schools.com/python/python_dictionaries_methods.asp
	*słowo kluczowe in pozwala sprawdzić czy dany klucz istnieje w kolekcji:
				if "brand" in thisdict:
					print("yes")
	*get(klucz,"tresc wyswietlona jezeli klucz nie istnieje")- możliwośc dostania się do wartości 
			poprzez klucz i jeżeli taki klucz nie istnieje to NIE wyskoczy ci ERROR
						[PODANIE DRUGIEGO ARGUMENTU W METODZIE GET powoduje że 
						     NIE WYSKAKUJE ERROR gdy klucz nie istnieje]
				x = thisdict.get("model")
				x = thisdict.get("model","klucz nie istnieje")
				x = thisdict.get("model",0)  #ze wzgledu na czeste wykorzystywanie dictionary
											 #do histogramu najlepiej w drugim opcjonalnym
											 #argumencie wpisac 0 jako domyslna uzyta/wyswietlona
											 #wartosc do klucza żeby wyswietlilo sie że do klucza
											 #podanego mamy 0 pasujacych wartosci
											 
				dictionary = {"marek": 1, "arek":2}
				dictionary2= {"marek": 1}
				for nameDict1 in dictionary:
					dictionary2[nameDict1] = dictionary2.get(nameDict1,0)+1
				print(dictionary2)			 #zwroci: {'marek': 2, 'arek': 1} mimo że wczesniej 
											 #klucz "arek" w dictionary2 nie istniał - a gdybys
											 #chcial sie odwolac do klucza ktory nie istnieje 
											 #poprzez nawiasy kwadratowe to mialbys error
		
		**PRZYPISANIE LISTY do DICTIONARY ZAWIERAJĄCEJ WARTOŚCI:
				lista = ["marek", "arek"]
				dictionary= {"marek": 1}
				for name in lista:
					dictionary[name] = dictionary.get(name,0)+1
				print(dictionary)			 #zwroci: {'marek': 2, 'arek': 1} mimo że wczesniej
											 #klucz "arek" w dictionary nie istniał  -> tak 
											 #powinno wygladac przypisanie listy do juz wczesniej
											 #stworzonej kolekcji dictionary ktora ma juz jakies
											 #wartosci wewnatrz
											 
	*keys() - zwraca listę wszystkich kluczy w kolekcji dictionary
				x = thisdict.keys()
	*values() - zwraca listę wszystkich wartości w kolekcji dictionary
				x = thisdict.values()
	*items() - zwraca liste par(klucza i wartosci) zapisanych jako krotki
				x = thisdict.items()	 #zwraca: dict_items([('brand', 'Ford'), ('year', 1964)])
	*pop('key') - usuwanie elementow ze slownika po kluczach przy pomocy funkcji pop("klucz")
				slownik.pop(1)	
						[jezeli dany element nie istnial to nie wyswietli sie zaden blad]
	*popitem() - usuwa ostatnio dodaną parę do kolekcji (przed wersją 3.7 usuwana jest losowa wartość):
				thisdict.popitem()
	*del dict["key'} - usuwa konkretna pare o podanym kluczu
				del thisdict["model"]
	*del dict - usuwa cała kolekcję dictionary
				del thisdict
	*clear() - pozostawia cała kolekcję pustą:
				thisdict.clear()
	*copy() - w pythonie nie wyjdzie ci kopiowanie poprzez przypisanie jednej kolekcji do innej 
		**jedna opcja to kopiowanie poprzez metodę copy():
				dict2 = thisdict.copy()
		**druga opcja to przekonwertowanie kolekcji Dictionary na kolekcje Dictionary:
				dict2 = dict(thisdict)
	*sort() - w słowniku możesz posortować nie tylko przez metodę sorted ale przez zwykła metodę sort()
	 tak samo tylko musisz podać parametr key i przypisanć do niego lambdę
				temps=[("Berlin",29),("Cairo",36),("Buenos Aires",19),]
				temps.sort(key=lambda x: x[1])		
				print(temps)			#zwróci: [('Buenos Aires', 19), ('Berlin', 29), ('Cairo', 36)]
	*update({key:value, key2:value2}) - update'owanie poprzez dodanie do starej kolekcji Dictionary nowej 
	 kolekcji Dictionary Jeżeli wcześniej dany klucz nie istniał to nowa para zostanie dodana do kolekcji 
	 a jeżeli istniał to wartość zostanie nadpisana. Robi się to głównie update'ując słownik słownikiem
	 składającym się z wielu par elementów.
				thisdict = { "brand": "Ford", "model": "Mustang", "year": 1964}
				thisdict.update({"year": 2020, "age": 22})
	*dla pojedyńczych kluczy update'uje się elementy poprzez wywołanie kolekcji z kluczem oraz przypisaniu 
	 jej nowej wartosci.
				thisdict = { "brand": "Ford", "model": "Mustang", "year": 1964}
				thisdict["year"] = 2018			
	*dodawanie nowych wartosci nastepuje poprzez wywolanie elementu po kluczu ktory jeszcze 
	 nie istnieje (jezeli istnieje to wartosc zostanie nadpisana) 
				slownik[3] = "sroda"		   [klucz 3 w kolekcji slownik wczesniej nie istnial]
		**dodawanie do slownika nie odbywa sie w sposob sortujacy - po prostu na samym koncu
	 JEZELI klucz istnieje ale nie ma wartości to skorzystaj z metody append():
		**żeby dodać do istniejącego klucza bez wartości, wartość 
				my_dict = {"Name":[],"Address":[]};
				my_dict["Name"].append("Guru")			#zwroci: {'Name': ['Guru'], 'Address': []}
		**żeby dodać do istniejącego klucza kolejną wartość - tak że stworzy się z tego lista wartości
				my_dict = {"Name":[],"Address":[],"Age":[]};
				my_dict["Name"].append("Dupus")			#zwroci: {'Name': ['Guru','Dupus'], 'Address': []}
		**w kolekcji Dictionary musi istniec klucz zeby zaapendowac mu wartosc - inaczej zwroci KeyError
							
	*PRZEJŚCIE po CAŁYM SLOWNIKU w petli FOR bedzie iterowane domyślnie po kluczach:
				for key in slownik
				print(key, slownik[key])			#wyswietli klucz i wartosc
		**JEDNKAZE przejscie po wszystkich elementach kolekcji mozna zmienic tak by odbywalo sie 
		  to przez wartosci albo na sztywno ustawic na klucze: slownik.values() lub slownik.keys()
				for l in slownik.values()
					print(l)
		**jako iterator możesz też uczynić całą parę przy pomocy funkcji items()
				for x,y in slownik.items():
					print(x,y)
	*fromkeys('mylist') - poprzez funkcje fromkeys() można też przekonwertować listę na słownik:
				dict.fromkeys(mylist)
	*możesz też zagnieździć kolekcję dictionary w kolekcji dictionary:
				child1 = {"name" : "Emil","year" : 2004}
				child2 = {"name" : "Tobias","year" : 2007}
				child3 = {"name" : "Linus","year" : 2011}
				myfamily = { "child1" : child1, "child2" : child2, "child3" : child3}
				print(myfamily)
				
2* DICTIONARY ZRODZONE Z LISTY:
	*w większości wykorzystuję się do histogramów  i przedstawienia ile razy wystepuje 
	 dany klucz - tę ilosc razy wyraza wartosc. Przy Dictionary następuję częste zliczanie jakies
     wartosci listy ktorej elementy sa pozniej traktowana jako klucz do dictionary gdzie wartosc 
	 wyraza ilosc wystapien danego elementu w liście - takie dopisywanie listy do Dictionary 
	 odbywa sie poprzez metode get (gdy klucz wczesniej nie istnial to zostaje stworzony i 
	 dodaje mu sie wartosc 1 a jezeli istnial to do istniejacej odpowiadajacej mu wartosci 
	 dodaje sie + 1:
   	*PRZYPISANIE LISTY do DICTIONARY ZAWIERAJĄCEJ WARTOŚCI - PRZYKŁAD:
				lista = ["marek", "arek"]
				dictionary= {"marek": 1}
				for name in lista:
					dictionary[name] = dictionary.get(name,0)+1
				print(dictionary)			 #zwroci: {'marek': 2, 'arek': 1} mimo że wczesniej
											 #klucz "arek" w dictionary nie istniał  -> tak 
											 #powinno wygladac przypisanie listy do juz wczesniej
											 #stworzonej kolekcji dictionary ktora ma juz jakies
											 #wartosci wewnatrz
		**przypisanie nowego klucza ktory wczesniej nie istnial do dictionary (nie ma Errora)
				dictionary[niestniejacyKlucz] = wartosc			#dodano nowy klucz do Dictionary
		**odwołanie sie do klucza ktory wczesniej nie istnial przez nawiasy kwadratowe
		  spowoduje ERROR --> jedyne dobre odwołanie sie poprzez metode get z drugim argumentem
				print(dictionary[nieistniejacyKlucz]) 			#!!!ERROR!!!
				print(dictionary.get([nieistniejacyKlucz],0) 	#!brak errora!
	*IDEALNY przykład zadania wykorzystującego ten schemat to zliczanie slow w tekscie. Tekst 
	 zamienimy na liste słów i nastepnie stworzymy kolekcje dictionary gdzie slowa beda kluczami
	 glownymi a wartosciami bedzie liczba wystapien danego slowa
				words =list()
				dictionary = dict()
				try:
					fname = input("Enter the file name: ")
					file = open(fname,"r")
					for line in file:
						words.extend(line.split())
					for word in words:
						dictionary[word]=dictionary.get(word,0)+1
				except ValueError: print("No such file try again")
				except: print("other bug")
				print(dictionary)	
		*żeby znaleźć teraz najwiekszą liczbę danego słowa w tekscie wystarczy przejść po całej 
		 kolekcji wykorzystując funkcję items() ktora pozwoli miec jednocześnie dwa iteratory:
		 klucz i wartość --> jeżeli ktoras wartość będzie większa niż ta najwieksza (zapisana 
		 w oddzielnej zmiennej) to zostanie zmieniona wartość na nową(największą) i klucz na ten
		 odpowiadający wartości:
				words =list()
				dictionary = dict()
				fname = input("Enter the file name: ")
				file = open(fname,"r")
				for line in file:
					words=line.split()
					for word in words:
						dictionary[word]=dictionary.get(word,0)+1
				bigwordCount=None
				bigkey=None
				for word, wordCount in dictionary.items():
					if bigwordCount is None or bigWordCount<wordCount:
						bigWordCount=wordCount
						bigkey=word
				print(bigkey, bigWordCount) 	#LUB
				print(dictionary[bigkey])
		*jednakże przy zwyklej funkcji split tekst zostanie nam rozdzielony na slowa ale separatorem
		 bedzie jedynie spacja i enter, wyrazy ze znakami interpunkcyjnymi zostaną policzone
		 jako osobne słowa w sosunku do tych bez znaków interpunkcyjnych chociaz mogą to być te 
		 same słowa np: "soft" i "soft!" dlatego powinines użyć funkcji translate na całym tekscie
		 (albo na danej lini) 
			line.translate(str.maketrans(fromstr, tostr, deletestr))	
							#fromstr i tostr mogą pozostać puste a w deletestr musisz podac znaki 
							 interpunkcyhjne ktore jeste w stanie pobrac z modułu string --> 
							 string.punctuation  #: ['!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~']
			import string
			line = line.translate(line.maketrans('', '', string.punctuation))
			PRZYKLAD:
				words =list()
				dictionary = dict()
				fname = input("Enter the file name: ")
				file = open(fname,"r")
				for line in file:
					line.lower()			#jeszcze zmniejsz litery żeby slowa z duzymi literami
											#byly liczone jak te z malymi literami
					import string
					line.translate(line.maketrans("","",string.punctuation))
					words=line.split()
					for word in words:
						dictionary[word]=dictionary.get(word,0)+1
				bigwordCount=None
				bigkey=None
				for word, wordCount in dictionary.items():
					if bigwordCount is None or bigWordCount<wordCount:
						bigWordCount=wordCount
						bigkey=word
				print(bigkey, bigWordCount) 	#LUB
				print(dictionary[bigkey])
		*to co nam zostaje to posortowanie całego słownika względem klucza albo wartosci - 
		 domyślnie sortowanie metodą sorted() jest ascending czyli rosnące ale możesz też
		 zrobic zmniejszające decending poprzez wpisanie drugiego argumentu reverse=True
				sorted(lista,reverse=True)
	https://www.py4e.com/html3/10-tuples
		  *SOROTOWANIE PO KLUCZACH --> uzyjemy funkcji sorted której w argumencie podamy 
		   liste krotek stworzoną ze słownika (za pomocą funkcji items() (możemy tez na tej
		   zwroconej liscie krotek zmiast sorted uzyc funkcji sort())
				print(sorted(dictionary.items()))		
							#zwroci posortowaną listę krotek dwuelementowych (odpowiadajacych 
							 kluczowi i wartosci w słowniku przed uzyciem metody items())
		  *SORTOWANIE PO WARTOŚCIACH --> ponieważ nie ma na to żadnej metody trzeba najpierw
		   wykorzystać tymczasową liste do ktorej przepiszesz dwuelementowe krotki (ze zmianą 
		   kolejności klucza i wartosci czyli (wartosc, klucz). Nastepnie uzyjesz na tej 
		   tymczasowej liscie metody sorted (albo zwyklej metody sort) a nastepnie stworzysz 2gą 
		   tymczasową listę do której przepiszesz te krotki ale według schematu (klucz, wartość)
		   zamiast (wartosc, klucz):
				tmp=list()
				for key,value in dictionary.items():
					newTuple=(value,key)
					tmp.append(newTuple)
				tmp=sorted(tmp)
				tmp2=list()
				for value,key in tmp:
					newTuple=(key,value)
					tmp2.append(key,value)
				print(tmp2)
		   ***TAKIE SORTOWANIE DA SIĘ ZASTĄPIĆ JEDNĄ LINIJKA KODU:
						listaKrotek = sorted([(v,k) for k,v in dictionary.items()]) 
		   ***ORAZ MOŻNA UŻYĆ DEDYKOWANEJ FUNKCJI SORTED gdzie należy wpisac klucz (key) poprzez
		      funkcje odpowiadającą za wyszukanie klucza i (to wszystko podac jako drugi argument)
			  oraz można podać 3ci argument czy ma ta byc sortowanie malejące (descending) 
			  [reverse = True]:  https://careerkarma.com/blog/python-sort-a-dictionary-by-value/
						listaKrotek = sorted(tuple, key= lambda x: x[1], reverse=True)
						listaKrotek = sorted(dictionary.items(), key= lambda x: x[1], reverse=True)
			  #(WIĘCEJ w dziale BUILT-INS)
3* DICTIONARY COMPREHENSIONS:
				numbers = list(range(10))
				liters = ['a','b','c','d','e','f','g','h','i','j','k','l']
				myDict = {l:n for l,n in zip(numbers, liters)}
												#zwróci:{0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 
														 5: 'f', 6: 'g', 7: 'h', 8: 'i', 9: 'j'}
		 
####################### LEKCJA 24 KOLEKCJA SET | OPERATORY NA ZBIORACH #########################
SET INFORMACJE:			https://www.w3schools.com/python/python_sets.asp
SET METODY:				https://www.w3schools.com/python/python_sets_methods.asp
SET METODY USUNIECIA: 	https://www.w3schools.com/python/python_sets_remove.asp
SET METODY ŁĄCZENIA:	https://www.w3schools.com/python/python_sets_join.asp

1* ZBIORY
    *WLASCIWOSCI SETU:
		*elementy sie nie powtarzaja
		*można modyfikować (dodawać, usuwać) ale ponieważ elementy są nieuporządkowane (czyli:
		 niezaindeksowane) to nie można usunąc albo zmodyfikować na konkretnego indeksu
		 gdyż taki nie istnieje - dlatego trzeba uważać na metode .pop() która usuwa wartosc o 
		 ostatnim indeksie (czyli akurat jak zbiór sobie uporządkuje)
		*ma nieuporzadkowane elementy chyba ze dodasz liczbe przy pomocy metody add() to ci
		 uporzadkuje od najmniejszej do największego
		*jak we wszystkich kolekcjach mozesz mieszac typy danych w jednej kolekcji
    
	*Mozliwosci stworzenia zbioru:
		*utworzenie pustego setu:
				s=set()										#{} - takie coś to pusty słownik
		*przypisanie liczb w nawiasach klamrowych
				liczby1 = {3,43,6,4}
				print(liczby1)
        *przekonwertowanie listy na typ zbioru(set)
				slowa = ["ggag","aa","dda"]
				slowa = set(slowa)
				print(slowa)
		*uzycie konstruktora set():
				thisset = set(("apple", "banana", "cherry"))
												#pamiętaj o podwójnych okrągłych nawiasach 
												zamiast okrągłych i wąsowych w środku
	
	*METODY:
	https://www.w3schools.com/python/python_ref_set.asp
		  *nia ma takich metod jak insert albo append tylko SET ma swoje indywidualne
	https://www.w3schools.com/python/python_sets_join.asp
		*add() - dodaje do zbioru, jezeli dodasz wartosc ktora jest w zbiorze to nie wywali 
		 ci bledu tylko nic sie nie stanie
				liczby1.add(111)
		*update() - pozwala połączyć 2 zbiory ze sobą (biorac z nich sumę) poprzez zainsertowanie
		 jednego zbioru w drugi (ten który jest w nawiasie jest insertowany) - wybierajac tylko 
		 niepowtarzające sie elementy;;  [to niekoniecznie muszą być dwa zbiory - może być zbiór 
		 i jakakolwiek inna kolekcja]
				set1 = {"apple", "banana", "cherry"}
				set2 = {"pineapple", "mango", "papaya"}
				set1.update(set2)
				print(set1)
				#2ga opcja:
				mylist = ["kiwi", "orange"]
				set1.update(mylist)
				print(set1)
		*union() - pozwala połączyć dwa zbiory ze sobą dając 3 zbiór jako zwrotkę (biorać z 
		 nich sumę) - wybierajac tylko niepowtarzające sie elementy;;  [to niekoniecznie muszą 
		 być dwa zbiory - może być zbiór i jakakolwiek inna kolekcja]
				set1 = {"a", "b" , "c"}
				set2 = {1, 2, 3}
				set3 = set1.union(set2)	
		*intersection_update() - zatrzymuje tylko duplikaty z dwóch kolekcji na pierwszym zbiorze
		 (bierze z dwóch zbiorów iloczyn)
				x = {"apple", "banana", "cherry"}
				y = {"google", "microsoft", "apple"}
				x.intersection_update(y)
				print(x)
		*intersection() - zwraca trzeci zbiór w którym są tylko duplikaty z pierwszego i 
		 drugiego zbioru, (bierze z dwóch zbiorów iloczyn):
				x = {"apple", "banana", "cherry"}
				y = {"google", "microsoft", "apple"}
				z = x.intersection(y)
				print(z)
		*difference() - jako odejmowanie od pierwszego zbioru drugiego
				x = {"apple", "banana", "cherry"}
				y = {"google", "microsoft", "apple"}
				z = x.difference(y)
				print(z)				#zwroci: {"banana", "cherry"}
		*symmetric_difference_update() - zostawia te elementy które nie duplikują się w dwóch 
		 zbiorach - wszystko robi na pierwszym zbiorze (bierze odwrotność iloczynu):
				x = {"apple", "banana", "cherry"}
				y = {"google", "microsoft", "apple"}
				x.symmetric_difference_update(y)
				print(x)
		*symmetric_difference() - zwraca 3ci zbiór który składa się z elementów które nie 
		 duplikują się w dwóch zbiorach (bierze odwrotność iloczynu): 
				x = {"apple", "banana", "cherry"}
				y = {"google", "microsoft", "apple"}
				z = x.symmetric_difference(y)
				print(z)
		*issubset() - zwraca True gdy set na którym jest wywoływana jest w zbiorze podanym w argumencie
				set1.issubset(set2)
		*issuperset() - zwraca True gdy zbió zawiera wszsytkie elementy jakiegoś innego zbioru (de facto 
		 podzbioru)
				set2.issuperset(set1)
	https://www.w3schools.com/python/python_sets_remove.asp
		*remove('element') - (usuwajaca po elemencie a nie po indexie); jeżeli element nie istnieje
		 to wyskoczy ERROR:
				liczby1.remove(3)
		*discard('element') - usuwajaca po elemencie a nie po indexie); jeżeli element nie istnieje
		 to NIE wyskoczy ERROR (tym się różni od metody remove():
				liczby1.discard('element')
		*pop() - usuwa ostatni eelement w zbiorze a ponieważ zbiór nie jest zaindeksowany to 
         usunie ci losową wartość - tę która akurat będzie ostatnia
				liczby1.pop()
		*clear() - czyści cały zbiór tak że zostaje pusty:
				thisset.clear()
		*del - słowo kluczowe del usuwa cały zbiór bezpowrotnie:
				del liczby1
	*OPERATORY w OPERACJACH NA ZBIORACH:
				liczby1 = {3,43,6,4}
				liczby2 = {3,4,5,6,7}
		*OPERATOR SUMY - liczby ze zbioru 1go i 2go nie powtarzajac wartosci wspolnych
				print(liczby1 | liczby2)
		*OPERATOR ILOCZYNU - liczby powtarzajac sie w zbiorze 1wszym i 2gim
				print(liczby1 & liczby2)
		*OPERATOR ROZNICY '-' - liczby ze zbioru 1go ktore nie powtarzaja sie w zbiorze 2gim
				print(liczby1 - liczby2)
		*OPERATOR ROZNICY SYMETRYCZNEJ '^' - liczby ze zbioru 1go i 2go ktore nie wystepuja 
		 zarowno w 1wszym jak i 2gim zbiorze. Jest to odwrotnosc OPERATORA ILOCZYNU
				print(liczby1 ^ liczby2)
		*tak jak kazda funkcja na SETcie moze być rozszerzona o końcówkę _update() czyli zamiast 
		 tworzyć nowy zbiór z dwóch które zostały podane jako argumenty to zostanie zmodyfikowany 
		 zbiór na którym zostałą wywołana funkcja - można to zrobić poprzez lekką modyfikację operatora: 
		 wystarczy za operatorem postawić znak przypisania (=)
				.update() or |=   
				.intersection_update() or &= 
				.difference_update() or -=
				.symmetric_difference_update() or ^=
	*FROZENSET - ziór który jest niemodyfikalny:
				set2=frozenset([1,2,3,4])
				print(set2)

####################### LEKCJA 16 KOLEKCJA TUPLE - KROTKA i SEKWENCJE #########################
https://docs.python.org/3/library/stdtypes.html#mutable-sequence-types
KROTKA INFORMACJE:		https://www.w3schools.com/python/python_tuples.asp
KROTKA METODY:			https://www.w3schools.com/python/python_tuples_methods.asp

1* KROTKA:
	*pozwala na duplikowanie elementow i na ich rozne typy, jest uporządkowana (zaindeksowana) 
	 ALE NIE POZWALA na MODYFIKOWANIE ELEMENTOW (dodawanie, usuwanie, zmienianie kolejnosci) 
	*uzywa się jej zamiast listy ze względu na EFFICENCY (efektywnosc):
		*zajmują mniej miejsca
		*szybciej się dostac do jej elementów niż do listy
	*ma to też swoje wady gdyż krotki nie możesz wykonywać na niej wielu funkcji które 
	 móglbyś srobić na liście - nie możesz jej sortować, dodawać wartości, zmieniać ich wartości,
	 zamieniać kolejności - niczego co wjakiś sposób modyfikuję wartości
	*puste krotka:
				t=tuple()
				t=()
	*tworzy sie poprzez nawiasy okragle a nie kwadratowe ani wasowe
				krotka =(2,7,7,"erferg",7,True,10)
				print(krotka) 	[wyswietli wszystkie elementy krotki]
	*można stworzyć krotke także poprzez konstruktor:
				thistuple = tuple(("apple", "banana", "cherry"))
												#pamiętaj o podwójnych okrągłych nawiasach
 	*można zrobić KROTKE ZMIENNYCH ktore będą miały PRZYPISANE WARTOŚCI do INNEJ KROTKI 
	 o tej samej ilości elementów lub do INNEJ LISTY (działą to trochę jak Dictionary ALE
	 SĄ TO CAŁY CZAS ZMIENNE) 
				(x,y) = (4,'fred')
				print(y)  #wyświetli się: fred	
				(x,y) = [4,'fred']
				print(y)  #wyświetli się: fred	
				
	*wywolanie elementow kolekcji TUPLE odbywa sie tak samo jak przy liscie czyli po numerze 
	 elementu liczonego od zera
				print(krotka[3])
	*jeśli chcesz stworzyć KROTKE Z JEDNYM ELEMENTEM to musisz po elemencie wpisac przecinek ->
	 inaczej Python nie rozpozna tego jako krotki a jako zwykłą zmienną
				thistuple = ("apple",)
		*jeśli do krotki z jednym argumentem dasz stringa i zrobisz to poprzez wywołanie 
		 konstruktora to dostaniesz krotke jego pojedynczych znakow:
				t=tuple("slowo") 	#zwroci: ('s','l','o','w','o')
		 dlatego jeśli chcesz stworzyć krotke z jednym argumentem to musisz dac przecinek na 
		 koncu:
				t=tuple("slowo",)	#zwroci: ('slowo')
	*jeżeli masz zamiar przetwarzać jakąś kolekcję której nie masz zamiaru modyfikować to używaj
	 krotki zamiast listy ponieważ jest około 20% bardziej wydajniejsza niż lista ze względu na to 
	 że zajmuję mniej miejsca:
				t=("mac",28,3,4,5,"sfsdf",6,"bost")
				l=list(t)
				import sys
				print(sys.getsizeof(t),"bytes")		# 64 bytes
				print(sys.getsizeof(l),"bytes")		# 80 bytes
	 a ponadto przy tworzeniu wielu milionów list i krotek krotka tworzy sie 10 razy szybciej:
				import timeit
				print(timeit.timeit(stmt="[1,2,3,4,5,6,7]",number=1000000))			# 0.11065
				print(timeit.timeit(stmt="(1,2,3,4,5,6,7)",number=1000000)) 		# 0.01528
				
	*FUNKCJE KROTKI:
	https://www.w3schools.com/python/python_tuples_methods.asp
		*krotka nie ma funkcji do appendowania, insertowania, modyfikowania, usuwania elementow
		 GDYŻ w krotce NIE MOZNA modyfikowac elementow 
		*krotkę można stworzyć nie tylko poprzez nawiasy okrągłe (chociaż jest to dobra praktyka)
		 ale także bez tych nawiasów (chocią nie powinno się tak robić):
				my_tuple = 3, 4.6, "dog"
				print(my_tuple)				#zwróci: (3, 4.6, 'dog')
		*count('element') - sluzy do zliczenia ilosc wystpaien podanego elementu
				print(krotka.count(7))
		*index('element') - zwroci pierwszy napotkany numeru indexu podanego elementu
		*del('krotka')  - usuwanie krotki
		*MODYFIKOWANIE KROTKI - odbywa się poprzez zamianę krotki na listę, modyfikacji i zamiany
		 listy na krotke (już z modyfikacjami:
				x = ("apple", "banana", "cherry")
				y = list(x)
				y[1] = "kiwi"
				x = tuple(y)	
		 ALBO MODYFIKOWANIE POPRZEZ ZASTEPOWANIE WYRAZOW JEDNEJ KROTKI INNĄ KROTKĄ (POJEDYŃCZĄ):
		 (modyfikowanie poprzez przypisowanie wartosci jakiemus indexowi jest zakazane, tak 
		 samo jak zmiana kolejnosci w krotce):
				t = ('a', 'b', 'c', 'd', 'e')
				t = ('A',) + t[1:]
				print(t)				#zwroci:('A', 'b', 'c', 'd', 'e')
		*DODAWANIE NOWYCH ELEMENTÓW W KROTCE - odbywa się poprzez dodawanie się krotek - czyli 
		 trzeba do swojej krotki stworzyć jednoelementową krotkę i połaczyć te krotki ze sobą
			thistuple = ("apple", "banana", "cherry")
				y = ("orange",)
				thistuple += y
		*PORÓWNYWANIE CAŁYCH KROTEK - beirze wartości od lewej do prawej - porównuję tylko 
		 wartości o najmniejszym indexie i na tej podstawie zwraca True albo False (jeżeli 
		 wartości są takie same to sprawdza kolejny index w dwóch krotkach i na tej podstawie
		 zwraca True albo False
				(1,20,30)<(0,1,1)							#zwróci True
				(1,20,30)<(1,20,33)							#zwróci True
				('Jones','Sam')>('Jones', 'Sally')			#zwróci False
											#przy slowach sprawdza każdą pojedyńczą literkę
		*PRZEJSCIE PO LIŚCIE KROTEK GDZIE MASZ WIELE ITERATORÓW (WIĘCEJ patrz dział pętla FOR):
				b=('r',10,22)
				c=('g',33,21)
				list_of_tuples=[b,c]
				for m1,m2,m3 in sorted(list_of_tuples):
					print(m1,m2,m3)
		*SORTOWANIE WIELU KROTEK - wiedzac że możemy porównywać krotki o tej samej ilosci 
		 elementów to możemy też je POSORTOWAĆ względem elementów od lewej do prawej. Najpierw 
		 ze wszystkich krotek trzeba stworzyć liste a następnie posłużyć się nią jako argument
		 do funkcji sorted (lub na tej liscie  wywołąć funkcje sort()) (WIĘCEJ W BUILT-INS'ach)
		*PRZYPISANIE ELEMENTÓW DO KROTKI - w jednej linijce tekstu mozna przypisac kazdemu
		 elementowi krotki jakąs wartość:
				(x,y,z) = (10,20,30)		ALBO:
				(x,y,z) = [10,20,30]		ALBO: w jednej linijce mozna dokonac zamiany wartosci
												  miedzy zmiennymi w krotce:
				(x,y,z) = (y,z,x)					
		*DODATKOWE OPERACJE NA KROTKACH 
			- mozesz dodawac ze sobą krotki: tuple3 = ("a", "b" , "c") + (1, 2, 3)
			- możesz mnożyć krotkę przez liczbę (wtedy będziesz mieć 2 razy powtorzone elementy):
				fruits = ("apple", "banana", "cherry")
				mytuple = fruits * 2	
							#[zwróci: ("apple", "banana", "cherry", "apple", "banana", "cherry")
						
				
####################### LEKCJA 7 i 17 | KOLEKCJA: LISTA | LIST COMPREHENSION ###################
METODY LISTA: 			https://www.w3schools.com/python/python_ref_list.asp
LISTY INFORMACJE:		https://www.w3schools.com/python/python_lists.asp
LIST COMPREHENSIONS: 	https://www.w3schools.com/python/python_lists_comprehension.asp

LISTA:
	*lista to kolekcja która pozwala duplikować elementy, jest uporządkowana i możliwa do zmiany
	*lista nie ma ograniczonej wielkosc tak jak w tablica; sa przez to bardziej dynamiczne 
	*liste mozna zadeklarować wcześniej bedzie wtedy pusta poprzez stworzenie obiektu listy 
			lista = []
			lista = list()
	*jedna lista moze przechowywac wszystkie typy danych [liste mozemy zakonczyc przecinkiem]
			lista = [1,'c',"d",4]
			lista = [1,'c',"d",4,]
	*listy sa indexowane od 0 i koncza sie jeden mniej niz dlugosc [jak przy tablicach]
	*możemy stworzyc obiekt listy poprzez konstruktor:
			thislist = list(("apple", "banana", "cherry")) 
												#pamiętaj o ppodwójnych okrągłych nawiasach 
												zamiast okrągłych i kwadratowych w środku
	*możemy dostac się do elementów listy poprzez indexy (pozytywne i negatywne i wycinki):
			thislist[0] - pierwszy element
			thislist[-1] - ostatni element
			thislist[2:5] - od 3ego elementu do 5tego (2gi index do 4indexu)
			thislist[-4:-1] - od 4rgo elementu od końca do przedostatniego 9ostatni się nie liczy)			
	*mozemy wypisac wszystkie elementy listy lub jej dany element
			print(lista)
			print(lista[3])		
	*funkcja range - ZWRACA LISTE liczb o podanej wielkosci i parametrach tych liczb]	
	*string jest przechowywany jako lista znakow i mozna sie odwolac do jakiegos jego elementu
	 poprzez liste
			tekst = "mama lubi kota"
			print(tekst[3])
	*mozemy dynamicznie laczyc ze soba listy (to nie jest zagnieżdzanie) poprzez '+' 
	 lub metode extend() (patrz metody do listy):
			print(lista + ["a", 3])
	*możemy zagnieżdzać listę w liście 
			lista.append(["a", "v", "eee"])
	*mozemy mmnozyc listte przez jakas ilosc elementow:
			print(lista*3)
	*możęmy łąćzyć kilka list w jedną listę oprzez znak plusa (+):
			lst1=[1,2,3,4]
			lst2=[1,2,3,4]
			lst3=lst1 + lst2			#[1,2,3,4,1,2,3,4]		
	*mozesz tez przekonwertowac jakis obiekt na liste:
			print(list("slowo"))		#wynik: [s,l,o,w,o]
			print(list(range(10))) 		#wynik: [0,1,2,3,4,5,6,7,8,9]
	*by zamienić jakiś elementelementy w liscie na inny element/elementy to korzystasz z wycinek:
			thislist[1] = "blackcurrant"					- zamiana 1nego elementu na 2gi
			thislist[1:3] = ["blackcurrant", "watermelon"]	- zamiana 2wóch elementów na 2
			thislist[1:3] = ["watermelon"]					- zamiana 2wóch elementów na 1
			thislist[1:2] = ["blackcurrant", "watermelon"]	- zamiana 1dengo elementu na 2 
						[w ostatnim elemencie będziesz miał zainsertowanie ponadprogramowego 
						 elementu jeden index dalej niz ten poprzedni zainsertowany]
	*by usunąć duplikaty elementów w liscie musisz najpierw przekonwertować kolekcje na słownik 
	 poprzez metode dict.fromkeys(mylist) [w ten sposob usuniesz duplikaty] a nastepnie musisz 
	 na nowo przekowertowac ten slownik na liste:
			mylist = ["a", "b", "a", "c", "c"]
			mylist = list( dict.fromkeys(mylist) )
			print(mylist)
	*PRZEJSCIE PO LIŚĆIE KROTEK GDZIE MASZ WIELE ITERATORÓW (WIĘCEJ patrz dział pętla FOR):
			b=('r',10,22)
			c=('g',33,21)
			list_of_tuples=[b,c]
			for m1,m2,m3 in sorted(list_of_tuples):
				print(m1,m2,m3)
											
		
	*LISTA TO OBIEKT ktory ma swoje METODY - MEOTDY TE NIE ZWRACAJĄ LISTY (to są VOIDy) przez 
	 co nie można na nich wykonywać innych operacji np przypisania i łaćzyć ich w jednej linijce:
		*APPEND - dołączanie do listy (znakow lub liczb ORAZ innych list->zagniezdzanie listy 
				  w liscie)
					lista.append("x")
					lista.append(["a", "v", "eee"])
											#6tym elementem tej listy bedzie lista 3 elementowa
					print(lista[5][2])									#[wynikiem bedzie "eee"]
		*INSERT - insertowanie czyli dołączanie ale we wskazanym miejscu z przesunieciem 
				  wszystkich elementow o 1 pole w prawo. Insert zrobi insert na pozycji przed
				  indeksem. Najpierw wskazujesz miejsce gdzie ma byc zainsertowane a pozniej co 
				  ma byc zainsertowane. Nie można używać tej funkcji podczas przypisania. 
					lista.insert(3,'aa')
		*EXTEND - do dodania do starej listy nowej możesz użyc albo PLUSA! albo metody extend()
					thisList.extend(secondList)
		  *korzystając z metody extend mozesz nie tylko dodawac listy do listy ale równiez 
		   inne kolekcje do swojej listy i te kolekecje zamienią sie w listy
					thislist = ["apple", "banana", "cherry"]
					thistuple = ("kiwi", "orange")
					thislist.extend(thistuple)	  
										#zwróci:['apple', 'banana', 'cherry', 'kiwi', 'orange']
		*COUNT - liczenie ilosci wystepowania danego znaku w liscie 
		 [nie bierze pod uwage znakow w zagniezdzonej liscie]
					lista.count("d")
		*INDEX - zwrocenie indexu podanego znaku w liscie [pierwszego napotkanego][liczy od zera]
					lista.index("d")
		*REMOVE - usuniecie pierwszego napotkanego podanego znaku
					lista.remove("d")
		*POP - usuniecie elementu o podanym indexie lub ostatniego na liście:
					thislist.pop(1)		-usuniecie drugiego elementu
					thislist.pop()		-usuniecie ostatniego elementu
		*DEL - usuniecie elementu lub całej listy: 
					del thislist[0]
					del thislist
		*CLEAR - wyczyszczenie listy ze wszystkich elementow
					lista.clear()
					print(lista)		#wynikiem w konsoli bedzie znak pustej listy czyli []
		*SORT - poprzestawianie elementow poprzez posortowanie ich rosnaco [dla listy gdzie 
				sa same liczby] oraz alfabetycznie [dla listy gdzie masz same stringi]
				Funkcja nic nie zwraca, tylko modyfikuję orginalną listę. Jeżęli nie chcesz 
				żeby modyfikowało oryginalną liste to użyj metody sorted (patrz built-insy)
					lista.sort();
					print(lista)
		  *żeby zrobić sortowanie malejące to dodajesz parametr reverse = True:
					lista.sort(reverse = True)
		  *możesz też ustawić paramter  key = function  względem którego ma się odbyć sortowanie:
					def myfunc(n):
						return abs(n - 50)
					thislist = [100, 50, 65, 82, 23]		
					thislist.sort(key = myfunc)				#zwróci te  które są bliżej zera
					print(thislist)							#zwróci: [50, 65, 23, 82, 100]
		  *lista jest też 'case sensitive' - słowa z dużymi literami zawsze będą wyprzedzały 
		   miejscem słowa z małymi literami dlatego jeżeli nie chcesz zeby wielkośc liter miała 
		   wpływ na sortowanie słów to użyj argumentu key = str.lower
					thislist = ["banana", "Orange", "Kiwi", "cherry"]
					thislist.sort(key = str.lower)
					print(thislist)			
		*REVERSE - odworcenie kolejnosci elementow w liscie 
					lista.reverse() 
							#mozna tez zrobic sortowanie malejace najpierw posrotowac(rosnaco)
					print(lista)	#     lista.sort()    a pozniej odwrocic    lista.reverse()
		*COPY - ponieważ nie możesz sobie skopiować listy poprzez przypisanie jej do nowej listy
				to musisz użyc metody do tego przeznaczonej czyli copy():
					thislist = ["apple", "banana", "cherry"]
					mylist = thislist.copy()
			  - innym sposobem bedzie przypisanie przekonwertowanej listy na liste 
					thislist = ["apple", "banana", "cherry"]
					mylist = list(thislist)
		*SORTED - do funkcji sorted podajesz liste krotek o tej samej ilosci elementow. Dzieki
				 niej masz mozliwosc posortowania tychze krotek (więcej patrz dział BUILT-INS)
		
	*LIST COMPREHENSIONS - WYRAZENIA LISTOWE (lekcja 17)
		*https://www.w3schools.com/python/python_lists_comprehension.asp
		*w nawiasach kwadratowych wpisujesz co ma zostac zwrocone z listy po ktorej przejdzie
				newlist = [expression for item in iterable if condition == True]
		petla for (na liscie ktora podasz w argumencie petli for)
				lista = [0,1,2,3,4,5,6,7,8,9]
				nowa1 = [i*3 for i in lista]			[zwroci: [0,3,6,9,12,15,18,21,24,27,30]]		
		*mozesz tez dodac warunek na koncu tego wyrazenia
				nowa2 = [i*3 for i in lista if i%2 ==0] 			[zwroci: [0,6,12,18,24]]
		*mozesz tez dodac warunek na poczatku ale to juz bedzie manipulacja tego co zwroci funkcja
		 z warunkiem na koncu czyli cale wyrazenie zwroci liste na ktorej ty przeprowadzisz operacje 
		 z poczatku wyrazenia pod warunkiem ze wszystkie elementy beda spelniac warunek z poczatku 
		 dla elementu nie spelniajacego warunku z poczatku zostanie wykonana inna operacja (z else'a)
				nowa3 = [i + 7 if i !=2 else "mama" for i in lista if i % 2 == 0 ]
															[zwroci [7, 'mama', 11, 13, 15]]
				newlist = [x if x != "banana" else "orange" for x in fruits]
						["Return the item if it is not banana, if it is banana return orange"]
		*W LIST COMPREHENSION nie ma możliwości przypisywania oraz iterowania na zmiennej przed 
		 forem ale zamiast tego mozna użyć przy liczbach funkcji sum():  
			*zamiast tego:
				zmienna=0
				[zmienna+=10**j for j in range(10)] !!! tego nie wolno robić !!!
			*taka opcja jest dozwolona:
				sum([10**j for j in range(10)])	
	
	**NESTED FOR in FOR IN LIST COMPREHENSIONS- iterowanie po ZAGNIEŻDŻONYCH LISTACH wewnątrz siebie:	
		czyli zamiast robienia petli w petli:
				for i in range(x+1):
					for j in range(y+1):
						mainList.append([i,j])
				print(mainList)
		*robisz wszystko w jednej linijce za pomocą list comprehensions:
				lst=[(a,b) for a in A for b in B]	np:
				[mainList.append([i,j]) for i in range(x+1) for j in range(y+1)]
				
					
############################# LEKCJA 32 - 35 | WYRAZENIE REGULARNE ############################
https://www.w3schools.com/python/python_regex.asp
NAJLEPSZY PORADNIK I ZBIÓR WIEDZY O REGEXACH:
			*https://www3.ntu.edu.sg/home/ehchua/programming/howto/Regexe.html
			*https://www.youtube.com/watch?v=K8L6KVGG-7o
HOW TO CHECK A VALID REGEX PATTERN:	
			*regex101.com
			*https://www.geeksforgeeks.org/how-to-check-a-valid-regex-string-using-python/
FLAGI:		*https://www.guru99.com/python-regular-expressions-complete-tutorial.html
	

LEKCJA 32 WYRAŻENIA REGULARNE:
0* PODSTAWY PODSTAW:
	*jeżeli chcesz sprawdzić czy dany regex cos zwrócił (coś zmatchował) to możesz to sprawdzić 
	 poprzez przekonwertowanie wyniku funkcji regexowej na listę albo Stringa i sprawdzenie poprzez ifa 
	 (jeżeli lista labo String będą puste to zwróci fałsz)
			allMatches = findAll(r'pattern', String)
			if bool(allMatches)==True:
				print(allMatches)
			else:
				print((-1,-1))   
	*żeby wyświetlić treść/stringa z dopasowanego MatchObjectu (z funkcji match, search, finditer) 
	 musisz użyć na obiekcie MatchObject funkcji group() (więćej w Pkt3 funkcje):
			print(re.match("ko.","kotttttt").group())							#zwroci: 'kot'
	*znacznik 'r' przed stringiem (raw) - sprawia ze znaki specjalne wyswietlaja sie jak zwykly tekst
			wzor = 'banan\nbanan\tbanan'
			print(wzor)
			wzor = r'banan\nbanan\tbanan'
			print(wzor)
	*żeby móc działać na wyrażeniach regularnych to musisz zaimportowac 
	 bibliotekę 're'  (od regular expressions)
			import re
1* WZÓR 'PATTERN' - dla wyrażeń regularnych musisz stworzyć WZÓR 'PATTERN' który będziesz dopasowywal
   do podanego tekstu:
   https://www.w3schools.com/python/python_regex.asp
	* PODSTAWOWE ZNAKI:
		* znak '.' dodany do wzoru oznacza że jakikolwiek POJEDYŃCZY znak moze sie pod tym kryc:
				print(re.match("ko.","kotttttt"))	
											#zwroci: <re.Match object; span=(0, 3), match='kot'>
				print(re.match("ko.","askotttttt"))					]
											#zwroci: None
				print(re.match(".ko.","skotttttt"))
											#zwroci: <re.Match object; span=(0, 3), match='skot'>
				print(re.match("ko.","sskottttt"))					]
											#zwroci: None
		* znak '^' dodany do wzoru oznacza że wzor musi sie zaczynac od znaku za 'daszkiem'
				print(re.match("^ko","kotttt"))
											#zwroci: <re.Match object; span=(0, 2), match='ko'>
				print(re.match("^ko","skotttt"))
											#zwroci: None
		* znak '$' dodany do wzoru oznacza że wzor musie sie konczyc na znaku przed dolarem
				print(re.match("ko$","ko"))
											#zwroci: <re.Match object; span=(0, 2), match='ko'>		
				print(re.match("ko$","kot"))
											#zwroci: None				
		* znak '*' pozwala w wyrażeniach regularnych na dowolną ilośc wystąpień znaków/klasy znakow
		 (może być tak że wogóle nie musi występować nawet jeden raz dany znak)
		 które występują przed tym symbolem np: wszystkie słowa z dużymi literami
				print(re.match("[A-Z][a-z]*","M"))
											#zwroci: <re.Match object; span=(0, 5), match='M'>
				print(re.match("[A-Z][a-z]*","Marek"))
											#zwroci: <re.Match object; span=(0, 5), match='Marek'>
				print(re.match("[A-Z][a-z]*","adMarek"))
											#zwroci: None
		* znak '+' pozwala w wyrażeniach regularnych na dowolną ilość wystąpień znaków/klasy 
		 ale z zastrzeżeniem że MUSI WYSTĄPIĆ CHCOCIAŻ 1 raz, dla wszystkich tych 
		 ktore wystepują bezpośrednio przed jego symbolem 
				print(re.match("[A-Z][a-z]+","M"))
											#zwroci: None
				print(re.match("[A-Z][a-z]+","Marek"))
											#zwroci: <re.Match object; span=(0, 5), match='Marek'>
				print(re.match("[A-Z][a-z]+","adMarek"))
											#zwroci: None
		* znak '?' pozwala w wyrażeniach regularnych na POJEDYŃCZĄ lub ŻADNĄ ilość wystąpień 
		 znaków/klasy (1 albo 0) dla wszystkich tych ktore wystepują bezpośrednio przed jego symbolem
		 znak '?' jest tez znakiem zakończenia dalszego wyszukiwania
				print(re.match("[A-Z][a-z]?","M"))
											#zwroci: <re.Match object; span=(0, 1), match='M'>
				print(re.match("[A-Z][a-z]?","Marek"))
											#zwroci: <re.Match object; span=(0, 2), match='Ma'>
				print(re.match("[A-Z][a-z]?","adMarek"))
											#zwroci: None
	* SEKWENCJE ZNAKÓW - zamiast budować pewne schematy samemu poprzez klasy znaków albo grupy 
	 znaków to można użyć specjalnych sekwencji:
	 https://www.w3schools.com/python/python_regex.asp
	 https://www.regular-expressions.info/backref.html
		r przed patternem jest po to żeby potraktowac wzor jako surowego stringa
		\1 - (backreference) - służy wyszukiwaniu POWTÓRZEŃ (tylko w grupach), stawiasz za grupą a on 
			znajduję ci pierwszą powtarzającą się grupę (jedynka odwołuję się do pierwszej zwróconej 
			grupy z patternu, mogłbyś dać zamiast niej 2kę a wtedy backreference odwoływałby się do drugiej 
			zwróconej grupy w patternie. [\1 references the first capturing group) matches the same text 
			as previously matched by the capturing group.]
				string ='123123333'
				m = re.search(r'(\w)\1', string)
				print(m.group())							#zwroci: 33
				m = re.search(r'(\w+)\1', string)
				print(m.group())							#zwroci: 123123	
				m = re.search(r'(\w)23\1', string)
				print(m.group())							#zwroci: 1231	
				m = re.search(r'(\w)\1{3,}', string)
				print(m.group(1))							#zwroci: 3 (od 3 elementów)
			*W PRZYPADKU grup opcjonalnych tj takich gdzie grupy na zewnątrz poddaje się opcjonalności
			 poprzez znaki ? oraz * to nie można się do nich odwołać przez backreference bo pojawi się błąd
			 [nie można czegoś takiego zrobić (b)?\1 gdyż nie można odwołąć się do grupy ktora nie została
			 wywołana] jednakże można zrobić coś innego czyli odwołać się do grupy która została wywołana 
			 ale nic nie zwróciła [(b?)\1 - takie coś można zrobić]. 
			*DO WYSZUKIWANIA POWTÓRZENIA jakiekowielk znaku w całym tekscie( nie musi byc pod rząd 
			 użyj patternu: r'(.).*\1'
			*DO WYSZUKIWANIA POWTÓRZEŃ POD RZĄD Z SEPARATOREM użyj patternu:
				r'(\d)(-?\1){3}' #wyszukuję 4(nie 3) liczby przedzielone myslnikiem w obojetnie jakim miejscu
		\A - zwraca dopasowanie jeśli znaki za nim sa na poczatku danego stinga:
				print(re.findall("\AThe", "The Rain in Spain"))				#zwroci: ['The']
		\Z - zwraca dopasowanie jeśli znaki przed nim sa na końcu danego stinga
				print(re.findall("Spain\A", "The Rain in Spain"))			#zwroci: ['Spain']
		\b - zwraca dopasowanie jeśli podane znaki są na poczatku słowa (\bpoczatekSlowa) lub 
		     na końcu słowa (koncowkaSlowa\b) lub ograniczają słowo na początku i na końcu. Jeżeli 
			 używasz tego to nie powinineś używać zaraz po znakach częstotliwości tj +,*,?;
				print(re.findall("in\b", "The Rain in Spain"))				#zwroci: ['Rain','in'] 	
				print(re.findall("\bRa", "The Rain in Spain"))				#zwroci: ['Rain'] 	
				print(re.findall("\bin\b", "The Rain in Spain"))			#zwroci: ['in'] 	
		\B - zwraca dopasowanie jesli podane znaki nie znajdują sie na poczatku słowa (\Bain)
			 albo na końcu słowa (ain\B)
				print(re.findall("\Bain", "The Rain in Spain"))			#zwroci: ['Rain','Spain'] 	
				print(re.findall("ain\B", "The Rain in Spain"))			#zwroci: [] 	
		\d - (digit) - zwraca dopasowanie gdy znajdzie liczbe 
				print(e.findall("\d","The rain in S34pai5n"))			#zwroci: ['3','4','5']
		\D - (digit) - zwraca dopasowanie gdy nie znajdzie liczby
				print(e.findall("\D","The r4ain"))#zwroci: ['T', 'h', 'e', ' ', 'r', 'a', 'i', 'n']
		\s - zwroci tekst gdy string zawiera spacje 
				print(e.findall("\s","The rain-in=S34pai5n"))			#zwroci: [' ',' ',' ']
		\S - zwroci tekst gdy string NIE zawiera spacji
				print(e.findall("\S","The r"))						#zwroci: ['T','h','e','r']
		\w - zwroci tekst gdy string bedzie zawieral znaki a-zA-Z0-9 (nie odpowiada to tylko
			[a-zA-Z1-9] - bierze jeszcze dodatkowo znak '_')
				print(e.findall("\w","The r"))						#zwroci: ['T','h','e','r']				
		\W - zwroci tekst gdy string nie bedzie zawieral znakow a-zA-Z0-9
				print(e.findall("\W","The rain-in=S34pai5n"))			#zwroci: [' ','-','=']
	* FLAGI REGEX (podawane jako 3ci argument w funkcjach:) - gdy korzystasz z wielu flag w 3cim 
	  argumencie to musisz je wypisać po znaku pipu |
		re.findall(pattern,txt,re.I|re.DOTALL)
								#wielkość znaków będzie ignorowana i regex będzie matchował multiline 
								 czyli z enterami a nie do końca linii
	  FLAGI: https://www.guru99.com/python-regular-expressions-complete-tutorial.html
		re.M/re.Multiline		Make begin/end consider each line ( w sytucjach gdy string jest 
			zapisany przy pomocy ''' ''' w kliku liniach 
		re.I					It ignores case sensitive (ignoruje wielkosc znaków)
		re.S lub re.DOTALL (?s)	sprawia że znak . (wszystkie znaki) oraz inne znaki są brane pod
			uwagę przy matchowaniu nie do końca lini tylko łącznie z enterami czyli: match any 
			character at all, including a newline - bez tego będzie matchował tylko do końca linii 
			(czyli do ENTERA). JEDNAKŻE używając tego trzeba pamiętać o tym żeby wykorzystać LAZY
			(spowolnienie) GREEDY MATCHING - w przypadku znaków miedzy tagami czyli .* dodać znak 
			spowolnienia czyli ? żeby wyszło: .*?
					pattern=r'//.*?(?=\n)|/\*.*?\*/'
					re.findall(pattern,txt,re.I|re.DOTALL)
			mimo wszystko i tak najlepszą opcją będzie użycie [\s\S]*? zamiast .*? i re.DOTALL
					pattern=r'//.*|/\*[\s\S]*?\*/'
					re.findall(pattern,txt,re.I)
		re.U					Make { \w,\W,\b,\B} follows Unicode rules
		re.L					Make {\w,\W,\b,\B} follow locale
		re.X					Allow comment in Regex
	* KLASA ZNAKOW [] - jeżeli dopasowano chociaż jeden ze znakow podanych w klasie znakow (przy
	 pomocy nawiasow kwadratowych) to ma taki napis wziąć pod uwagę
			print(re.match("[KPk]ot","Pota"))		#bierze pod uwage Duzą literę K i P
			print(re.match("[KPk]ot","kota"))		#oraz małą literę k: CZYLI K lub P lub k
										#zwroci:<re.Match object; span=(0, 3), match='Pot'>
												<re.Match object; span=(0, 3), match='kot'>
			print(re.match("[KPk]ot","Nota"))
										#zwróci: None
		*w klasie znaków mozesz zrobic tzw przedział np [A-Za-z]-czyli małe i duze litery od A-Z
			print(re.match("[A-Za-z]ot","rotak"))
										#<re.Match object; span=(0, 3), match='rot'>
		*zeby zanegowac jakies znaki to w klasie zanków uzywamy symbolu '^' 
			print(re.match("[^a-k]ot","kotka"))
										#zwroci: None
			print(re.match("[^a-k]ot","lotka"))
										#zwroci: <re.Match object; span=(0, 3), match='lot'>
	* PRZEDZIAŁ ZNAKÓW '{}' pozwala zawrzeć po przecinku minimalną i maxymalną ilość wystąpień 
	 znaków/klasy dla wszystkich tych ktore wystepują bezpośrednio przed jego symbolem
	 Podawany przedział jest obustronnie zamknięty.
			print(re.match("[A-Z]{3}","MAR"))
										#zwroci: <re.Match object; span=(0, 3), match='MAR'>
			print(re.match("[A-Z][a-z]{2,6}","M"))
										#zwroci: None
			print(re.match("[A-Z][a-z]{2,6}","Marekist"))
										#zwroci: <re.Match object; span=(0, 5), match='Marek'>
			print(re.match("[A-Z][a-z]{2,6}","Marekist"))
										#zwroci: <re.Match object; span=(0, 7), match='Marekis'>
			print(re.match("[A-Z][a-z]{2,6}$","Marekist"))
										#zwroci: None
		*takiego przedziału możemy nie zamykać dając z danej strony mozliwośc wystąpienia albo zero
		 razy albo nieskończoność
			print(re.match("[A-Z][a-z]{,6}$","M"))
										#zwroci: <re.Match object; span=(0, 1), match='M'>
			print(re.match("[A-Z][a-z]{2,}$","Marekist"))			
 										#zwroci: <re.Match object; span=(0, 8), match='Marekist'>
		*jeżeli ma być wystąpienie danego patternu konkretną ilość razy (i jest tych konkretnych ilości
		 kilka) to nie możesz zrobić znaku 'LUB' wewnątrz przedziału znaku tj np.: {4|6} (TAK NIE MOŻNA)
		 to co musisz zrobić to powtórzyć cały pattern z nowym przedziałęm znaków (drugą konkretną liczbą)
		 (więskza liczba powinna być pierwsza) 
			matches = re.findall(r'(#[a-fA-F0-9]{6}|#[a-fA-F0-9]{3})',string)
	* GRUPY ZNAKÓW () - są używane po to żeby pokazać że dopuszczamy powtórzenie się całego słowa
	 poprzez użycie specjalnych znaków za grupą typu: *,+,?   
		*poprzez wpisanie w patternie jakiegos slowa w nawiasy okrągłe oraz przypisaniu całej 
		 funkcji match() do jakies zmiennej to na tej zmiennej odwołując się do metody 
		 group(index) jesteś w stanie wywołać tę grupę którą zdefiniowałeś wcześniej pod danym 
		 indexem. 
		*Dla indexu zero jest zarezerwowane całe dopasowane wyrażenie (nie tylko grupy ale całe wyrażnenie)
		 dla indexu 1 pierwsza dopasowana grupa, a dla kolejnych nastepne grupy.
			wynik = re.match(r"^Hello (Wo)(rld)+(im)?","Hello Worldrldrld")
			print(wynik.group())		#zwróci: Hello Worldrldrld czyli całe dopasowane wyrażenie
			print(wynik.group(0))       #pod indeksem 0 to samo co bez indeksu
			print(wynik.group(1))		#zwróci: Wo
			print(wynik.group(2))		#zwróci: rld
		*Ponadto poprzez odwołanie się do funkcji groups() funkcja zwróci Tobie wszystkie 
		 dopasowane grupy w postaci krotki
			print(wynik.groups())			#zwróci: ('Wo', 'rld', None) #dla 'im' niedopasowano 
											 żadnego indeksu dlatego pokazało None 
		*Możesz także zagnieżdżać grupy wewnątrz innej grupy
			wynik = re.match(r"^Hello (Wo(rl)d)$","Hello World")
			print(wynik.groups())		#zwróci: ('World', 'rl')
		*grupy można też nazwać dzięki czemu poprzez funkcje group() będzie można się do nich 
		 odwołać poporzez index albo poprzez ich nazwe. Nazwanie grupy odbywa się poprzez 
		 taką składnie (?P:<nazwagrupy>znakiDlaGrupy)
			wynik = re.match(r"^(He(?P<first>ll)o) (Wo)(rld)+(im)?","Hello Worldrldrld")
			print(wynik.group("first"))				#zwroci ll
			print(wynik.group(2)) 					#zwroci ll (dla indexu 1 bedzie: Hello)
			print(wynik.groups())					#zwroci wszysgtkie grupy czyli:
													#('Hello', 'll', 'Wo', 'rld', None)
		*można też stworzyć grupę anonimową przez co nie zmieni nam to kolejności indeksowania
		 naszych wcześniej zawartych grup ale także nie bedzie można się do niej dostać przy
		 pomocy metody group()
			wynik = re.match(r"^((?:He)(?P<first>ll)o) (Wo)(rld)+(im)?","Hello Worldrldrld")
			print(wynik.groups())					#zwroci wszysgtkie grupy oprocz tej anonimowej
													#('Hello', 'll', 'Wo', 'rld', None)
		*jeżeli w grupie chciałbyś znaleźć 1 z 2 znaków to musisz w patternie uzyc takiego
		 wyrażenia znak1|znak2 co oznacza znak1 albo znak2 (może to być też grupa znaków np
		 grznakow1|grznakow2 :
			wynik=re.match(r"((tr|sr)ap)","trapsrap")
			print(wynik.groups())					#zwroci: ('trap', 'tr')		 
		*jeżeli w grupie chcielibyśmy znaleźc jakiś znak specjalny jak np kropka to musisz 
		 użyć backslasha: \. 
		 PRZYKŁAD dla walidacji emaili:
		 if re.match("^([A-Za-z0-9]+|[A-Za-z0-9][A-Za-z0-9\.-]+[A-Za-z0-9])@"
            "([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\.-]+[A-Za-z0-9])\."
            "[A-Za-z0-9]+$","a@p.pl"):
			print("Dopasowano")
		else: print("Nie dopasowano")									#zwroci: "Dopasowano"
		*PRZYKŁADY GRUPY ZNAKÓW:
			*Wyszukiwanie maili w tekscie zaczynajacym sie od slowa From:
				^From:\s(\S+@\S+)	#przy funkcji findall() zwroci tylko grupę czyli w tym wypadku
									#maile bez slowka "From:" 
	  *NON CAPTURING GROUP ?: 
	   https://www.rexegg.com/regex-disambiguation.html#noncap
		*jeżeli masz konstrukcję patternu w postaci grupy wewnątrz grupy (gdyz tak trzeba było stworzyć 
		 pattern) ale chcesz żeby wszystko było traktowane jako 1 grupa przy matchowaniu to w wewnętrznej 
		 grupie zaraz po nawiasie wstawiasz ?: Dzięki temu wewnętrzna grupa nie będzie traktowana jako 
		 grupa. [It is useful if we do not need the group to capture its match (grupa nie musi uchwicić
		 swojego matcha]
				matches = re.findall(r'((?:[a-fA-F]{3}){1,2})',String)
				matches.group() 		#zwroci wszystkie napisy z 3 lub 6 literami a-f
		*NON CAPTURING GROUP używa się głównie wtedy gdy masz wiele warunków w jednym REGEXIE. Wtedy
		 jeden warunek ustalasz głównym a na pozostałych robisz lookaheady/lookbehindy. W tyh lookaheadach 
		 musisz czasem zawrzeć ilość wystąpień poprzez nawiasy wąsowe {}. Zeby to zrobić to musisz to
		 zrobić na wewnętrznej grupie, a ponieważ jak masz wiele warunkó to grupą którą chcesz zwrócić
		 ma byćwarunek główny to żeby zdeprecjonować tę wewnętrzną grupę to używasz NON CAPTURING GROUP
				pattern=r'^(?=(?:[a-z\d]*[A-Z]){2})(?=(?:\D*\d){3})(?:([a-zA-Z\d])(?!.*\1)){10}$'
			*powyższy pattern sprawdza czy napis ma conajmniej 2 Duże litery, 3 cyfry i 10 znaków oraz czy 
			 jakiekolwiek znaki się nie powtarzają (niestety nie roumiem jak został stworzony ten ostatni
			 warunek, dlaczego to nie może być użycie lookaheada z warunkiem odpowiadającym za niepowtarzanie
			 się znaków: (.).*\1. Dlatego jak masz wiele warunkó w jednym REGEXIE to o wiele lepiej jest
			 zrobić kilka funkcji sprawdzających niż robić to wszystko w jednym REGEXIE:
					s='B3C4d5efgh'
					import  
					patterns=[r'(.*[A-Z]){2}',r'[a-zA-Z0-9]{10}', r'(.*\d)']
					pattern2=r'(.).*\1'
					boolean= all([re.search(p2,string) for p2 in patterns])and not re.search(pattern2,s)
					print('Valid') if boolean else print('Invalid')
		*Sytuacje w których równiez warto skorzystać z NonCapturing Group to sytuacja powyżej gdy masz 
		 określoną ilość liter (w tym przypadku 3 albo 6) --> robisz to tak jakbyś grupa 3 literowa mogła 
		 wystąpić 1 albo 2 razy (wtedy 6 liter)	 
				matches = re.findall(r'(#(?:[a-fA-F0-9]{3}){1,2})',String)
	  *BRANCHRESET ?| 
	   https://www.rexegg.com/regex-disambiguation.html#branchreset
			*wykorzystywane wewnątrz grup jest alternatywą dla NON CAPTURING GROUP. Pozwala na 
			 umieszczenie w jednej wielkiej grupie wielu podgrup w alternatywie do siebie z wyzerowaną
			 numeracją (tj że każda podgrupa w alternatywie zaczyna numeracje od 1)
				(?|(ab)|(cde)|(fghi)) 		#grupy ab,cde,fghi są numerowane od indexu 1
				(?|a(b)|(c)(de)|(fg)(h)(i)) #grupa (b) ma index 1, grupa (c) ma index 1 a (de) index 2
											 grupa(fg) index 1 (h) index 2 (i) index 3
			*takie numerowanie indexu przydaję się przede wszystkim przy backreference 
				(?|(ab)|(cde)|(fghi))\1		#backreference odwołuję się do grupy pierwszej dzieki czemu 
											 może zmatchować takie teksty jak abab albo cdecde albo fghifghi
	  *LOOKAHEAD/LOOKBEHIND 
	    https://www.rexegg.com/regex-disambiguation.html#lookarounds
		https://www.geeksforgeeks.org/python-regex-lookahead/
		https://www.regextutorial.org/positive-and-negative-lookahead-assertions.php
		https://www.regular-expressions.info/lookaround.html
		*LOOKBEHIND/LOOKAHEAD ?<= / ?=
			*The lookahead only asserts whether a match is possible or not
			*chcąc z niego skorzystać wyobraż sobie że przy korzystaniu z funkcji finditer() możesz 
			 robić matche dokładnie od każdej literki (to tak nie działa dokładnie ale dobrze by było żeby
			 ci się w ten sposób kojarzyło wykorzystywanie tego) (dzieki czemu nawet jak się pattern zazebia 
			 czyli drugi rozpoczyna się wenątrz pierwszego to dzieki lookahead, lookbehind zwróci oba 
			 zamiast tylko tego pierwszego)
			*dopasowuje (matchuje) obiekt do patternu ale to co jest przy znaku lookbehind i lookahead 
			 nie jest zwracane funkcji. Normalnie mógłbyś to zrobić poprzez grupę ale jeżeli poszukiwane
			 patterny się zakleszczają (czyli jeden jest wewnątrz poprzedniego )to przez to że ten pierwszy
			 został już zmatchowany i zwrócony to tego zakleszczonego nie weźmie już pod uwagę. Dlatego
			 używasz lookahead i lookbehind żeby wskazać w nich to co nie ma być zwrócone ale ma być
			 zmatchowane.
			*głównie jest to stowrzone dla znaków okalających/otaczających nasz pattern np szukasz 2 
			 samogłosek ktore są otoczone 1 spółgłoską. Chcesz zwrócić tylko samogłoski bez spółgłosek 
			 ale musisz zmathować pattern wraz ze spółgłoskami, dlatego spółgłoski robisz w lookbehind 
			 i lookahead.
				*Przykład: szukasz w tekście 'baabeebuubiid' conajmniej 2 samoglosek otoczynych 
				 conajmniej jedną spółgłoską. Bez uzycia lookahead zwroci Tobie 'aa' i 'uu' gdyz po 
				 zmatchowanium'baab' nie może zmatchować już 'beeb' (tak samo z 'buub' i 'biid'). 
				 Jednakże jezeli w pierwszej grupie użyjesz lookbehind a w trzeciej lookahead to zwroci
				 Tobie tylko podwójne samogłoski czyli to czego szukałeś 
						pattern=r'(?<=[qwrtypsdfghjklzxcvbnm])([aeiou]{2})(?=[qwrtypsdfghjklzxcvbnm])'
			*Lookbehind nie zwraca wszystkiego co jest przed poszukiwanym patternem a Lookahead nie 
			 zwraca wszystkiego co jest za poszukiwanym patternem (Obszar wskazywany przez 
			 lookbehind/lookahead konczy się na rozpoczęciu nowej grupy)(w poniższym przypadku w 
			 momencie gdy zaczynają się samogłoski ([aeiou]{2})
						pattern=r'(?=[qwrtypsdfghjklzxcvbnm]([aeiou]{2})[qwrtypsdfghjklzxcvbnm])'
			*Positive lookbehind/lookahead ?<= / ?= matchuje (ale nie zwraca!) wszystkie podane znaki a
			 Negative lookbehind/lookahead ?<! / ?! matchuje (ale nie zwraca!) wszystkie miejsca gdzie 
			 nie ma podanych znaków:
						pattern = r'(?<=[1-3])(pattern)',x)	
									#zwróci wszystkie patterny gdzie przed występują liczby 1,2 lub 3 
									 bez tych liczb na początku 
						pattern = r'(?<![1-3])(pattern)',x)
									#zwroci wszystkie patterny gdzie przed NIE występuje liczby 1,2 lub 3 
									 bez tego co występuję zamiast tych liczb 
				  #inny przykład Negative lookbehind/lookahead 
						pattern = r'(?<!^)(pattern)' 
									#zwróci wszystkie patterny gdzie patterny nie zaczynają się na 
									 początku zdania
			*lookaheada i lookbehinda używasz w sytuacjach gdy masz w jednym regexie wiele warunków 
			 wtedy jeden warunek ustawiasz jako główny (który będzie grupą którą będziesz zwracał 
			 a reszta jest lookaheadami i lookbehindami i on nic nie będą zwracać tylko matchować
			 (sprawdzając przy okazji wszystkie warunki.
						pattern=r'^(?=(?:[a-z\d]*[A-Z]){2})(?=(?:\D*\d){3})([a-zA-Z\d]){10}$'
									#sprawdza czy napis ma conajmniej 2 Duże litery, 3 cyfry i 10 znaków
			*W przypadku LOOKAHEAD możesz zrobić alternatywę ale w przypadku LOOKBEHIND już nie (wyskakuję
			 błąd że fixed-width-pattern-error) Żeby móc zrobić alternatywę to musisz skorzystać z
			 NON CAPTURING GROUP czyli:
				(?:(?<=a)|(?<=bc))
			*w funkcji findAll() w patternie zwraca zmatchowane Stringi bez tego co jest w 
			 lookabehind/lookahead pod warunkiem że są zawarte w grupie czyli w nawiasach okrągłych 
			 tj r'(?<=[\s])(pattern)'
					string = 'abaabeebuubiide'
					pattern=r'(?<=[qwrtypsdfghjklzxcvbnm])([aeiou]{2,})(?=[qwrtypsdfghjklzxcvbnm])'
					outcome= re.findall(pattern,string, re.I)
					for x in outcome:
						print(x)					#zwroci 'aa' 'ee' 'uu' 'ii'
			*funkcje search(), match(), finditer() zwrócą MatchObject na którym pozniej będzie można 
			 operować odpowiednio poprzez wyciaganie indeksów zmatchowanego tekstu (ze spana()) albo 
			 wyciągniecie samego zmatchowanego tekstu poprzez funkcje group() 
					string = 'abaabeebuubiide'
					pattern=r'(?=[qwrtypsdfghjklzxcvbnm])([aeiou]{2,})(?=[qwrtypsdfghjklzxcvbnm])'
					outcome= re.finditer(pattern, string, re.I)
					for x in outcome:
						print(x.group())
			*EFEKTYWNE KORZYSTANIE z LOOKAHEAD i LOOKBEHIND jest wtedy gdy wprowadzasz je jako grupy 
			 okalające - ktore mają być tekstem okalającym poszukiwanego patternu. Tworzysz taki pattern 
			 ze pierwszą i trzecią grupą są Lookbehind i Lookahead a drugą grupą jest poszukiwany wyraz:
			 Przykład - szuka wszystkich znakow && które mają spacje przed i za i zamienia je na 'and'
			 nie biorąc przy okazji tych spacji pod uwagę do zwracanej grupy
					string="x&& &&& && && x"
					print(re.sub(r'(?<=\s)(&&)(?=\s)','and',string))	#zwroci: "x&& &&& and and x"
			 To na co należy zwrócić uwagę przede wszystkim to to czy na 100 procent z przudu i 
			 z tyłu ma być grupa okalająca czy tylko np z przodu  

2*WAŻNE ZAWIŁOŚCI PRZY REGEXACH PO PRZECZYTANU O PATTERNACH:
	*GREEDY MATCHING:
		*JEŻELI STWORZYMY WZÓR KTÓRY BĘDZIE PASOWAŁ W JEDNYM TEKSCIE WIECEJ NIŻ JEDEN RAZ TO 
		 ZAWSZE WYBIERZE GREEDY MATCHING czyli DŁUŻSZE DOPASOWANIE:
			np.: (tekst zaczynający się od F, jakiekolwiek znaki w środku i dwukropek na koncu)
			wzór: ^F.+:	 dla tekstu: "From: Using the :..." zwroci dopasowanie: "From: Using the :"
		*dlatego gdy dodasz na koncu sekwencji znaków .* lub .+ znak ? (czyli .*? lub .+?) to 
		 będzie zwracal	dopasoawania NON GREEDY czyli :
			wzór: ^F.+:	 dla tekstu: "From: Using the spaces: 1st space" zwroci dopasowanie: 
									 "From: Using the spaces:" zamiast oczekiwanego "From:"
			jednakże po dodaniu znaku zapytania     ^F.+?:     zwróci NON GREEDY:     From:
		*działa to szczególnie w przypadku wykorzystania flagi re.DOTALL w trzecim argumencie 
		 danej funkcji gdy REGEX przeszukuję wiele linii zamiast zatrzymać się na pojedyńczej 
		 linii (przeszukiwanie po jednej linii jest domyślnym przeszukiwaniem). Wtedy Greedy 
		 Matching szczegoonie się ujawnia bo w całym tekście wybierze pierwsze i ostatnie 
		 wystąpienie danego matcha (gdyż cały tekst pomiędzy uzna za pasujący do patternu .*lub .+)
	*Alternative Matching | 
		*Może być wykorzystywane w klasie znaków albo w grupie znaków ale nie w przedziale znaków. 
		*W jednej klasie znaków lub grupie znaków możesz użyć wiele alternative matching
		*W klasie znaków słuzy jako alternatywa miedzy jednym znakiem a drugim [a|b] #a lub b ;; 
		 a w grupie znaków służy do wyboru jednej lub drugiej grupy (and|AND) #grupa and albo AND
		*Alternative matching mozesz uzyc takze w NONCAPTURING GROUP:
					(?:http://|https://)
		 Jeżeli w zadaniu masz wiele grup i podgrup w których musisz posłużyć się ALTERNATIVE 
		 MATCHING to użyj NON CAPTURING GROUP - wręcz dobrą praktyką jest używanie NON CAPTURING 
		 GROUP jak najczęściej podczas grupowania (zamiast zwykłych grup):
					'(?:(?:(?:[1-8]\d|\d)(?:\.\d+)?)|(?:(?:90)(?:\.0+)?))'
							#zmatchuję liczby od 0 do 90 z tymi które mają liczby po przecinku 
							i z tymi które nie mają a w przypadku liczby 90 weźmie pod uwagę po 
							przecinku tylko 0
		*W przypadku LOOKAHEAD możesz zrobić alternatywę ale w przypadku LOOKBEHIND już nie
		 (wyskakuję błąd że fixed-width-pattern-error) Żeby móc zrobić alternatywę to musisz 
		 skorzystać z NON CAPTURING GROUP czyli:
					(?:(?<=a)|(?<=bc))
		 Więcej na wpisie Wiktor Stribiżew: https://stackoverflow.com/questions/20089922/python-regex-engine-look-behind-requires-fixed-width-pattern-error
	*EEKTYWNE KORZYSTANIE Z LOOKBEHIND LOOKAHEAD i NON CAPUTRING GROUP 
		*To wzajemne zamienne stosowanie tych dwóch ze soba ==> w funkcji findall() jest zwracane 
		 to co jest w nawiasach okrągłych to co nie jest zwracane to wszystko to co znajduję się 
		 poza nawiasami okrągłymi czyli:
				*LOOKBEHIND/LOOKAHEAD
				*zwykły TEKST/PATTERN
				*NONCAPTURING GROUPS
					re.findall(r'(?:http://)www\.(\w\.)+(?=/)',string)
													#zostanie zwrócona tylko grupa (\w\.)+
	*WYSZUKIWANIE WIELU GRUP W JEDNYM PATTERNIE:
		*O wiele lepiej jest to zrobić przy użyciu powatórzenia się tej samej funkcji dla wielu róznych
		 patternów niż użycia rozbudowanego połaczonego patternu dla jednej funkcji ale jeżeli już
		 jest to konieczne to:
		*W danym patternie musisz użyć nawiasów okrągłych które zwrócą ci to czego chcesz a reszta musi 
		 znajdować się poza nawiasami okrągłymi. Niestety ale LOOKBEHIND i LOOKAHEAD nie będą miały 
		 tutaj zastosowania. Przykład. W tekście:
				<h3><a href="/questions/80405/5v-regulator-power-dissipation" 
				class="question-hyperlink">5V Regulator Power Dissipation</a></h3>
				<h3><a href="/questions/80407/about-power-supply-of-opertional-amplifier" 
				class="question-hyperlink">about power supply of opertional amplifier</a></h3>
		 gdzie chcesz znaleźć numer wpisu i musisz użyć patternu wykorzystującego nawiasy okrągłe
		 oraz NON GREEDY MATCHING:
				pattern=r'href=\"/questions/(\d+)/.*?class=\"question\-hyperlink\">(.*?)</a></h3>'
				
3*FUNKCJE W WYRAŻENIACH REGULARNYCH:
	 https://www.w3schools.com/python/python_regex.asp
	 [NAJWAŻNIEJSZE TO ZWRÓCIĆ UWAGĘ CZY FUNKCJA ZWRACA CI OBIEKT MATCHOBJECT (NA KTORYM MOZNA 
	 WYWOŁYWAĆ INNE FUNKCJE) czy STRINGA \]
		*funkcja match() - wyszukuję patternu na początku Stringa. Zwraca obiekt typu MatchObject
				wzor =r"banan"
				tekst =r"banangruszkajablko"
				print(re.match(wzor,tekst)) 
								#[ZWRÓCI prawde oraz: <re.Match object; span=(0, 5), match='banan'>]
			*do wzoru mozesz tez dodac znaki '.*' ktore beda wyszukiwac danego wzoru nie tylko na 
			 poczatku ale gdziekolwiek qw danym tekscie 
				wzor = r".*banan.*"
				tekst =r"jagodabanangruszkajablko"
				if(re.match(wzor,tekst)):
					print("Dopasowano")
				else:
					print("Niedopasowano ")
		*funkcja search() - szuka wzoru w jakimkolwiek miejscu tekstu (wyszukuję pierwszego wystąpienia)
			Zwraca obiekt typu MatchObject na którym mozesz wywołać inne funkcje (span, start, end itp)
				wzor = r'gruszka'
				tekst =r"jagodabanangruszkajablkogruszkagruszka"
				print(re.search(wzor,tekst))
							#ZWROCI prawde oraz: <re.Match object; span=(11, 18), match='gruszka'>]
		*funkcja finditer() - zwraca obiekt iterator który po zmapowaniu zwraca liste obiektów 
			MatchObject (returns an iterator yielding MatchObject instances over all non-overlapping 
			matches for the re pattern in the string)
				import re
				print(list(map(lambda x: x, re.finditer(r"\w",'mar'))))
													#ZWRÓCI:[<re.Match object; span=(0, 1), match='m'>, 
															 <re.Match object; span=(1, 2), match='a'>, 
															 <re.Match object; span=(2, 3), match='r'>]
			*dlatego żeby dostać się do obiektów które zwroci to trzeba to przemawapować poprzez 
			 wywołanie funkcji group() na każdym obiekcie:
				import re
				print(list(map(lambda x: x.group(), re.finditer(r"\w",'marek'))))
																		#zwróci: ['m', 'a', 'r']
		*funkcja findall() nie zwraca prawdy lub falszu a liste wszystkich wystepowan wzoru np lista 
		 wszystkich imon damskich (konczacych sie na 'a') Zwraca listę Stringów pasujących do wzoru
				wzor = r"banan"
				tekst =r"jagodabanangruszkabananjablko"
				print(re.findall(wzor,tekst))	
			**jeżeli we wzorze we funkcji findall() użyjesz grupy to zwroci Tobie tylko dopasowania
			  do grupy zamiast do całego wyrazenia np:
				import re
				zmienna=re.findall("^From:\s(\S+@\S+)",line)	#zwroci Tobie same maile bez slowka From:
				print(zmienna)	
		*funkcja split('pattern',txt) zwraca liste Stringów przedzielonych separatorem podanym
		 w patternie. Funkcja idealna żeby podać wiele separatorów (zwykłym splitem w stringu tego
		 nie zrobisz) potem możesz to zjoinowac na enterze:
				"\n".join(re.split(regex_pattern, input()))
			  #2gi przyklad:
				txt = "The rain:in.Spain"
				x = re.split("\s|\.|:", txt)
				print(x)								#zwroci: ['The', 'rain', 'in', 'Spain']
		  możemy też poprzez 3 argument zaznaczyć ile separatorow ma byc wzietych pod uwage:
				txt = "The rain in Spain"
				x = re.split("\s", txt, 1)
				print(x)								#zwroci: ['The', 'rain in Spain']
		*funkcja sub() zastepuje nam podanym argumentem (2gi argument to nasz podany tekst) 
		 wszystkie miejsca wystepowania wzoru w naszym tekcie. Zwraca Stringa 
				wzor = r"banan"
				tekst =r"jagodabanangruszkabananjablko"
				tekst2= re.sub(wzor, r"truskawka",tekst)	#zamieni banana na truskawke
				print(tekst2)						#zwroci: 'jagodatruskawkagruszkatruskawkajablko'
		  możemy też poprzez 4 argument zaznaczyć ile zaznaczeń ma byc wzietych pod uwage:	
				wzor = r"banan"
				tekst =r"jagodabanangruszkabananjablko"
				tekst2= re.sub(wzor, r"truskawka",tekst, 1)	#zamieni banana na truskawke
				print(tekst2)						#zwroci: 'jagodatruskawkagruszkabananjablko'	  
		*funkcja compile() - dzieki tej metodzie jesteś w stanie zwalidować regexPattern i uzyskać
		 obiekt typu re.Pattern na ktorym mozesz wywołać wszystkie powyższe metody tj search(), 
		 match(), findall(), finditer(). Dzięki takiemu rozwiązaniu możesz zwalidować pattern 
		 i następnie na tym samym patternie wywoływac wiele Stringów bez konieczności wywoływania
		 za każdym razem tego samego patternu dla róznych Stringów:
				import re
				pattern = re.compile(r'([aeiou]{2,3}')
				allMatches1 = pattern.findall(String1)
				allMatches2 = pattern.findall(String2)
				print(allMatches1, allMatches2)
		 w metodzie compile() możesz zawrzeć nie tylko pojedyńczy pattern ale wiele patternów jednocześnie 
		 szczególnie gdy masz wiele warunkó dla jednego patternu. Jednakże wtedy musisz pamieac że jest 
		 to traktowane jako jeden pattern daltego przy wielu warunkach musisz odwołać się do lookaheada
				comp=re.compile(
					r'(?=^[4-6])'
					r'(?!.*(\d)(-?\1){3})'
					r'\d{16}|\d{4}-\d{4}-\d{4}-\d{4}'
					)
		 pamiętaj że te poszczególne warunki nie są traktowane jako każdy z osobna ale jeden pojedyńczy
				print('Valid') if comp.search(x) else print('Invalid')
	*Na wyniku funkcji match(), search()(czyli obiekcie MatchObject) lub finditer() (czyli liscie obiektów 
		MatchObject można dokonać operacji:
		**jesli nie ma wyniku wyszukiwania to zamiast MatchObject masz None (możesz to wykorzystac w ifie):
			m = re.search(r'(\w)\1{2,}', string)
			print(m.group(1) if m else -1)
		**span() - zwroci krotke zawierającą index 
			txt = "The rain in Spain"
			x = re.search(r"\bS\w+", txt)
			print(x.span())												  #zwroci: (12, 17)
		**start(), end()- zwraca pierwszy/ostatni+1 indeks znaku patternu w stringu.
			import re
			m = re.search(r'\d+','abcd')
			m.end()													#zwroci: 4
			m.start()												#zwroci: 0
		**string - zwraca całego Stringa który został przekazany do jedenj z funkcji regexowej (search, 
		  match, findall, finditer)
			txt = "The rain in Spain"
			x = re.search(r"\bS\w+", txt)	
			print(x.string)										#zwroci: 'The rain in Spain'
		**group(), groups(), groupdict()
		  *dla funkcji search() i match() funkcja group() zwraca zmatchowane słowa z MatchObjectu. 
		   (nie muszą one znajdować się w grupie w patternie) Jednym zdaniem zwraca pogrupowane słowa 
		   pasujące do wzoru:
				txt = "The rain in Spain"
				x = re.search(r"\bS\w+", txt)
				print(x.group())											#zwroci: 'Spain'\
		  *dla GRUP ZNAKÓW tj dla wyników wyszukiwania patternów zawierających grupy znaków:
			*group() - bez argumentu albo group(0) zwraca cały wynik w postaci stringa
				m = re.match(r'(\w+)@(\w+)\.(\w+)','username@hackerrank.com')
				m.group() #/m.group(0)						#zwroci: 'username@hackerrank.com'
			*group(1) - zwroci numer danej grupy (liczone od 1 bo 0 jest dla wyswietlenia calego dopasowania)
				m.group(1)									#zwroci: 'username'			
			*groups() - zwroci krotke stringow wszystkich dopasowanych grupy
				m.groups()									#zwroci: ('username', 'hackerrank', 'com')
			*groupdict() - zwroci Dictionary wszystkich dopasowanych grup gdzie kluczem będą przypisane 
			 nazwy w grupach poprzez aliasy: ?P<nazwa> (bez aliasów to nie zadziała)
				m = re.match(r'(?P<user>\w+)@(?P<website>\w+)\.(?P<extension>\w+)','myname@hackerrank.com')
				m.groupdict()		#zwroci:{'website': 'hackerrank', 'user': 'myname', 'extension': 'com'}

	*FUNKCJE w Stringach odpowiadające WYRAŻENIOM REGULARNYM:
			STRING:					WYRAŻENIA REGULARNE:
		.startswith()					^
		.find()						search()
									findall()
4*CIEKAWE ZADANIA:  
	*jeżeli chcialbyś przeszukiwać jakieś teksty w celu poszukiwania i dostałbyś zestaw Stringowych
	 intów to pamiętaj żeby odpowiednio rozpocząć (poprzez funkcje match()) i skończyć(znakiem $) 
			re.match(r"[+-]?\d*[.]\d+$",string)					#[zadanie poszukiwania floatow]
	*żwróci wszystkie maile w tekscie ktore występują po słowie 'From':
			import re
			zmienna=re.findall("^From:\s(\S+@\S+)",line)	#zwroci Tobie same maile bez slowka From:
			print(zmienna)	
	*szukanie conajmniej 2 samoglosek otoczonych spolgloskami:
			string = 'abaabaabaabaae'
			import re
			pattern=r'(?=[qwrtypsdfghjklzxcvbnm]([aeiou]{2,})[qwrtypsdfghjklzxcvbnm])'
			outcome= re.findall(pattern,string, re.I)
			[print(x) for x in outcome]						#zwroci: aa aa aa
	*matchowanie liczb rzymskich :
			thousends = 'M{0,3}' 
			houndreds = 'C[DM]|D?C{0,3}'
			tens =      'X[LC]|L?X{0,3}'
			ones =      'I[VX]|V?I{0,3}'
			regex_pattern = r'({})({})({})({})$'.format(thousends,houndreds,tens,ones)
	*matchowanie maili:
		match= re.match(r'([a-zA-Z][\w\-\.]*@[a-zA-Z]*\.[a-zA-Z]{1,3})',email)
		if match: print(match.group())
	*matchowanie id z wieloma warunkami w jednym patternie -> najlepiej rozbić sobie to na kilka
	 warunków i na każdym z nich zrobić search'a() 
			lst =[input() for i in range(lines)]
			for x in lst:
				p1=re.search(r'^[4-6]',x)
				p2=re.search(r'^\d{16}|^\d{4}-\d{4}-\d{4}-\d{4}$',x)
				p3=re.search(r'(\d)(-?\1){3}',x)            #r'(\d)\1{4}'
				print('Valid') if all([p1,p2]) and not p3 else print('Invalid')
	*wyszukiwanie wnętrza tagów:
			pattern=r'(?<=</)[a-zA-Z]+(?=>)|(?<=<)[a-zA-Z]+(?=\s.+/>)'
	*odroznianie adresow IPv4 od IPv6:
			[print("IPv6") if re.match(r'''([a-fA-F0-9]{1,4}:){7}([a-fA-F0-9]{1,4})$''',address) else 
			 (print("IPv4") if re.match(r'''((2[0-5]{2}\.|1[0-9]{2}\.|[1-9][0-9]\.|[1-9]\.){3})
			 (2[0-5]{2}|1[0-9]{2}|[1-9][0-9]|[1-9])$''',address) else print("Neither")) 
			 for address in addresses]
	*wyszukiwanie domen w pliku html:
			(re.findall(r'''(?:http://|https://)(?:www\.|ww2\.)?
						([\w\-]+(?:\.[\w\-]+)+)(?:(?=/)|(?=\?)|(?=\s)|(?=\"))''',string)
	*matthowanie szerokośći i długości geograficznej:
			re.match(r'''\((?:\+|\-)?(?:(?:(?:[1-8]\d|\d)(?:\.\d+)?)|(?:(?:90)(?:\.0+)?)),\s
			(?:\+|\-)?(?:(?:(?:1[0-7]\d|[1-9]\d|\d)(?:\.\d+)?)|(?:(?:180)(?:\.0+)?))\)''',line)
	*wyszukiwanie wielu informacji w pliku html
	
########################## LEKCJA 18 i 19 | STRING | STRING FORMATTER ##########################
FUNKCJE Stringow: 		https://www.w3schools.com/python/python_strings_methods.asp
					   (https://www.w3schools.com/python/python_ref_string.asp)[to samo]
STRING FORMATTER:		https://www.w3schools.com/python/python_string_formatting.asp

1* OPERACJA NA STRINGACH:
FUNKCJE Stringow: https://www.w3schools.com/python/python_strings_methods.asp
				 (https://www.w3schools.com/python/python_ref_string.asp)[to samo]	
	*CONCATENATE- it is possible to adding only the same TYPE of variable (string)
			[ZABRONIONE]  txt = "maciek dostal "+4	[ZABRONIONE]
			txt = "maciek dostal " str(4)			[DOBRE]
	*ESCAPE CHARACTER - to use double quotes or single quotes or ither escape characters in 
	 string use backslash '\"' ,np.: txt = "We are the so-called \"Vikings\" from the north."
		\'	Single Quote	
		\"  Double Quote
		\\ Backslash 		np: print('\\\\marek')		   #zwróci: \\marek
		\n	New Line	
		\r	Carriage Return	
		\t	Tab	
		\b	Backspace	
		\f	Form Feed	
		\ooo	Octal value	
		\xhh	Hex value
		{{ }}	Allowed single curly brackets
		\ 		przejście do nowej linii w stringu
	*ARRAYS - strings in Python are arrays of bytes representing unicode characters.
			a = "Hello, World!"
			print(a[1])
	*LOOP - Since strings are arrays, we can loop through the characters in a string, 
	 with for loop:
			for x in "banana":
				print(x)	
	*MULTILINE STRINGS - you can assign a multiline string to a 
	 variable by 3 quotes """...""" or '''...''':
			a = """Lorem ipsum dolor sit 
			amet, consectetur adipiscing 
			elit,sed do eiusmod tempor 
			incididuntut labore et dolore 
			magna aliqua."""
			print(a)
	*WYCINANIE - SLICING STRINGS - return a range of characters by indexes [start;end(open bracket)]
			b = "Hello, World!"
			print(b[2:5])													[zwroci 'llo']
		*slice from start by empty first place in brackets:
			b = "Hello, World!"
			print(b[:5])													[zwroci 'Hello']
		*slice to the end by empty second place in brackets:
			b = "Hello, World!"
			print(b[2:])													[zwroci: llo, World!]
		*negative slice - from end of the string without reversing:
			b = "Hello, World!"
			print(b[-5:-2])
		*slice to the index that not exist will return you not an error but the end of the string
			b = "Hello, World!"
			print(b[2:49])													[zwroci: Hello, World!]
	***HOW TO REVERSE STRING - there is no built-in function for that. It is possible to 
							   reverse by slicing total and step backwards:
			txt = "Hello World"[::-1]
	
2* OPERACJE NA TEKSCIE - METODY NA STRINGACH:
https://www.w3schools.com/python/python_ref_string.asp		
https://www.programiz.com/python-programming/methods/string/join		
	*join() - to na czym ja wywolujemy jest spojnikiem do argumentow podanych w join'ie
			print(", ".join(["a","b","c"]))			
									[zwroci: 'a, b, c' -a, b i c oddzielone spacja i przecinkiem]
	*replace() - na tekscie zastepuje argument pierwszy argumentem drugim 
			print("Witaj swiecie".replace("Witaj","czesc"))			[zwroci: 'Czesc swiecie']
	*startswith() - zwraca prawde jezeli tekst zaczyna sie od wartosci podanej w argumencie
			print("To jest zdanie".startswith("To"))				[zwroci: True]
	*endswith() - zwraca prawde jezeli tekst konczy sie na wartosci podanej w argumencie
			print("To jest zdanie".startswith("."))					[zwroci: False]
	*count('char') - zwraca ilość wystąpień dnego znaku:
			print('Hello World'.count('l'))							#zwróci: 2
	*upper() - wszystkie litery zamienia na duze litery
			print("ZDanie".upper())									[zwroci:'ZDANIE']
	*lower() - wszystkie litery zamienia na male litery
			print("ZDanie".lower())									[zwroci:'zdanie']
	*capitalize() - na wywołanym tekście bierzez pierwszą literę w zdaniu i robi ją dużą. 
		Jeżeli chciałbyś tak zrobić na każdym słowie to teoretycznie móglbyś użyc metody split() 
		ale ponieważ ona nie bierze pod uwagę wielokrotnych spacji to o wiele lepiej byłoby gdybyś
		zrobił to poprzez funkcje enumerate() która na stringu wezmie kazdy znak i stworzy liste
		dwuelementowych krotek (index w stringu, 'znak'):
			for i,c in enumerate(s):
				if i==0 or s[i-1]==" ":
					c=c.upper()
				string+=c  
			return string		
		zapisaną krócej:
			return "".join(c.upper() if i==0 or s[i-1]==" " else c for i,c in enumerate(s))
		WIĘCEJ NA (5ta odpowiedz ze wszystkich):
		https://stackoverflow.com/questions/1549641/how-can-i-capitalize-the-first-letter-of-each-word-in-a-string
	*title() - na wywołanym tekście bierze pierwszą literę i ją powiększa.
	*zfill(int) - do danego tekstu dodaję brakującą ilość miejsc wypełnioną zerami:
			numbers=['1','34','103']
			numbers= [x.zfill(3) for x in numbers]				#zwróci: ['001','034','103']
	*strip() - usunie spacje i tabulacje z początku i końca teksttu:
			(lstrip() i rstrip() - usuwanie inf z poczatku-lewej i konca-prawej tekstu)
			print(" Hello, World  ".strip())						[zwroci: 'Hello world']
			mozesz też użyc w ifie (if data.strip(): będzie odpowiednikiem  if data != "\n":) 
	*find() - wyszukuje index podanego znaku/zwrotu w tekscie (mozna wskazac poczatek i koniec
			poprzez indexy) find() ma 3 argumenty z czego 2 ostatnie sa opcjonalne:
									string.find(value, start, end)
			fruit(find('na'))
			fruit.find('ba','7')		#szukaj indexu gdzie wystepuje 'ba' ale powyzej 7 indeksu
			fruit.find('ba','7','13')	#szukaj indeksu dla 'ba' powyżej 7 ale ponizej 13 indexu
	*sort() sortowanie stringow jest 'case sensitive' - słowa z dużymi literami zawsze będą
			wyprzedzały miejscem słowa z małymi literami dlatego jeżeli nie chcesz zeby wielkośc
			liter miała wpływ na sortowanie słów to użyj argumentu key = str.lower w liscie
			slow. Jezeli masz do czynienia z pojedynczym stringiem zamien go najpierw na liste
					zmienna = list("mAmfrewTRE")
					zmienna.sort(key = str.lower)
					print(zmienna)	
			sortowanie słów względem innych slow moze sie takze odbywac poprzez operatory 
			logiczne: == ; > ; < (tutaj znowu jest to CaseSensitive - duze znaki przed malymi)
			#ROWNE:  word="banana"	#PRZED:  word ="ban" or word="a"  #ZA": word="z"
					if word  == "banana": print("jest rowne słowu \"banana\"")
					elif word < "banana": print("przed słowem \"banana\"")
					elif word > "banana": print("za słowem \"banana\"")
	*split(() - splits the string into substrings if it finds instances of the separator:
			print("Hello, World!".split(",")) 						[zwroci ['Hello', ' World!']
		*jednakże przy zwyklej funkcji split tekst zostanie nam rozdzielony na slowa ale separatorem
		 bedzie jedynie spacja i enter, wyrazy ze znakami interpunkcyjnymi zostaną policzone
		 jako osobne słowa w sosunku do tych bez znaków interpunkcyjnych chociaz mogą to być te 
		 same słowa np: "soft" i "soft!" dlatego powinines użyć funkcji translate na całym tekscie
		 (albo na danej lini) (co spowoduje usuniecie wszystkich tych znakow w tekscie)
			line.translate(str.maketrans(fromstr, tostr, deletestr))	
							#fromstr i tostr mogą pozostać puste a w deletestr musisz podac znaki 
							 interpunkcyhjne ktore jeste w stanie pobrac z modułu string --> 
							 string.punctuation  #: ['!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~']
			import string
			line = line.translate(line.maketrans('', '', string.punctuation))
			PRZYKLAD:
				words =list()
				dictionary = dict()
				fname = input("Enter the file name: ")
				file = open(fname,"r")
				for line in file:
					line.lower()			#jeszcze zmniejsz litery żeby slowa z duzymi literami
											#byly liczone jak te z malymi literami
					import string
					line.translate(line.maketrans("","",string.punctuation))
					words=line.split()
					for word in words:
						dictionary[word]=dictionary.get(word,0)+1
				bigwordCount=None
				bigkey=None
				for word, wordCount in dictionary.items():
					if bigwordCount is None or bigWordCount<wordCount:
						bigWordCount=wordCount
						bigkey=word
				print(bigkey, bigWordCount) 	#LUB
				print(dictionary[bigkey])
	*center(width,'znak'), rjust(width,'znak') i ljust(width,'znak') - żeby utworzyć jakis napis
		w konsoli o ciekawej formie to użyj na napisach metod gdzie width to ilośćznakow w jakich 
		element ma się znajdowac, a 'znak' okresla jakie znaki mają wypełnić podaną resztę przestrzeni.
		Funkcje odpowiednio ustawią napis po stronie ktoa reprezentują, 
		Przykład:
			string=""
			#'.|.'
			for i in range(1,n-1,2):
				string+=('.|.'*i).center(m,'-')+'\n'
			#Welcome
			string+=('WELCOME'.center(m,'-'))+'\n'
			#'.|.'
			for i in range(n-2,0,-2):
				string+=('.|.'*i).center(m,'-')+'\n'
			print(string)
		POWSTANIE:
			---------.|.---------
			------.|..|..|.------
			---.|..|..|..|..|.---
			-------WELCOME-------
			---.|..|..|..|..|.---
			------.|..|..|.------
			---------.|.---------
	*metody sprawdzające z czego składa się dany napis:
			s=list(s)
			if any(i.isalnum() for i in s): print(True) 	#sprawdzenie czy tekst ma liczby i litery
			else: print(False)
			if any(i.isalpha() for i in s): print(True)		#sprawdzenie czy tekst ma litery
			else: print(False)
			if any(i.isdigit() for i in s): print(True)		#sprawdzenie czy tekst ma liczby
			else: print(False)
			if any(i.islower() for i in s): print(True)		#sprawdzenie czy tekst ma male litery
			else: print(False)
			if any(i.isupper() for i in s): print(True)		#sprawdzenie czy tekst ma duze litery
			else: print(False)										
	*wszystkie metody mozna otrzymac poprzez odwolanie sie do konsoli i wpisanie komendy dir()
	 z argumentem wczesniej zadeklarowanym jako string"
					>>>word="slowo"
					>>>dir(word)
	*CIEKAWE ZADANIA:
		*sprawdzenie czy dana liczba lub napis jest palindromem:
				def isPalindrome(s):
					return s == s[::-1]
		
					
3* STRING FORMATTER Formatowanie ciagow String
https://www.w3schools.com/python/python_string_formatting.asp
	*zamiast konkatenacji mozemy uzyc metody format() w ktorej mozna wpisac argumenty ktore 
	 zostana podmienione w Stringu w miejscach gdzie sa umieszczone nawiasy wasowe wraz z 
	 kluczem lub bez niego jezeli wymienione sa w kolejnosci 
	*tego samego klucza w tekscie mozna uzyc wiele razy 
		**klucz moze nie byc wpisany w nawiasy wasowe - bedzie brany pod uwage po kolei 
		  z funkcji format ALBO
				arg = ["Seba", 24]
				tekst = "mam na imie {} i mam {} lat".format(arg[0],arg[1])
		**klucz moze byc zwiazany z indexem argumentu ALBO
				tekst = "imie: {0} i mam {1} lat, nara {0}".format(arg[0],arg[1])
											[zwroci: 'mam na imie Seba i mam 24 lat, nara Seba']
		**klucz moze odpowiadac wpisanej zmiennej (nie mozna laczyc klucza indexowanego ze zmiennymi)
				tekst = "imie: {imie} i mam {wiek} lat ".format(imie = "Marek",wiek = arg[1])
											[zwroci: 'mam na imie Marek i mam 24 lat, nara Marek']
		**w formatowanym tekscie można użyć także kolekcji dictionary. 
				data = {'name': 'Hodor', 'email': 'holdthe@door.com'}
				txt = 'Name: {name} ,Email: {email}'.format(**data)
						#lub
				"{0} {1} {2['hello']}".format("Hello", "World", {'hello': 'sup'})
	*w nawiasach wąsowych może poformatować stringa na:
		*otrzymując różnie sformatowane liczby:
			*liczby o danej liczbie cyfr po przecinku {:.2f}
				pi = 3.14159265
				print('pi is {:.3f}'.format(pi)							#zwroci: 3.142
			*liczby z wcięciami co 3 cifrę:
				print('my number is {:,}'.format(10000000000))			#zwróci: 10,000,000,000
			*wpisując 0 przed liczbami do momentu osiągniecia iluś-cyfrowej liczby {:02} ,{:04}
				for i in range(1,13):
					sentence = '{:02}'.format(i)
					print(sentence)					#zwroci: 01,02,03,04,05,06,07,08,09,10,11,12,13
		*otrzymując różnie sformatowane napisy np z wcięciami: '<'-przed ; '^'-przed i po; '>'-za ;
				"|{:<10}|{:^10}|{:>10}|".format('butter','bread','ham')
															# '|butter    |  bread   |       ham|'		
		*możesz uzyskać rózne typy danych np"
			*poprzez{liczba:b} - typ binarny
				"Binary of {0} is {0:b}".format(12)						#'Binary of 12 is 1100'
			*poprzez{liczba:e} - z liczbą e -'1.566345e+03'
				"Exponent: {0:e}".format(1566.345)						#'Exponent: 1.566345e+03'
		*daty odpowiednio sformatowane wg kodów: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
				import datetime
				my_date=datetime.datetime(2016,9,24,12,01,01)
				print({:%B %d,%Y}.format(my_date))						#zwróci September 24,2016
	*oprocz metody format() uzywanej na danym tekscie mozesz tez formatowac tekst poprzez 
	 literke 'f' przed tekstem i w nawiasach wasowych wpisac wczesniej zdefiniowane zmienne:
				name = "Marek"
				print(f"Nazwa uzytkownika: {name}")
		*możęsz tak samo jak w metodzie format nie tylko korzystać z listy ale także z dictionary:
				my_dict = {'name':'Jennifer', 'surname':'Magican'}
				print(f'My name is {my_dict['name']} and my surname is {my_dict['surname']}')
		8w nawiasah wąsowych możesz dokonywać nawet obliczeń:
				print(f'The result is {4*11}')					#zwróci: The result is 44
	*oprócz opcji wykorzystania nawiasów wąsowych {} jest jeszcze możliwośc formatowania tekstu w 
	 Stringu poprzez starsze opcje czyli: %s, %d tj: wewnątrz Stringa dla stringów podajesz %s a
	 dla liczb %d, za Stringiem znak % i w nawiasach okrągłych argumenty ktore będą pod 
	 postacią %s oraz %d*
			'%s jakis tekst %d' % ('one', '23') 	#zwroci: one jakistekst 23
			"%(first)s %(second)s" % {"first":"Hello", "second":"World"}	#dla słownika
			
########################################## OPERACJE NA PLIKACH (.txt) ######################################
1* OPERACJE NA PLIKACH .TXT
  *W SKRÓCIE:
	*2 OPCJE DO ODCZYTU i ZAPISU:
		A) open()
				file=open(path,"r")
				if file.readable():
					lines=file.readlines()
				file.close()
			**do przechodzenia przez każdą z osobna linii kodu możemy wykorzystać obiekt iteratora i jego 
			  funkcję next, czyli:
				if file.readable():
					line=next(file)
					line2=next(file)
				file.close()
				
				file=open(path,"w")
				file.write("my first line\n")
				file.close()
				
		B) with open()
				with open(path, "r") as file:
					if file.readable():
						lines=file.readlines()
			**do przechodzenia przez każdą z osobna linii kodu możemy wykorzystać obiekt iteratora i jego 
			  funkcję next, czyli:
					if file.readable():
						line=next(file)
						line2=next(file)
				
			    with open("test.txt",'w') as file:
					file.write("my first file\n")
					file.write("This file\n\n")
					
		C) KOPIOWANIE PLIKÓW (odczyt + zapis)
				with open('my_file.txt','r') as rf:
					with open('my_file_copy.txt','w') as wf:
						for line in rf:
							wf.write(line)
  *PODSTAWY:
   https://www.programiz.com/python-programming/file-operation
	*CZYTANIE Z PLIKU:
		- zeby moc otworzyc plik txt to korzystamy z tego co zwraca funkcja open() lub with open()
		- przy funkcji open() trzeba po wszystkim zamknąc plik funkcją close() a przy with open()
		  nie trzeba tego robić. 
		- zarówno przy funkcji open() jak i with open() jeżeli plik nie będzie istniał to wyskoczy wyjątek
		  FileNotFoundException dlatego musisz okalać to wszystko w klauzuli try except:
					try:							try:
						plik=open('plik.txt')			with open('plik.txt,'r') as plik:
						...									...
					except FileNotFoundError:		except FileNotFoundError:
						...								...	
	  *możemy przejść bezpośrednio po pliku:
					plik=open('plik.txt')			with open('plik.txt,'r') as plik:
					for line in plik:					for line in plik:
						print(line)							print(line)
					plik.close()
	  *możęmy też odczytać te linijki poprzez funkcje readlines()
					plik=open('plik.txt')			with open('plik.txt,'r') as plik:
					linijki=plik.readlines()			linijki=plik.readlines()
					for line in linijki:				for line in linijki
						print(line)							print(line)	
					plik.close()
	  *mozemy tez odczytac caly plik jednorazowo przy pomocy funkcji read() albo tyle znakow 
	   ile chcemy wpisując tę ilosc jako pierwszy argument: 
					plik=open(test.txt)				with open('plik.txt,'r') as plik:
					zmienna=plik.read()					zmienna=plik.read()
					zmienna=plik.reead(10)				zmienna=plik.reead(10)
					plik.close()
	  *funkcja plik.readline() zwróci Tobie jedną linijkę tekstu, jeżeli dwa razy po sobie użyjesz tej 
	   komendy to dostaniesz pierwsza i drugą linikę tekstu
					f = open("demofile.txt", "r")	with open("demofile.txt','r'):
					print(f.readline())					print(f.readline())
					print(f.readline())					print(f.readline())
					plik.close()	
	  *możemy też skorzystać z metody Iteratora o nazwie next():
					plik=open('plik.txt')			with open('plik.txt,'r') as plik:
					if plik.readable():				if plik.readable():
					line=next(plik)						line=next(plik)

	*ZAPISYWANIE DO PLIKU:
	  *możęsz użyć funkcji write()
					plik=open('plik.txt','w')		with open('plik.txt,'w') as plik:
					plik.write("costam")				plik.write("costam")
					plik.write("costam2")				plik.write("costam2")
	  *lub możesz użyć printa i w parametrze file podać nazwę pliku:
					plik=open('plik.txt','w')		with open('plik.txt,'w') as plik:
					print("costam", file=plik)			print("costam", file=plik)
					print("costam2", file=plik)			print("costam2", file=plik)
					
  *ROZSZERZENIE:		
	*zamiast korzystać z funkcji open() najlepiej żebyś skorzystał z context managera czyli dodał 
	 słówko with:
					with open('file.txt') as f:
						...
	*funkcja open() może działać na ścieżce WZGLĘDNEJ jak i BEZWZGLĘDNEJ
					f = open("demofile.txt", "r")
					f = open("D:\\myfiles\welcome.txt", "r")
	*funkcja open() ma 2 argumenty: nazwaPliku, trybOtwarcia (domyślnie tryb "r")
			*("r","a","w","x")
	 do tych trybow mozesz dodac jeszcze 2 literki odpowiadajace za to czy bedziesz bral pod
	 uwage plik tekstowy ['t'] czy plik binarny ['b'] (domyślnie jest plik tekstowy "t"): 
			*("rt","at","wt","xt")	 LUB
			*("rb","ab","wb","xb") 
					plik = open("test.txt","wb")
	*podczas czytania z pliku możesz otrzymać informacje aktualnej pozycji/linijki któą czytasz
     poprzez funkcje tell() oraz tę pozycję zmienić na taką jaka ci pasuje poprzez seek():
					f=open("plik.txt", r, encoding="utf-8")
					f.tell();			#zwroci numer pozycji np 56
					f.seek(10);			#zmieniłęś numer czytanej pozycji na 10.
    *ponadto powinineś dodać do tego kodowanie i wszystko umieśći w bloku try: finally: 
					try:
						f = open("test.txt", 'r', encoding='utf-8')
					else:
						f.close()
					finally:
						print("the end")
	*czytanie plików jpg:
					with open('my_file.jpg','rb') as rf:
						with open('my_file_copy.jpg','wb') as wf:
							chunk_size=4096
							rf_chunk=rf.read(chunk_size)
							while len(rf_chunk)>0:
								wf.write(rf_chunk)
								rf_chunk=rf.read(chunk_size)
	*TRYBY OTWARCIA PLIKU - (by sprawdzić tryb skorzystaj z funkcji mode())
		*DO ODCZYTU I ZAPISU - z atrybutem 'r+'
		*DO ODCZYTU - z atrybutem "r"
		  **dodatkowo mozesz uzyc metody readable() ktora zwroci ci prawde jezeli
			plik jest w trybie do odczytu
		*DO ZAPISU z atrybutem "w" 
			**gdy plik nie istnieje to zostanie utworzony (wedlug sciezki wzglednej lub 
			  bezwzglednej jesli wskazesz dokladne miejsce do zapisu)
			**zapis jest za kazdym razem od poczatku -> dotychczasowe dane sa kasowane i 
			  plik jest zapisywany od poczatku
					plik = open("test.txt","w")
					if plik.writable():
						plik.write(input("Wprowadz tekst") + "\n")
					plik.close()	
			**dodatkowo mozesz uzyc metody writable() ktora zwroci ci prawde jezeli
			  plik jest w trybie do zapisu
			**mozesz tez pobrac dane od uzytkownika i od razu je zapisac w pliku
					plik.write(input())				
					plik.write(input("Wprowadz tekst")	[z informacja o wprowadzaniu tekst]
				****[z enterem na koncu linii by kazde kolejne zdanie zaczynalo sie od nowej linii]
					plik.write(input("Wprowadz tekst") + "\n")
				****ta funkcja zwraca ci ilosc bajtow/znakow w danym tekscie
					ile = plik.write(input("Wprowadz tekst") + "\n")
					
		*DO ZAPISU Z APPENDOWANIEM NOWEGO TEKSTU DO STAREGO z atrybutem "a"
			**zapis doda nowe dane do tych ktore juz sie tam znajdowalu -> dotychczasowe dane 
			  nie beda kasowane
					plik = open("test.txt","a")
					if plik.writable():
						plik.write(input("Wprowadz tekst") + "\n")
					plik.close()
			**funkcja write() zwraca ci ilosc bajtow/znakow w danym tekscie
					ile = plik.write(input("Wprowadz tekst") + "\n")
		
		*DO TWORZENIA PLIKOW pod warunkiem tego ze ten plik NIE ISTNIAŁ WCZESNIEJ z atrybutem "x"
			**jezeli plik istnial wczesniej to funkcja zwroci error
			
				 
	
	****USUWANIE PLIKU / FOLDERU:
		**trzeba pobrac modul 'os' 
		**sprawdzic czy plik istnieje przy pomocy metody exitsts("plik.txt") na polu path
		**przy pomocy metdy remove usunac na polu path plik path.remove("plik.txt")
					import os
					if os.path.exists("test.txt")
						os.path.remove("test.txt")
	  *do usuwania folderu użyj funkcji rmdir()
		**też trzeba pobrać modul 'os' i przy pomocy funkcji rmdir() usunac folder
					import os
					os.rmdir("myfolder")


###############################################  WYJATKI  #################################################
3* PODSUMOWANIE WYJATKOW:
TYPY WYJĄTKÓW:		https://www.w3schools.com/python/python_ref_exceptions.asp
	* obslugujemy wyjatki poprzez bloki 'try except finally' tylko przy wywolaniu tejze funkji
	* podnoszenie wyjatku poprzez raise albo wywolywanie asercji realizujesz jedynie przy 
	  definiowaniu funkcji. Ma to służyc głównie sytuacją gdzie chcesz zaakcentować błąd logiczny
	  w działaniu programu a nie taki który jest zdefiniowany w systemie (np TypeError, KeyError itp)
	  (chociaż taki błąd/wyjątek też możesz podnieść)
	* Jeżeli zawrzesz słówko 'raise' w bloku except przy obsłudze błędu [try except finally] to i tak
	  program zostanie przerwany. W tym przypadku jedynie blok finally zawsze zostanie wywolany.

2* TWORZENIE WŁASNYCH WYJĄTKÓW:
   https://www.programiz.com/python-programming/user-defined-exception
	*tworzymy klasę wyjątku która dziedziczy po klasie Exception:
			class CustomError(Exception):
				pass
	 i można go wywołać normalnie poprzez raise w definicji jakieś funkcji:
			def f():
				raise CustomError   	LUB 	  rasie customError("napis ktory sie wyswietli")
				#zwróći: __main__.CustomError		LUB 	  __main__.CustomError An error occurred
	 lub obsłużyć w blokach [try except]
			try:
				...
			except CustomError as c:
				print(c.value, c.message)
	*żeby wywołać taki nasz wyjątek to trzeba przsłonić metodę def init. Przykład:
			class CustomError(Exception){
				def __init__(self, salary, message="Salary is not in (5000, 15000) range"):
					self.salary = salary
					self.message = message
					super().__init__(self.message)
			}
			salary = int(input("Enter salary amount: "))
			if not 5000 < salary < 15000:
				raise SalaryNotInRangeError(salary)
				
1* PODNOSZENIE WYJATKOW raise i WYRZUCANIE asercji:
	*PODNOSZENIE WYJATKU 'raise':
		*wykorzystujesz głównie wewnątrz funkcji. W Javie jest to 'throw'.
					def f(x = "hello"):
						if not type(x) is int:
							raise Exception()
		*służy do tego żeby wyrzucić WŁASNY wyjątek czyli taki którego system sam by nie podniósł. To 
		 tak jak byś definiował swój własny wyjatek ale zamiast robić to poprzez klasę by móc korzystać 
		 z niego wielokrotnie i w wielu miejscach to wykorzystujesz raise do podniesienia go jednorazowo.
					def f(x = "hello"):
						if not type(x) is int:
							raise TypeError()
		*przy podniesieniu wyjatku mozna tez dodac swoja wlasna wiadomosc w nawiasach okraglych:
					def f():
						x = "hello"
						if not type(x) is int:
							raise Excpetionr("Only integers are allowed")
		*poprzez raise mozna podnosic nie tylko wyjatki wlasne ale także te juz zdefiniowane przez system:	
					def dzielenie(x, y):
						if y == 0:
							raise ZeroDivisionError("Dzielenie przez zero")
						print(x/y)
		*potem musisz obsłużyć wywołanie takiej funkcji wewnątrz bloku try except. W przeciwnym wypadku 
		 przez słówko raise zostanie wyrzucony błąd i program zostanie przerwany.
					try:
						print(1)
						dzielenie(2,0)
						print(2)
					except ZeroDivisionError:
						print('obsługa wyjątków')			#zwróci: 1 'obsługa wyjątków'
															#bez bloku except wyskoczyłoby:
															#	raise ZeroDivisionError
		*tak samo jak użyjesz słówka 'raise rodzajError' wewnątrz bloku try albo po prostu (bez bycia w 
		 funkcji i bez bycia w bloku try). Też trzeba potem dodać blok except gdzie dodasz rodzajError 
		 albo samo except. W przeciwnym wypadku program wyrzuci błąd i zostanie przerwany. 
					try:
						if y == 0:
							raise ValueError
						print(x/y)
					except:
						print(7,7,7) 
		*jeżeli słówko raise umieścisz wewnątrz bloku [except] to wykona sie blok finally ale nic 
		 poza nim - program zostanie przerwany (mimo tego że teoretycznie zrobiłeś obsługę wyjątku)
		 (pod warunkiem że w bloku except umiescisz w ostatniej linii samo slowko 'raise')
			try:
				dzielenie(2, 0)
			except ZeroDivisionError:
				print("Blad")
				raise
			finally:
				print("dalsza czesc [programu")		 
	*ASERCJA (upewnienie) 'assert' 
		*przy asercji nalezy wygenerowac jakis warunek logiczny i jezeli ten warunek sie NIE 
		 sprawdzi to przy wywolaniu funkcji zostanie wyrzucony specjalny typ wyjatku (asercji) 
		 który przerwie dzialanie programu 
		*działą tak samo jak słóko raise
		*asercji uzywa sie po to zeby byc pewnym tego ze funkcja bedzie zwracac dana wartosc 
		 i uzywa sie tego tylko na czas tworzenia programu a nie gdy juz jest gotowy program
		*przy asercji, po przecinku po warunku logicznym mozna wypisac co ma zostac wyswietlone
		 w momencie podniesienia wyjatku
					def dzielenie(x, y):
						assert y!=0, " y jest rowne 0"
						print(x/y)
					dzielenie(2, 0)				#zwróci: AssertionError:  y jest rowne 0]
						
0* OBSLUGA WYJAKOW   [try ; except ; finally]:
TYPY WYJĄTKÓW:		https://www.w3schools.com/python/python_ref_exceptions.asp
					https://www.programiz.com/python-programming/exceptions
	*wyjątki dzielimy na:
		*SKŁADNIOWE (syntax)
		*LOGICZNE (logical) np (FileNotFoundError, ZeroDivisionError,ImportError)
	*obsługę wyjątków robi się po to żeby program nadal działał mimo wystąpienia jakiegoś błędu 
	 a nie żeby zamiast tego wszystko się przerwało tak że trzebaby było uruchamiać wszystko 
	 od początku 
	*nieobsluzone wyjatki - python dla bezpieczenstwa przerywa dalsze dzialanie programu 
	*jezeli wyjatek jest obsluzony to przy jakims bledzie program przerywa czytanie dalszych 
	 linijek w blok try i od razu przechodzi do bloku except
	*obsluzenie wyjatkow odbywa sie poprzez poprzez 2 bloki: try i except i opcjonalnie finally
	 mozna jeszcze dodac else ktory wywoła się wtedy gdy nie zostanie podniesiony żaden wyjątek:
		try:
		except:
		else:
		finally:
	*wyjątkom w bloku except możesz dodać takze aliasy:
				try:
					...
				except ZeroDivisionError as zerr:
					...
	*Przykład:
					x = 4
					y = 0
					z = "mama"
					lista = []
					try:
						print(x/y) 				
		#blok except - po wystapieniu wyjatku dalsze linijki sie nie zrealizuja od raz przejscie do
		#bloku except
						print(x/z) 			
						print(lista[0]/y)
						print("linijka dalsza w bloku TRY ktora sie nie wykona")
					except ZeroDivisionError:					
						print("nastapilo dzielenie przez zero")
		  #mozesz wybrac 1 wyjatek do obslugi lub mozesz wybrac tez kilka wyjatkow 
					except (IndexError, TypeError):				 
						print("1 z dwoch wyjatkow")
					except:
						print("jakis inny blad")
		#blok finally - jeżeli zostanie umieszczny w kodzie to wykona się zawsze. (blok opcjonalny -
		#czyli nie trzeba umieszczac go w kodzie):
					finally:	
						print("wykona sie zawzsze - niezaleznie czy wyjatek czy nie")
					print("dalsze instrukcje")
		#blok else - to to co tam bedzie wykona sie zawsze wtedy gdy wykona sie cala instrukcja try
		#bez wystąpienia błędu (blok opcjonalny czyli nie trzeba umieszczac go w kodzie):
					try:
						a=5/3
					except:
						print("Blad")
					else:
						print("else wykona sie zawsze gdy nie wystapi blad")
					finally:
						print("wykona sie zawsze nawet wtedy gdy pojawi się blad")
	*KILKA PRZYKŁADÓW WYJĄTKÓW:
		*ZeroDivisionError - dzielenie przez zero
		*ValueError - rigth type but an inappropriate values
		*re.error - do sprawdzenia czy REGEX jest dobry czy nie (z wykorzystaniem metody re.compile)
		 https://www.geeksforgeeks.org/how-to-check-a-valid-regex-string-using-python/
					try:
						re.compile(patternString)
						print(True)
					except re.error:
						print(False)

			
############################################# FUNKCJE | REKURSJA ##########################################
3*Funkcje REKURENCYJNE (rekursja):
	*tak samo jak w innych jezkach
	*najwazniejsze zeby pamietac o przypadku podstawowym
		def silnia(x):
			if x <= 1:			#przypadek podstawowy
				return 1
			else:
				return x * silnia(x-1)
	*w Pythonie limit rekursji wynosi 1000 . Przy przekroczeniu tego poziomu wyskoczy błąd 
	 RecursionError
	*MEMOIZATION:
		*ponieważ rekursja zabiera bardzo dużo RAMu to dobrze jest użyć MEMOIZATION
		*polega to na stworzeniu dodatkowego słownika(Dictionary) na zewnątrz funkcji rekurencyjnej  
		 który przetrzymuję odpowiednio wyliczone wartości dla poszczególnych przypadków. Dzięki temu 
		 przy większych przypadkach funkcja rekurencyjna nie tworzy całego ogromnego drzewa aż do 
		 przypadku podstawowego tylko używa już wcześniej wyliczonych mniejszych przypadków.
				dictionary={}
				def fibonnaci(n):
					if n in dictionary.keys():
						return dictionary.get(n)
					if n==1 or n==2:
						value=1
					elif>2:
						value=fibonnaci(n-1)+fibonnaci(n-2)
					dictionary[n]=value
					return value
		*oprócz takiego dopisania sobie zewntrznego słownika możńa zrobić to samo poprzez użycie 
		 dekoratora lru_cache() z modułu functools():
				from functools import lru_cache
				@lru_cache(maxsize=128)						#musisz podać parametr maxsize 
				def fibonnaci(n):
					if n==1 or n==2:
						return 1
					elif n>2
						return fibonnaci(n-1)+fibonnaci(n-2)

2* PRZECIĄZANIE FUNKCJI: 
	*w pythonie zamiast przeciazania funkcji masz jej nadpisanie:
		def dodaj(arg1):
			print(arg1+1)
		def dodaj(arg1, arg2):
			print(arg1+arg2)
		dodaj(2, 3)
		#dodaj(2)   	#ta funkcja nie zostanie wywolana bo zostala nadpisana 
						# przez kolejna o tej samej nazwie ktora znajduje sie ponizej
	*a PRZECIAZANIE FUNKCJI mozna uzyskac poprzez ustanowienie 
	 ze argument bedzie opcjonalny poprzez przypisanie mu stalej 
			def dodaj(arg1, arg2=1):
				print(arg1+arg2)
			dodaj(2)		#wynik: 3
			dodaj(2,3)		#wynik: 5
		*to czego nie mozna zrobic to podanie kolejnego argumentu 
		 po argumencie opcjonalnym ==> arg3 powinno sie podac przed arg2
			def dodaj ((arg1, arg2 = 1, arg3):			
				
1* Funkcje:
	*WSTĘP:
		*w pierwszej linijce po zadeklarowaniu funkcji zawsze powinineś opisać co dokładnie robi 
		 funkcja poprzez opisanie niej w trzech cudzysłowach --> dzięki temu po wpisaniu funkcji
		 pomocniczej help z nazwą zadeklarowanej funkcji od razu pojawi się ten komentarz:
					def func():
						'''function return nothing and do nothing'''
						pass
					help(func)						#zwróci: function return nothing and do nothing
	*PODSTAWY:
		*nie mozna wywolywac funkcji przed jej wywolaniem - istnienie funkcji zaczyna sie po jej 
		 zadeklarowaniu
		*w pythonie nie podzialu na PROCEDURY (voidy) a FUNKCJE ktore cos zwracają
					def funkcja1():
						print("tata")
					def funkcja2():
						return "mama"
					funkcja1()				#wynik: tata
					print(funkcja2())		#wynik: mama
		*do zmiennej mozna przypisac nazwe funkjci (nie jej wynik) i wtedy zmienna staje sie funkcja
					def func(x):
						return x*x
					zmienna =func
					print(zmienna(5)		#wynik: 25
	*ARGUMENTY w Pythonie:
		*przy podawaniu argumentow nie definiujemy ich typow
		*przekazując argumenty do funkcji i pracując na nich pracujesz na orginałach (referencjach)
		 a nie na kopiach 
		*w pythonie mozna podac jako argument inna funkcje bez argumentu - wtedy specjalnie podaje 
		 sie ja bez nawiasow okraglych tylko tak jak zmienna gdyż ty nie chcesz tej funkcji wywoływać
		 tylko podać do niej referencje.
					def func1(z):
						return z**2
					def func2(f1, x):
						return f1(x)
					print(func2(func1,5))   #wynik: 25
		*możesz też wywołać funkcje z nazwami jej argumentów i poprzez wypisanie tychze nazw 
		 argumentów możesz podać te argumenty w losowej kolejności:
					def greet(name, msg):
						print(name, msg);
					greet(name = "Bruce",msg = "How do you do?")
					greet(msg = "How do you do?", name = "Bruce")
		 możesz podać też te argumenty częsciowo z nazwami argumentów a cześciowo nie ale 
		 wtedy musisz pamiętać o kolejnośći podawania argumentów 
					greet("Bruce",msg = "How do you do?");
	*ARGUMENTY OPCJONALNE / DOMYŚLNE w Pythonie:
		*w pythonie mozesz podac domyślna wartość dla argumentu, przy deklarowaniu funkcji. 
		 Wtedy nie trzeba podawac tego argumentu przy wywołaniu:
				def my_function(country = "Norway"):
				  print("I am from " + country)	 
				my_function()
		*przy deklarowaniu funkcji argument domyślny nie może znajdować się przed argumentem
		 właściwym.
				def my_function(name, country='Norway');
					print(f"My name is {name} and I'm from {country}")
				my(function('Marek')		#'My name is Marek, and I'm from Norway'
	  ! *MUTABLE DEFAULT ARGUMENTS - (mutowalne argumenty domyślne) - przy wywołaniu funkcji z 
		 argumentem domyślnym bez podania tylko z użyciem domyślnej wartośći trzeba pamiętać o tym 
		 że taki argument domyślny jest tworzony TYLKO RAZ podczas pierwszego wywołania takiej 
		 funkcji i jeżeli jest mutowalny to nie będzie tworzony za każdym razem od nowa podczas 
		 kolejnego wywołania funkcji:
		   *w pierwszym przykładzie podajesz pustą listę jako argument domyślny:
				def add(name, emp_list=[]):
					emp_list.append(name)
					print(emp_list)
				add('Marek')		#zwróci: ['Marek']
				add('Darek')		#zwróci: ['Marek', 'Darek']   ,zamiast ['Darek'] 
									#nawet po wywołaniu argumentu z listą argument z domyślną 
									#listą będzie przechowywany 
				add('Andrzej', ['Gary'])
				add('Jurek')		#zwróci: ['Marek', 'Darek', 'Jurek']
			dlatego NIE PODAJĘ SIĘ MUTOWALNYCH OBIEKTÓW do argumentów domyślnych !!! tylko IMUTABLE 
			czyli zamiast pustej listy powinineś podać argument None:
				def add(name, emp_list=None):
					if emp_list==None:
						emp_list=[]
					emp_list.append(name)
					print(emp_list)
		   *innym przykładem jest podanie datetime.now() jako argument domyślny:
				import time
				import datetime 
				def display_time(timing=datetime.datetime.now())
					print(timing.strftime('%H:%M:%S))
				display_time()		#zwróci: 	8:47
				time.sleep(60)
				display_time()		#zwróci: 	8:47	zamiast 8.48
				time.sleep(60)
				display_time()		#zwróci: 	8:47	zamiast 8:49
			znowu powinineś podać None do argumentu domyślnego:
				import time
				import datetime 
				def display_time(timing=None)
					if timing==None:
						timing==datetime.datetime.now()
					print(timing.strftime('%H:%M:%S))
				display_time()		#zwróci: 	8:47
				time.sleep(60)
				display_time()		#zwróci: 	8.48
				time.sleep(60)
				display_time()		#zwróci: 	8:49
				
	*ARBITRARY ARGUMENTS:
		*ARBITRARY ARGUMENTS *args - jeśli nie wiesz jak dużo danego argumentow bedzie w danej 
		 funkcji (moze byc tez zero) to dodaj '*' przed danym argumentem (domyślnie tak się
		 wpisuję: *args) - wtedy w dane miejsce funkcje przyjmie krotke tych argumentow
				def my_function(*kids):
				  print("The youngest child is " + kids[2])
				my_function("Emil", "Tobias", "Linus")
		*ARBITRARY ARGUMENTS **kwargs - jeśli nie wiesz jak dużo danego argumentu będzie w danej
		 funkcji (moze tez byc zero) ale już wiesz żeby te argumenty miały postać słownika 
		 (dictionary) to ** dodaj przed danym argumentem (domyślnie wpisuję się **kwargs) - wtedy
		 w dane miejsce funkcja przyjmie kolekcje dictionary tych argumentów:
				def my_function(**kid):
				  print("His last name is " + kid["lname"])
				my_function(fname = "Tobias", lname = "Refsnes")
					 
######################################## IF | PETLA WHILE | PĘTLA FOR #####################################
1* Petla obiektowa FOR i funkcja RANGE
	*mozesz iterowac petla FOR przez kazdy element kolekcji (NIE TYLKO LISTY) - w pythonie
	 inaczej niz winnych jezykach programowania, pętla for dziala troche jak iterator w obiektach
			for x in lista:
				print(x)
		*mozesz iterowac tez po stringu ktory jest traktowany jak lista
			for x in "banana":
				print(x)
		*po przeiterowaniu po pętli możesz dostac się do zmiennej x któa będzie mieć przypisaną
		 ostatnią wartość z iterowanej pętli (w tym przypadku będzie to 'a')
		*możesz iterować przez wiele elementów W LISCIE STWORZONEJ ZE SŁOWNIKA(dzieki funkcji 
		 items() - zamieniającej klucz i wartosc na krotke) albo w LISCIE KROTEK:
			#DLA SLOWNIKA:
			slownik={'c':10, 'a':1, 'b':22}
			for key, value in slownik.items():
				print(key, value)									#zwroci: c 10 ; a 1 ; b 22
				
			#DLA KROTKI:
			b=('r',10,22)
			c=('g',33,21)
			d=('r',9,55)
			e=('r',9,56)
			f=('z',1,1)
			list_of_tuples=[b,c,d,e,f]
			for m1,m2,m3 list_of_tuples:
				print(m1,m2,m3)				#zwroci: r 10 22 ; g 33 21 ; r 9 55 ; r 9 56 ; z 1 1
			
			#TE LISTY mozna tez posortowac poprzez funkcje sorted (patrz dział krotek): 
			for key, value in sorted(slownik.items()):
				print(key, value)									#zwroci: a 1 ; b 22 ; c 10 
			for m1,m2,m3 sorted(list_of_tuples):
				print(m1,m2,m3)				#zwroci: g 33 21 ; r 10 22 ; r 9 55 ; r 9 56 ; z 1 1
				
				
	*FUNKCJA RANGE()- [ZWRACA LISTE liczb o podanej wielkosci i parametrach tych liczb]
		*zwraca podany zasieg od 0 
			print(range(10) 	#wynik: [0,10] (od zera do 10 ale bez liczby 10)
        *zwraca podany zasieg od podanej liczby
			print(range(3, 8))        #wynik: [3,8] (od 3 do 8 ale bez liczby 8)
        *przekonwertowanie range'a na liste:
			print(list(range(10))) 	  #wynik: [0,1,2,3,4,5,6,7,8,9]
	*ITEROWANIE przez ZASIĘG funkcji range
			for x in range(10):
				print(x)			  #wynik: 0 1 2 3 4 5 6 7 8 9 
	*3ci ARGUMENT w funkcji range - dotyczacy wielkosci skoku
			for r in range(1,11,2):    #wielkosc skoku co 2 elementy;; wynik: 1,3,5,7,9
				print(r)

	*DODATKI:
		*mozesz przerwać pętle poprzez instrukcje break:
			fruits = ["apple", "banana", "cherry"]
			for x in fruits:
			  print(x)
			  if x == "banana":
				break		
		*mozesz nie dokończyć danej iteracji poprzez instrukcję continue:
			fruits = ["apple", "banana", "cherry"]
			for x in fruits:
			  if x == "banana":
				continue
			  print(x)			
		*mozesz użyc słowa kluczowego pass żeby interpreter nie pokazywał błedów przy pustej
		 niezapisanej funkcji
			for x in [0, 1, 2]:
			  pass
			  
	#### INNE ZASTOSOWANIE ELSE dla PĘTLI FOR:
	*PRZY PĘTLI FOR: gdy wpiszemy else po zakończeniu petli for TO JEŻELI tej pętli nie 
	 przerwiemy instrukcją break to po pętli for wykonają się instrukcje w else'ie
			for i in range(10):
				if i>7:
					print("mama")
			else:
				print("koniec")
		
2* PETLA WHILE
	*skladnia:
		while i < 5:
			print(i)
			i += 1
	*petla nieskonczona:
		while True:
			print('cos')
	*taka petle da sie przerwac poprzez slowo kluczowe      break
		while True:
			print(i)
			i += 1
			if i == 10:
				break
	*jezeli chcesz przeskoczyc jakis fragment petli to dodajesz slowo kluczowe     continue
		while i < 20:
			i+=1
			if i % 2 == 1:
				continue
			print(i)
			
	#### INNE ZASTOSOWANIE ELSE dla PĘTLI WHILE:		
	*PRZY PĘTLI WHILE - gdy wpiszemy else po zakonczeniu pętli while TO JEŻELI tej pętli nie 
	 przerwiemy instrukcją break to po pętli while wykonają się instrukcje w else'ie
			i = 1
			while i < 6:
			  print(i)
			  i += 1
			else:
			  print("i is no longer less than 6")
	
1*	    #### SKRÓCONY OPERATOR IF:
	*najpierw podajemy: co ma się wykonać, if warunek, else co ma sie wykonac gdy nieprawda" 
	*przy elsie gdy chcesz zrobić PRZYPISANIE to nie rób przypisania do zmiennej tylko postaw sam 
	 parametr (tak jakby było już po znaku przypisania!)
			for i in range(1,len(string)+1): string2+=string[i-1] if i%max_width!=0 else string[i-1]+'\n' 
			a=100 if 5>2 else -100
			print(a) 
	*ALE gdy chcesz wykonać jakąś metodę jak print TO nie wystarczy ze wpiszesz sam parametr TYLKO MUSISZ
	 wywołać tę metodę także po ELSE:
			print("PRAWDA ") if 5>2 else print("Nieprawda")
			import math
			math.sin(math.radians(90)) if 5<2 else math.sin(math.radians(0))
	*jeżeliw list comprehensions ze skroconym operatorem if, else w elsie nie chcesz wykonywać rzadnej 
	 operacji gdyż np chcesz zeby zwrociło Tobie listę z przefiltrowanej listy przez dany warunek to ifa 
	 stawiasz po forze zamiast przed:
			lower_lst=[x for x in lst if x.islower()]
	*gdy ifa w listcomprehensions stawiasz na koncu to możęsz postawic tez tam ich kilka i wtedy wykona 
	 sie najpierw ten wewntrzny a poniej dopiero zewnetrzny:
			digit_odd_lst=sorted([x for x in lst if x.isdigit() if int(x)%2!=0])		
		#lub mozna to zrobić w dwoch petlach:
			digit_odd_lst=[y for y in sorted([x for x in lst if x.isdigit()]) if int(y)%2!=0]
			
0* IFy:
	* bez nawiasow i bez klamer ;; kończy sie dwukropkiem :
	* jek jest bardziej skomplikowane rownanie to normalnie mozesz uzyc nawiasow
	* miedzy jednym poziomem a drugim 4 wciecia (albo tabulator)
	* zamiast else if masz elif
		x = 4
		if 5 < x:				|| 				if False:		    
			print('Prawda')
		elif 5 == x:
			print('Prawda')
		else 
			print('Falsz')
	*operatory porownania/spojniki logiczne:
		**AND - and 	(zamiast &&)  !!! ma wyższą wagę od operatora or 
										 (AND bedzie wykonywany pierwszy)
		**OR  - or		(zamiast ||)
		**not rownanie - negacja  
	*and     ma wyzsza wage od    or    (bedzie wykonywany pierwszy)
			if True or False and False:
				print("True")
			else:
				print("False")
						[zwroci: "TRUE" ze wzgledu na to ze operator and wykona sie pierwszy]
	*jesli tylko jedna linijka to mozesz w if'ie od razu po dwukropku wpisac co ma sie wykonac
			if a > b: print("a is greater than b")
	*if statement can not be empty but you can use keyword 'pass' in it
	
################################################ PODSTAWY #################################################
2* Składnia:
	*PODSTAWOWE FUNKCJE: https://www.w3schools.com/python/python_ref_functions.asp
	*PORADY WSTEPNE:
		**wciecia mozesz takie jakie chcesz ale przyjelo sie ze 1 tab lub 4 spacje - nie mozńa tego 
		  miksować bo pojawia się Indentation error - najelepiej znaleźć edytor który automatycznie
		  będzie zajmował 4 spacje tabulatorem albo tabulator 4 spaccjami. W prefereces będzie to 
		  często właściwość: 'translate_tabs_to_spaces': true,
		**najlepiej po kazdej operacji lub zmiennej od kolejnej oddzielaj poprzez SPACJE 
		**kod zero w interpreterze wskazuje na to że kod wykonał sie poprawnie
		**bez srednikow na koncu
	* KOMENTARZE i CUDZYSŁOWY:
		*hashtag # lub komentarz blokowy - na start: ''' i na koncu tez: ''' 
		*jeżeli wewnątrz Stringa chcesz użyć cudzysłowa to powineneś dla strina
		 użyć innego cudzysłowa:
				zmienna= "I'm a student"
				zmienna= 'I love the quote "Be or not to be"'
		*jeżeli chcesz użyć dwóch rodzajów cudzysłowiów w jednym Stringu to musisz to okalać
		 potrójnym cudzysłowiem:
				zmienna ='''I'm student and I love the quote "Be or not to be"'''
	* PRINT() - funkcja do wyświetlania:
		**funkcja print() od razu tworzy entera po wykonaniu (przechodzi do kolejnej linii)
		** konstrukcja printa() to: print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
			**wewnatrz funkcji print mozesz wybrac jaki chcesz separator zeby był: 
				print(*range(1,10),sep="-")		
									[zwroci: rozpakuj zakres 1-10 i oddziel liczby myslnikiem]
			**jezeli nie chcesz żeby print konczyl sie eneterem to przypisz do opcjonalnego parametru
			  end znak pusty czyli end="" 		|| 		print(i, end="")		  
			**przy str wystepuje KONKATENACJA poprzez znak + LUB poprzez wypisanie po przecinku
	* DO USUNIECIA zmiennej sluzy operator del 
			del x
	* ZMIENNE 
		**deklaracja typow odbywa sie niejawnie - python sam okresla jaki to jest typ danych 
		**w PYTHONIE nie przypisujesz wartośći do zmiennych tylko przypisuję referencje do obiektu 
		  DO zmiennej.
		**jednakże jestes w stanie stworzyc obiekt o podanym typie bez nadawania mu wartosci
		  i mozesz przypisac go do danej zmiennej (tylko musisz pamietac że do tej zmiennej 
		  do której przypiszesz ten obiekt, może w każdej chwili zostac przypisany jakikolwiek 
		  inny obiekt o innym typie) - takie przypisanie odbywa się poprzez zaincjowanie 
		  obiektu "pustą konwersją" czyli:
				zmienna = list()  LUB  zmienna=[]		#pusta List
				zmienna = dict()  LUB  zmienna={}		#pusty Dictionary
				zmienna = int()							#pusty int
				zmienna = float()						#pusty float
		**wpisujesz bez typow a nwet po przypisaniu mozesz przypisac wartosc o innym typie
		**w zmienną musisz zawrzeć w jednej linii albo możesz to zrobić w kilku liniach dodając
		  przed rozpoczęciem nowej linii znak backslacha '\'
				zmienna= 1 + 2 + 3 + \
						 4 + 5 + 6 + \
						 7 + 8			
		**DATA TYPES (TYPY DANYCH):
			* Text Type:		str
			* Numeric Types:	int (1, -1) [positive or negative wthout unlimited length]
								float (1.1) [containing one or more decimals]
								Decimal - musisz pobrać moduł Decimal
									używa się go tylko przy finansowych operacjach bo 
									jest bardziej dokładny w zmiennoprzecinkowych liczbach
									niż float. Trzeba pobrać import Decimal i tworzy się: Decimal(1.1)
									--> patrz:https://www.programiz.com/python-programming/numbers
								complex (1j) [Complex numbers are written with a "j" as the 
								imaginary part; x = 3+5j || print(x) || zwroci: (3+5j)
									-> x.real  #zwroci częśc realną 
									-> x.imag  #zwroci czesc wyimaginowaną 
			* Boolean Type:		bool (True, False) [od duzych liter sie zaczyna]
			* Binary Types:		bytes, bytearray, memoryview
			* Collections:		(range), list, tuple, dict, set, frozenset
			* None:				używa się dla pól które nie zostały jeszcze stworzone 
		**Zamiana integera na pochodne typy zmiennych:
			a = int(3)
			oct(a) - osemkowy
			hex(a) - szesnastkowy
			bin(a) - binarny 
		**mozesz sprawdzic jakiego typu jest zmienna poprzez funkcje 	
			type(zmienna)						[zwroci przy print'cie: 	<class 'str'>]
		**BOOLEAN TYPE (wszystko TRUE chyba że puste albo równe 0)
			*bool() - to evalute values and variables (True or False):	
				print(bool("Hello"))
			*bool() - to evalute objects by overloading class function - __len__ 
				class myclass():
				  def __len__(self):
					return 0
				myobj = myclass()
				print(bool(myobj))			
		  *Almost any value is evaluated to True if it has some sort of content.
		  *Any string is True, except empty strings.
		  *Any number is True, except 0.
		  *Any list, tuple, set, and dictionary are True, except empty ones.
		  *In Python 0 is False; 1 is True so:
					5 + True 	#returns 6 (5+1)
					5 + False 	#returns 5 (5+0)
		**GLOBAL - If you use the global keyword inside the function, the variable belongs
		  to the global scope. PAMIĘTAJ: Najpierw musisz zadeklarować że zmienna jest globalna. 
		  Dopiero później możesz do niej przypisywać wartości:
		  WIĘCEJ O ZAWIŁOŚĆIACH GLOBAL: https://www.programiz.com/python-programming/global-keyword
				def outer_function():
					global a
					a = 20
					def inner_function():
						global a
						a = 30
						print('a1 =', a)
					inner_function()
					print('a2 =', a)
				a = 10
				outer_function()			#przez global zwroci: a1=30, a2=30, a3=30
				print('a3 =', a)			#zamiast a1=30, a2=20, a3=10 gdyby nie było global
		**NONLOCAL - o wiele częściej niż global występuję nonlocal. 
			*Działa ona prawie tak samo jak global ale różni się tym że działa tylko w funkcjach 
			 wewnetrznych czyli tych które występują wewnątrz innej funkcji 
			*Najpierw trzeba stworzyć zmienną w funkcji zewnętrznej a później w funkcji wewnętrznej
			 można ją ewentualnie uczynić nonlocal co oznacza że jakiekolwiek zmiany dokonane w
			 funkcji wewnętrznej będą miały wpływ na tę zmienną z funkcji zewnętrznej:
					a = 10
					def outer_function():
						a = 20
						def inner_function():
							nonlocal a
							a= 30
							print('a1 =', a)
						inner_function()
						print('a2 =', a)
					print('a3 =', a)				
					outer_function()			#przez nonlocal zwroci: a1=30, a2=30, a3=10
		**poprzez kastowanie mozesz nadac konkretny typ zmiennej:
			x = str(3) 
			y = int(3)
			z = float(3)
		**Konwersja typow:
			**NIE WOLNO mieszac typow zmiennych przy konkatenacji:
			  NIE WOLNO:: print(int(a) + b) 
			*inty na stringi poprzez funkcje str()
				print(str(a) + str(b))
			*na inne typy:
				int(x)
				float(y)
				complex(z)
		**UNPACKING - Python allows you extract the values from collection into variables:
			fruits = ["apple", "banana", "cherry"]
			x, y, z = fruits		
	* INPUT() - pobieranie danych z konsoli poprzez:
		**input() w pythonie 2.0 był funkcją o nazwie raw_input()
		**input("Podaj w input'cie to co Cie interesuje: ")
		**input zawsze przyjmuje dane jako stringi --> nigdy jako liczby nawet gdy je wpiszesz
		**oprócz funkcji input() która przestanie pobierać dane z konsoli po wciśnieciu ENTERA
		  możesz uzyć funkcji read() na obiekcie stdin z biblioteki sys:
			import sys
			txt=sys.stdin.read()
		**przy funkcji input() python bierze dane wejsciowe za typ string dlatego ZAWSZE
		  trzeba dokonac konwersji typow:
			a = input(" podaj liczbe 1: ")			[5]
			b = input(" podaj liczbe 2: ")			[5]
			print(a + b)					[wynik: 55] !!!!!!!!!!!!!!
		**python potraktowal to jako Stringi dlatego przy input'cie musisz to przekonwertowac 
		  na typ int ALBO float poprzez funkcje int() ALBO float()
			print(int(a) + int(b))
	*Kolejność wykonywania działań: nawiasy, potęgowanie, mnożenieidzielenie, dodawanie 
	 oraz wszystko dzieje się od lewej do prawej, czyli jezel iznajduje si ena tym samym
	 poziomie to idzie od lewej do prawej
	* OPERATORY MATEMATYCZNE rozszerzone:
		- dzielenie i mnożenie intow zawsze da wynik we float'cie
		- modulo: 5 % 3		 [wynik:2]
		- dzielenie z wynikiem calkowitym:  5 // 2  	[wynik:1]
		- potegowanie: 2 ** 3  	[wynik:8]
	*OPERATORY PRZYPISANIA:
		* PYTHON nie ma inkrementacji ani dekrementacji  (x-- ; x++) - to nie zadziala
			=		x = 5		x = 5	
			+=		x += 3		x = x + 3	
			-=		x -= 3		x = x - 3	
			*=		x *= 3		x = x * 3	
			/=		x /= 3		x = x / 3	
			%=		x %= 3		x = x % 3	
			//=		x //= 3		x = x // 3	
			**=		x **= 3		x = x ** 3
			------------BITOWE:-----------
			&=		x &= 3		x = x & 3	
			|=		x |= 3		x = x | 3	
			^=		x ^= 3		x = x ^ 3	
			>>=		x >>= 3		x = x >> 3	
			<<=		x <<= 3		x = x << 3
	*OPERATORY LOGICZNE:
		* W PYTHONIE nie ma && albo || tylko:
			and		if x==0 and y==2
			or		if x==0 or y==2
			not		if not(x==0 and y==2
			-----------------------------
			is		if x is y		(dopasowuje zarowno typy i wartosci)
			is not 	if x is not y	(dopasowuje zarowno typy i wartosci)
			-----------------------------
			in 		if x in y
			not in  if x not in y
	*OPERATORY BITOWE:
			& 	AND	Sets each bit to 1 if both bits are 1
			|	OR	Sets each bit to 1 if one of two bits is 1
			 ^	XOR	Sets each bit to 1 if only one of two bits is 1
			~ 	NOT	Inverts all the bits
			<<	Zero fill left shift	Shift left by pushing zeros in from the right 
										and let the leftmost bits fall off
			>>	Signed right shift	Shift right by pushing copies of the leftmost bit 
										in from the left, and let the rightmost bits fall off
										
	*OPERATORY PRZYNALEŻNOŚCI (Identity) ( IS, IS NOT ) sprawdzają czy 2 zmienne leżą w tym samym
 	 miejscu w pamięci czyli sprawdza czy te 2 zmienne to te same obiekty; W przypadku typów prostych
	 2 różne zmienne o tych samych wartością wskaża prawdę:
			x1 = 5
			y1 = 5
			x2 = 'Hello'
			y2 = 'Hello'
			x3 = [1,2,3]
			y3 = [1,2,3]
			print(x1 is y1) 							# Output: True
			print(x2 is y2)								# Output: True
			print(x3 is y3)								# Output: False
			
	*OPERATORY 'WYSTĘPOWANIA W' (MEMBERSHIP) (IN, NOT IN):
			x = 'Hello world'
			y = {1:'a',2:'b'}
			print('H' in x)								# Output: True
			print('Hello' in x)							# Output: True
			print(1 in y)								# Output: True
			print('a' in y)								# Output: False
			
1* Właściwości i SKROTY:
	*To defining scope of the class or loop or another structure Python relies on indentation,
     using whitespace. Python uses indentation to indicate a block of code. Other programming 
     languages often use curly-brackets for this purpose
	*nie jest jezykiem ściśle typowanym czyli nie mamy podgladu do typow jego zmiennych
	*jezyk wyzszego poziomu bez niuansow takich jak w jezykach niskiego poziomu\
		- wskazniki
		- nawiasy i sredniki utp
	* SKROTY PYCHARM:
		* CTRL + SHIFT + F10 - start INTERPRETER
		* CTRL + D	- KOPIOWANIE linii tam gdzie zaznaczony kursor
		* CTRL + SHIFT + strzalka - przenosisz strzalkami dana linie powyzej albo ponizej 
	* SKRÓTY VISUALSTUDIO:
		*będac w konsoli w folderze projektu wpisujesz	' code . '	i automatycznie otwiera Tobie 
		 projekt w Visual Studio
		*FIND & REPLACE:
			*zaznaczasz tekst i ctrl+F
			*ctrl_H i wpisujesz tekst któy będzie podmieniony
			*ENTER dla pojedyńczego słowa, ctrl+alt+ENTER dla wszystkich 
		*SHIFT + ALT + (strzałka w dół lub w góre) - kopiowanie linii 
		*ALT + (strzałka w górę lub w dół) - przemieszczanie się linii w górę lub w dół
		*CTRL + ` - terminal 
		*CTRL + b - panel boczny
	* SKRÓTY NOTEPADD ++
		*CTRL + d - duplikacja linii
		*CTRL + SHIFT +strzałka w góre/w dół - przeniesienie linii w górę lub w dół
		*CTRL + u - w zaznaczonym tekscie zamiana liter na małe
		
0.1* KONSOLA DLA PYTHONA:
	*OTWIERASZ PLIK PYTHON.EXE i masz konsole z pythonem. 
	*lub POWERSHELL/CMD w Windowsie gdzie wpisujesz python /python3 i odpala ci się
	 interpreter pythona (żeby wyjsć wpisz exit())
	*Tam gdzie są takie znaki >>> wpisujesz komendy
	*żeby otworzyc plik pythona w konsoli w trybie interaktywnym (czyli takim że możesz 
	 korzystać z funkcji tam znajdujących się) to w PowerShellu najpierw przechodzisz do 
	 ścieżki gdzie znajduję się tenże plik, a potem wpisujesz:
				C:\Users\Your_Name>python -i nazwaPliku.py
	*możesz też wywoływać funkcje ze swojego modułu/pliku_.py automatycznie przy otwarciu
	 tego modułu/pliku_py poprzez:	
				if __name__=='__main__':
					func1()
	 i w konsoli wpisując: 		
				C:\Users\Your_Name>python -i mojPlik_.py
	*możesz też w konsoli wpisywać argumenty bezpośrednio po nazwie pliku:
				C:\Users\Your_Name>python -i mojPlik_.py arg1 arg2 arg3
		*wykorzystując komende python -m możesz wpisać moduł bez końcówki .py - tylko w ten
		  sposób (dzięki '-m') możesz otwerać skrypty moduły któe nie znajdują się w twojej ścieżce
				C:\Users\Your_Name>python -m mojPlik arg1 arg2 arg3
	
0.0* INSTALACJA I KONFIGURACJA:
	*najlepiej wytłumaczona instalacja pythona3 na Maca i Windowsa:
	 https://www.youtube.com/watch?v=YYXdXT2l-Gg
			(plik IDLE który jest wewnątrz folderu z zainstalowanym Pythonem jest konsolą i 
			jednocześnie takim edytorem/notatnikiem)
	*jeżeli zainstalowałeś którąś z wersji pythona a ona się nie odpala po wpisaniu w terminalu 
	 python plik.py to znak że w zmiennych środowiskowych w USERS VARIABLES po przejściu każdej
	 ścieżki tam zawartej windows nie odnazł pliku python.exe i:
		*albo trzeba dodać ścieżkę w której jest zainstalowany plik python.exe (bez nazwy tego pliku)
		*albo w tychże zmiennych trzeba przenieść tę ściężkę wyżej w hierarchi (windows patrzy 
		 w pierwszej kolejnośći na tę najwyższą).
	*INSTRUKCJE DZIAŁANIA:
	  *Najpierw sprawdź z jakiej wersji Pythona używasz poprzez sprawdzenie ścieżki z której
	   windows korzysta by uruchomić plik python.exe :
				import sys
				print(sys.executable)
		*Instrukcje jak zmieniać zmienne środowiskowe w Windowsie:
					https://www.youtube.com/watch?v=OdIHeg4jj2c
			*by sprawdzić zmienne środowiskowe:
					echo %path%
		*instrukcje jak zmieniać zmienne środowiskowe na Macu oraz Linuxie:
					https://www.youtube.com/watch?v=PUIE7CPANfo3
			*by sprawdzić zmienne środowisowe:
					echo $PATH			#w linuxie nie ma dodawania danej ścieżki do zmiennej
										#jako nowej zmiennej śodowiskowej tylko jest tutaj
										#konkatenacje istniejącyh zmiennych środowiskowych 
										#z nowopowstałą (robisz to w nano: nano bash_profile) 
			*w linuksie ponadto musisz przypisać alias do pythona:
					alias python=python3
	*To samo dotyczy Django(który znajduję sie w folderze libs/site-packages oraz z pipem 
	 który znajduję się w folderze Scripts (te dwie ścieżki albo trzeba podać w zmiennych 
	 środowiskowych (users variables) albo podbić je wyżej w tychże zmiennych środowiskowych).	