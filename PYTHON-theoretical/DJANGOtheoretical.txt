============================================================================================================
=======II.PRZYKŁADY RÓŻNYCH APLIKACJI WYTWORZONYCH WE VIEWS.PY W KONKRETNYCH APP/FUNKCJONALNOŚCIACH=========
============================================================================================================
	1)FORMULARZ DO REJESTRACJI:
	---------------------------
		A) OPCJA PODSTAWOWA:
			1*W URLS.PY:
				*Tworzysz nową aplikację users
					python manage.py startapp users
				*dla głównej app/funkcjonalności w settings.py w INSTALLED_APPS dodajesz:
						'users.apps.UsersConfig',
				*w głównej app/funkcjonalności w pliku urls.py w urlpatterns dodajesz ścieżkę ('register') 
				 która będzie wskazywać na moduł vievs w app/funkcjonalności users. (ze względu na to że 
				 ścieżka register nie będzie miała żadnych innych podstron (a w pliku views.py będzie 
				 istnieć tylko jedna funkcja (w postaci register()) to nie musisz tworzyć dodatkowego
				 modułu urls.py w app/funkcjonalności users. Wystarczy zawrzeć przekierowanie w urls.py 
				 w głównej app/funkcjonalności)
						#plik urls.py w app/funkcjonalności django-project
						from users import views
						urlpatterns = [							#poniżej odwołanie do metody register w 
							...									#module views w app/funkcjonalności users
							path('register/', views.register, name = 'register'),
						]
				*ponieważ z innych app/funkcjonalnośći też możesz importować moduł views.py dlatego 
				 przypisz alias wg schematu: nazwaAppFunkcjonalności_views:
						#plik urls.py w app/funkcjonalności django-project
						from users import views as users_views
						urlpatterns = [							#poniżej odwołanie do metody register w 
							...									#module views w app/funkcjonalności users
							path('register/', users_views.register, name = 'register'),
						]
						
			2*WE VIEWS.PY (logika działania): 
				*korzystasz z gotowego modułu UserCreationForm, do tworzenia schematycznych formularzy 
				 składających się z: 'username', 'password1', 'password2' (do zatwierdzenia password1).
				 moduł ten musisz zaimportować:
							from django.contrib.auth.forms import UserCreationForm
				*tworzysz funkcję odpowiedzialną przy rejestracji:
					*za utworzenie użytkownika z danych przesłanych przez formulasz, walidację i zapis
					*za przekierowanie na inną stronę po udanej operacji lub w przypadku niuedanej operacji
					 za ponowne otworzenie strony register wraz z danymi przekazanymi w poprzednim 
					 formularzu:
							def register(request):
								if request.method == 'POST':			##gdy na dole w else'ie formularz 
																		##zostanie uzupełniony danymi to w 
																		##w pliku html poprzez przycisk 
																		##submit oraz metodę 'POST' z tagu 
																		##form te dane są przesłane i można
																		##je przekazać requestem
									formWithData=UserCreationForm(request.POST)	
																	##utworzenie formularza z danymi 
																	##przekazanymi przez metodę 'POST'
																	##z tagu form w pliku html
									if formWithData.is_valid():			##walidacja danych w formularzu
										formWithData.save()			##utworzenie użytkownika z danych z 
																	##formularza
										return redirect('blog-home')	##przekierowanie na stronę podaną
																		##w zmiennej name w urls.py 
																		##app/funkcjonalności blog
									else:									
										return render(request,'users/register.html', {'form':formWithData})
																	##wysłane powtórnie formularz z 
																	##uzupełnionymi danymi gdy dane z 
																	##formularza mają jakiś błąd
								else:
									formWithoutData = UserCreationForm()
									return render(request, 'users/register.html', {'form':formWithoutData})
																		##na początku odpala się formularz
																		##bez danych ponieważ nie została
																		##w pliku html nie została jeszcze
																		##odpalona metoda POST z tagu form
				*możesz rozszerzyć tę funkcję o wiadomość o udanej operacji zapisania i przesłania danych 
				 z formularza:
					*W PLIKU VIEWS.PY musisz zaimportować moduł messages z pakietu django.contrib oraz 
					 utworzyć wiadomość która zostanie automatycznie przesłana na podaną stronę przy
					 metodzie redirect()(przekierowaniu na inną stronę) lub metodzie render()(przezaniu 
					 obiektu typu Response):
							from django.contrib import messages
									...
									if formWithData.is_valid():
										formWithData.save()
										username = formWithData.cleaned_data.get('username')
														#tworzy zmienną pobierającą 'username' z formularza
										messages.success(request, f'Account created for {username}!')
														#tworzysz wiadomość która będzie automatycznie
														#przesłana wraz z metodą redirect() lub render()
										return redirect('blog-home')
					*W PLIKU SZABLONU (base.html w app/funkcjonalności blog) umieszczasz zmienną messages
					 w warunku że musi istnieć by ją pokazać:
							{% if messages %}
								{% for message in messages %}
									<div class="alert alert-{{ message.tags }}">
																		#wystylizowanie poprzez bootstrapa 
																		#wg pola tags ze zmiennej messages
										{{ message }}					#wiadomość przekazana w formularzu
									</div>
								{% endfor %}
							{% endif %}
							
			3*W TEMPLATES'ACH UTWORZENIE PLIKU HTML (register.html):
				*Tworzysz katalog templates i podkatalog o nazwie app/funkcjonalności users i 
				 wewnątrz tworzysz plik html: register.html:
				*odwołujesz się do szablonu umieszczonego w templates'ach innej app/funkcjonalności 
				 (w tym przypadku aplikacji/funkcjonalnośći blog)(nie musisz wpisywać specjalnej ścieżki 
				 żaby iśc w górę by przejśc do katalogu innej app/funkcjonalności. Ze względu na to
				 że strukture plików tworzysz tak że oprócz katalogu templates zawsze tworzysz katalog o 
				 nazwie app/funkcjonalności to wystarczy że odwołasz się do nazwy tej aplikacji i 
				 nazwy szablonu w niej zawartego):
						{% extends "blog/base.html" %}				#odwołujesz się do szablonu base.html 
																	#w app/funkcjonalności blog
				*tworysz strukturę formularza html która będzie podmieniana w szablonie html'a (base.html).
				 Ponieważ to formularz to dodajesz atrybut method ='POST' do tagu <form> żeby móc wysyłać
				 treści znajdujące się w polach formularza:
						{% block content %}	
							<div class="content-section">
								<form method='POST'>
								...
								</form>
							</div>
						{% endblock %}
				*wewnąrz formularza by działał właściwie musisz dodać w pojedyńczych nawiasach wąsowych 
				 (ukryty_tag/token) csrf_token oraz w podwójnych nawiasach wąsowych zmienną form która
				 bedzie wyrenderowana poprzez pole as_p (nazwa_pola i pole_formularza będą zaczynać się
				 od nowej linii)). W ten sposób powstanie nam domyślny formularz, który trzeba jeszcze 
				 uzupełnić o button typu submit żeby móc wysyłać dany formularz (jest to możliwe dzięki 
				 przypisaniu 'POST' do atrybutu method w tagu form):
						{% block content %}	
							<div class="content-section">
								<form method='POST'>
									{% csrf_token %}
									{{ form.as_p }}
								</form>
							</div>
							<div class="form-group">
								<button type="submit">Sign Up</button>
							</div>
						{% endblock %}		
			
		B)OPCJA ROZSZERZONA (rozszerzająca opcję podstawową):
			1*W URLS.PY tak samo jak w OPCJI PODSTAWOWEJ.
			2*WE VIEWS.PY
			 *Tworzysz swój własny typ formularza który nie będzie oparty o zaimportowany UserCreationForm
			  tylko o własną klasę która będzie dziedziczyć po UserCreationForm i która będzie rozszerzona 
			  o dodatkowe pola w formularzu:
			   2.0*WE FORMS.PY (class UserRegisterForm(UserCreationForm)):
					*wewnątrz swojej app/funkcjonalności users tworzysz moduł forms.py w którym tworzysz 
					 klasę UserRegisterForm dziedziaczącą po UserCreationForm. 
					*W tej klasie importujesz odpowiednie moduły, tworzysz dodatkowe pola w formularzu, 
					 wskazujesz bazę danych z modeli ze swojej app/funkcjonalności oraz wypisujesz kolejność 
					 swoich pól w liście fields:
							from django import forms		
										#do pobierania róznych typów pól dla formularzy, tutaj EmailField()
							from django.contrib.auth.forms import UserCreationForm
															#do możliwości dziedziczenia w swojej klasie
							from django.contrib.auth.models import User
															#do wskazania modelu Bazy danych w zmiennej model
							class UserRegisterForm(UserCreationForm):
								#email=forms.EmailField()	#nie musisz tego wpisywać gdyż pola formularz 
															#weżmie sobie z listy fields ale tutaj możesz
															#w parametrze wpisać ograniczenia (max_width=100)
															#lub format daty w przypadku pola Daty
								class Meta:
									model=User				#określasz bazę danych gdzie mają być zapisane 
															#dane z formualrza
									fields = [ 'username', 'email','password1','password2']
															#lista fields gdzie określasz wszystkie pola
															
			   2.1*WE VIEWS.PY:
					*ponieważ klasa UserRegisterForm dziedziczy po UserCreactionFrom to tylko je podmieniasz,
					 wcześniej importując UserRegisterForm z modułu forms znajdującego się w tym samym 
					 katalogu
					*dodatkowo dodajesz messages (opisane w PODSTAWACH w dziale MODUŁY I FOLDERY W 
					 APLIKACJACH w pkt module views.py)
							from django.shortcuts import render, redirect
							from django.contrib import messages	
							from . forms import UserRegisterForm
							def register(request):
								if request.method == 'POST':
									formWithData = UserRegisterForm(request.POST)
									if formWithData.is_valid():
										formWithData.save()
										username = formWithData.cleaned_data.get('username')
										messages.success(request, f'Account created for {username}!')
										return redirect('blog-home')
									else:
										return render(request,'users/register.html', {'form':formWithData})
								else:
									formWithoutData = UserRegisterForm()
									return render(request, 'users/register.html', {'form':formWithoutData})
									
			3*W TEPLATESACH W PLIKU REGISTER.HTML 
			 *Zmieniasz formę renderowania i przedstawienia błędów przy walidacji danych w formularzu z 
			  form.as_p na form|crispy:
				*instalujesz django-crispy-forms w konsoli poprzez:
							pipenv install django-crispy-forms	  LUB    pip install django-crispy-forms
				*dodajesz w głównej app/funkcjonalności w sekcji INSTALLED_APPS informacje o nowej 
				 crispy_forms (nie wiem czy to jest nowa app/funkcjonalność ale trzeba to tam umieścić)
							INSTALLED_APPS = [
								...
								'crispy_forms',
							]
			     oraz dodajesz w tym samym pliku zmienną CRISPY_TEMPLATE_PACK = 'bootstrap4'
							CRISPY_TEMPLATE_PACK = 'bootstrap4'
				*w pliku html (register.html) odwołujesz się do szablonu html, ładujesz tagi związane z 
				 cripsy_forms. Umieszczasz w sekcji block kod który będzie podmieniony w szablonie w danym
				 blocku. W zmiennej form dodajesz renderowanie (czyli modyfikacje przy wyświetleniu) na 
				 form|crispy zamiast form.as_p:
							{% extends "blog/base.html" %}
							{% load crispy_forms_tags %}
							{% block content %}
								<div class="content-section">
									<form method ='POST'>
										{% csrf_token %}
											{{ form|crispy }}
										<div class="form-group">
											<button type="submit">Sign Up</button>
										</div>
									</form
								</div>
							{% endblock content %}									
				*możesz rozszerzyć plik register.html o wystylizowanie stylów poprzez bootstrapa
					**w pliku register.html:
							{% extends "blog/base.html" %}
							{% load crispy_forms_tags %}
							{% block content %}
								<div class="content-section">
									<form method ='POST'>
										{% csrf_token %}
										<fieldset class="form-group">
											<legend class ="border-bottom mb-4">Join Today</legend>
												{{ form|crispy }}
										</fieldset>
										<div class="form-group">
											<button class="btn btn-outline-info" type="submit">Sign Up</button>
										</div>
									</form>
									<div class="border-top pt-3">
										<small class="text-muted">
											Already Have An Account? <a class="ml-2" href=#>Sign In</a>
										</small>
									</div>
								</div>
							{% endblock content %}
					**w szablonie base.html w app/funkcjonalności blog, w sekcji head ładujesz Bootstrapa:
							<head>
								<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
								<link rel="stylesheet" type="text/css" href="{% static 'blog/main.css' %}">
								
								
	2)STRONY DO LOGOWANIA, DO LOGOUTu i DO PROFILU:
	-----------------------------------------------
	  A)LOGIN oraz LOGOUT:
		1.MODULE URL.PY (w app/funckjonalności users - wykorzystujesz wcześniej utworzoną app/funkcjonalność)
			*pobierasz module views z django.contrib.auth by móc wywołac z niego 'class-based views'
			 (LoginView dla login oraz LogoutView dla logout).
			*LoginView dodajesz do ścieżki 'login/' oraz LogoutView dodajesz do ścieżki 'logout/' i ponieważ
			 ścieżki te nie będą miały podścieżek to na tych 'class-based views' wywołujesz metodę as_view()
			 i podajesz w niej parametetr template_name do którego przypisujesz ścieżki do plików html w
			 templates'ach w naszej app/funckjonalności users:
				#plik urls.py w app/funkcjonalności users
				from django.contrib.auth import views as auth_views
				urlpatterns = [							
					...									
					path( 'login/', auth_views.LoginView.as_view(template_name='users/login.html', 
																 name='login'),
					path('logout/',auth_views.LogoutView.as_view(template_name='users/logout.html',
																 name='logout'),
				]
				
		2*W SETTINGS.PY W GŁÓWNEJ APP/FUNCKJONALNOŚCI (zamiast views.py):
			*ponieważ cała logika działania aplikacji jest zawarta w 'class-based views' w pliku URLS.PY w 
			 głównej app/funkcjonalności to jedyne co zostaje to przekierowanie na inną stronę po poprawnym 
			 zalogowaniu. (standardowo DJANGO będzie przekierowac na http://127.0.0.1:8000/accounts/profile/)
			 By to zmienić musisz w pliku settings.py w głównej app/funckjonalności wpisać zmienną 
			 LOGIN_REDIRECT_URL i przypisując do niej interesującą cię stronę:
						#w settings.py w głównej app/funckjonalności
						LOGIN_REDIRECT_URL = 'blog-home' 	
						
		3*W TEMPLATES'ACH 
			a)W APP/FUNCKJONALNOŚCI USERS - login.html oraz logout.html :
			 **login.html:
				*tak samo jak register.html opierasz się na szablonie z app/funckjonalności blog,i zmieniasz
 				 tylko block content w którym musisz zawrzeć: tag form (z parametrem method='POST'),
				 koniecznie konstrukcje {% csrf_token %}, zmienną {{form}} oraz button submit:
						#minimalna wersja:
						{% extends "blog/base.html" %}
						{% block content %}
							<form method='POST'>
								{% csrf_token %}
								{{ form }}
								<button type="submit">Login</button> 
							</form>
						{% endblock content %}		
				*możesz dołożyć do tego renderowanie css'owe przez bootstrapa oraz renderowanie formularza 
				 przez crispy_forms (co omówiłeś w FORMULARZU REJESTRACYJNYM w pkt2 w OPCJI ROZSZERZONEJ):
						{% extends "blog/base.html" %}
						{% load crispy_forms_tags %}
						{% block content %}
							<div class="content-section">
								<form method ='POST'>
									{% csrf_token %}
									<fieldset class="form-group">
										<legend class ="border-bottom mb-4">Log In</legend>
											{{ form|crispy }}
									</fieldset>
									<div class="form-group">
										<button class="btn btn-outline-info" type="submit">Login</button>
									</div>
								</form>
							</div>            
						{% endblock content %}
			 **logout.html:
				*strona do logowania służy tylko temu żeby poinformować użytkownika że został wylogowany
				 (cała logika i tak dzieje się w module urls.py poprzez 'class-based views' LogoutView:
						{% extends "blog/base.html" %}
						{% block content %}
							<h2>You have been logged out</h2>
						{% endblock content %}
			b)W BASE.HTML (czyli szablonie) W GŁÓWNEJ APP/FUNKCJONALNOŚCI zmieniasz linki w zależności od
			  tego czy użytkownik jest zalogowany czy nie - używasz do tego pola is_authenticated na 
			  obiekcie user który jest wbudowany w django w paczce django.contrib:
						#jeżeli zalogowany -> nazwa profilu z linkiem do 'profile/' oraz link do 'logout/'
						#jeżeli niezalogowany -> link do podstrony 'register/' oraz 'logout/'
						{% if user.is_authenticated %}
							<a class="nav-item nav-link" href="{% url 'profile' %}">{{ user.username}}</a>
							<a class="nav-item nav-link" href="{% url 'logout' %}">Logout</a>
						{% else %}
							<a class="nav-item nav-link" href="{% url 'login' %}">Login</a>
							<a class="nav-item nav-link" href="{% url 'register' %}">Register</a>
						{% endif %}	
						
	  B)PROFILE:
		0.0* W MODELS.PY 
		   A* KLASA PROFILE:
			*Tworzysz model/klasę Profile dziedziczącą z models.Model, zaimportowanej z django.db.models:
								from django.db import models
								class Profile(models.Model):
			*W tej klasie będziesz musiał zdefiniować pola:
				**pole user typu OneToOneField:
					*models.OneToOneField(User) -importując wczensiej Usera: from django.contrib.auth.models 
					 import User odwołasz się do modelu użytkownika w relacji 1:1 - czyli 1 User może być 
					 związany z 1 profilem oraz 1 profil może być związany z 1 Userem. W ten sposób profil 
					 jest rozszerzeniem klasy użytkownika (User) bez użycia dziedziczenia. 
					*on_delete=models.CASCADE - podasz to jako parametr - gdy użytkownik zostanie usunięty 
					 to profil także:
								from dajngo.db import models
								from django.contrib.auth.models import User
								class Profile(models.Model):
									user=models.OneToOneField(User, on_delete=models.CASCADE)
									...
				**pole img typu ImageField:
					*default - czyli zdjęcie domyślne (gdy nie zostanie podane inne): default= 'default.png'
					*upload_to - jako drugi parametr wskażesz nazwę folderu gdzie mają być przechowywane 
					 uploadowane zdjęcia: upload_to='profile_pics' Django automatycznie w głównym katalogu 
					 (czyli tam gdzie są wszystkie foldery app/funkcjonalności stworzy folder o podanej 
					 nazwie, czyli: 'profile_pics'):
								class Profile(models.Model):
									img=models.ImageField(default= 'default.png', upload_to='profile_pics')
									...
					   ***Jednakże gdybyś stworzył wiele pól typu ImageField to w głównym katalogu (czyli 
						  tam gdzie znajdują się wszystkie app/funckjonalności) Django stworzy ci tak dużo
						  folderów na uploadowane pliki że będziesz mieć w głównym katalogu bałagan. Dlatego 
						  rozwiązaniem jest utworzenie jednego wspólnego katalogu plików zwanego media:
								||	
								\/
					      Żeby to zrobić (wersja dla developmentu nie dla deploymentu) musisz stworzyć:
						   **MEDIA_ROOT - zmienna ta ma utworzyć i wskazywać folder gdzie będą przechowywane
						     zuploadowane pliki. Pliki te będą przechowywane w zwykłym katalogu zamiast w
							 bazie danych. MEDIA_ROOT tworzysz w głównej app/funckjonalności w pliku 
							 settings.py i przypisujesz jej utworzoną ścieżkę na podstawie zmiennej BASE_DIR
							 (BASE_DIR jest już domyślnie utworzona w pliku settings.py, a ścieżkę tworzysz
							 poprzez metodę join() w module os):
								#w pliku settings.py w głównej app/funckjonalności:
								#BASE_DIR = Path(__file__).resolve().parent.parent - utworzone na starcie
								import os
								MEDIA_ROOT=os.path.join(BASE_DIR, 'media')
							 Bez przypisania ścieżki zmiennej MEDIA_ROOT będzie ona ustawiona na BASE_DIR							 
						   **w URLS.PY musisz dodać poniższe linie, żeby zdjecia/pliki mogły się wyświetlić 
						     (zarówno poprzez instrukcje konsolowe tj: user.profile.image.url jak i poprzez 
							 wpisanie w wyszukiwarke dokładnej lokalizacji zdjęcia):
								#w pliku urls.py w głównej app/funkcjonalności
								from django.conf import settings
								from django.conf.urls.static import static
								if settings.DEBUG:
									urlpatterns += static(settings.MEDIA_URL, 
														  document_root=settings.MEDIA_ROOT)
						   **MEDIA_URL - zmienna ta ma być publiczną reprezentacją adresu zmiennej MEDIA_ROOT.
						     Wpisujesz ją w głównej app/funckjonalności w pliku settings.py i ma to 
							 być nazwa folderu o tej samej nazwie co folder podany w ścieżce MEDIA_ROOT,
							 poprzedzona i zakończona slashami czyli:
								#pliku settings.py w głównej app/funckjonalności
								MEDIA_URL = '/media/'
							 To znaczy że jeżeli w wyszukiwarce wpiszesz jako folder pośredni '/media/' to 
							 będzie on reprezentował całą zmienną MEDIA_ROOT (czyli '127.0.0.1:8000/media/')
							 [Teoretycznie nie musiałbyś deklarować zmiennej MEDIA_URL ale jest to zbyt 
							 skomplikowane tłumaczyć dlaczego więc zawsze ją dodawaj podczas developmentu] 
							 # Teraz wszystkie zuploadowane zdjecia w profilu będą przechowywane w folderze
							 # media/profile_pics/ i będziesz mógł się do nich dostać w wyszukiwarce poprzez:
							 # '127.0.0.1:8000/media/profile_pics/nazwaZdjęcia.jpg' lub w pliku view.py 
							 # poprzez instrukcje konsolowe np: user.profile.image.url 
				**funkcja __str__() zwracjącą nazwę profilu/użytkownika zamiast adresu referencji:
								class Profile(models.Model):
									...
									def __str__(self):
										return f'{self.user.username} Profile'						  
		   B* MIGRACJA do DB oraz ZAREJESTROWANIE TABELI W ADMIN.PY:
				*Tworzysz migrację tak żeby w bazie danych powstała tabela Profile. Jednakże ponieważ w 
				 klasie Profile masz pole typu ImageField to by móc zrobic migrację i działac na zdjęciach 
				 musisz w konsoli zainstalować pakiet PILLOW (trzeba zainstalować ponieważ nie jest on w 
				 standardowych bibliotekach). W konsoli najpierw instalacja pillow:
								pipenv install pillow
				 A następnie zrobienie migracji:
								python manage.py makemigrations
								python manage.py migrate
				*W ADMIN.PY zarejestruj tabelę Profile żeby mieć do niej dostęp w panelu administracyjnym.
				 Żeby móc to zrobić musisz najpierw pobrać tabelę Profile z pliku models.py:
								from .models import Profile 		#'.' oznacza że z tego samego katalogu
								admin.site.register(Profile)
		   C* PRZESLONIĘCIE METODY SAVE:
				*Dodatkowo możesz przesłonić metodę save(self, *args, **kwargs) w celu AUTOMATYCZNEGO 
				 RESIZINGU ZDJĘCIA PRZY UPLOAOWANIU. W poniższym przypadku jest to automatyczna ZMIANA 
				 WIELKOŚCI ZDJĘCIA na wymiar 300 na 300. Żeby móc to wykonać musisz zaimportować klase Image 
				 z biblioteki PILLOW (którą wczesniej zainstalowałeś):
								from PIL import Image							#PILLOW ma skrót PIL
								class Profile(models.Model):
									...
									def save(self, *args, **kwargs):
										super().save( *args, **kwargs)			#przesłonięcie 
										img = Image.open(self.image.path)		#img jako zmienna do której
																				#przypisano obiekt Image (z 
																				#argumentem w postaci ścieżki:
																				#profile.image.path
										if img.height > 300 or img.width >300:	
											output_size= (300,300)
											img.thumbnail(output_size) 			#zmiana wielkości zdjęcia
											img.save(self.image.path)			#zapis nowego zdjęcia
											
		0.1* W SIGNALS.PY oraz APS.PY w danej app/funckjonalności:
		 *W APPS.PY:
			*po stworzeniu pliku signals.py żeby sygnały mogły działać to w apps.py wewnątrz klasy o nazwie
			 nazwa_app/funkcjonalnosci dziedziczącej po AppConfig trzeba stworzyć funkcję ready() i wewnątrz
			 jej zaimportować plik signals pochodzący z danej app/funkcjonalności poniżej dla users:
								class UsersConfig(AppConfig): 
									name = 'users'
									def ready(self):
										import users.signals
		 *W SIGNALS.PY:
			*Podstawy:
				*signals.py jest niczym innym jak kontynuacją pliku models.py (niektórzy wręcz to co jest w 
				 w signals.py robią w models.py)
				*w tymże sygnale chodzi o to żeby w momencie utworzenia obiektu User zostal automatycznie 
				 utworzony obiekt Profile (stworzony a następnie zapisany):
				*by móc utworzyć sygnał potrzebujesz:
					*zaimportować modele/klasy które będą użyte w sygnale (z pliku models.py) 
								from .models import Profile
								from django.contrib.auth.models import User
					*zaimportować dekorator receiver który jest odpowiedzialna za otrzymanie sygnału i 
					 uruchomienie funkcji wewnątrz dekoratora:
								from django.dispatch import receiver
					*zaimportować typ sygnału - post_save, który uruchomi daną funkcję po utworzeniu i 
					 zapisaniu wskazanego obiektu - w tym przypadku po utworzeniu i zapisaniu Usera.
								from django.db.models.signals import post_save 
			*tworzysz funkcje udekorowane dekoratorem @receiver przyjmującym w parametrach typ sygnału oraz
			 sender'a czyli nazwę klasę jaka musi zostać stworzona żeby uruchomiły się funkcje tworzące
			 inną klasę. 	
								@receiver(post_save, sender=User)
								def ...
			 Musisz stworzyć 2 funkcje wewnątrz receivera - do tworzenia i do zapisywania. Muszą one 
			 przyjmować odpowiednie argumenty,które dostarcza receiver tj: 
					-sender - jako klasę która wyśle sygnał gdy zostanie stworzona jej instancja
					-instance - jako instacja klasy która wysłała sygnał ze stworzyła instancje
					-created - (opcjonalnie) sprawdza czy obiekt zostal stworzony czy nie 
					-**kwargs - jako jakieś pozostałe elementy 
				*Funkcja create_profile dzięki funkcji create() użytej na wszystkich obiektach klasy Profile 
				 stworzy obiekt Profile gdzie w argumencie przyjmie pole user jako instance:
								@receiver(post_save, sender=User)
								def create_profile(sender, instance, created, **kwargs):
									if created:
										Profile.objects.create(user=instance)
				*Funkcja save_profile dzięki funkcji save() użytej na danym obiekcie Profile przypisanym do 
				 konkretnej instancji usera zapisze w modeluklasie/tabeli Profile nowo stworzoną instancje
				 profilu:
								@receiver(post_save, sender=User)
								def save_profile(sender, instance, **kwargs):
									instance.profile.save()
			*Logika działania takich sygnałów wygląda tak - po tym gdy User zostanie utworzony/zapisany 
			 (post_save) zostanie wysłany sygnał od Usera (sender=User) który zostanie otrzymany przez 
			 funkcje z dekoratorem @receiver. Pierwsza z nich stworzy obiekt Profile dzięki metodzie 
			 create() a druga zapisze go w tabeli dzięki metodzie save():
								from django.db.models.signals import post_save 
								from django.contrib.auth.models import User
								from django.dispatch import receiver
								from . models import Profile

								@receiver(post_save, sender=User)
								def create_profile(sender, instance, created, **kwargs):
									if created:
										Profile.objects.create(user=instance)

								@receiver(post_save, sender=User)
								def save_profile(sender, instance, **kwargs):
									instance.profile.save()
									
		1* W URLS.PY:
			A) ze względu na to że strona profile nie będzie miała żadnych podstron to importujesz moduł 
			   views.py z app/funkcjonalności users gdzie znajduję się logika działania funkcji profile oraz 
			   umieszczasz w liście urlpatterns przekierowanie na stronę profile:
						#w pliku urls.py w głównej app/funkcjonalności
						from users import views as user_views
						urlpatterns = [
							...
							path('profile/', user_views.profile, name = 'profile'),
						]
			B) ze względu na to że stworzyłeś zmienne MEDIA_ROOT oraz MEDIA_URL w celu stworzenia folderu 
			   pośredniego dla folderów przechowujących zuploadowane pliki musisz jeszcze dołożyć w pliku 
			   urls.py w głównej app/funkcjonalnośći linie kodu odpowiadające za wyświetlenie tychże
			   plików/zdjęć poprzez instrukcje konsolowe w pliku views.py np: user.profile.image.url, lub 
			   bezpośrednie wpisanie ścieżki w wyszukiwarkę: 127.0.0.1:8000/media/profile_pics/nazwa.jpg 			   
						#w wersji dla developmentu a nie dla deploymentu
						#w pliku urls.py w głównej app/funkcjonalności
						...
						from django.conf import settings
						from django.conf.urls.static import static
						if settings.DEBUG:
							urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
							
		2.0* WE FORMS.PY APP/FUNCKJONALNOŚCI USERS (forms.py który jest przedłużeniem pliku VIEWS.PY):
		   *Na początku musisz zaimportować modele User i Profile by móc dodawac formularze na ich bazie
		   *Tworzysz formularze UserUpdateForm oraz ProfileUpdateForm które dziedziczą po klasie ModelForm
		    z pakietu models (from django import forms). 
		   *Specjalnie tworzysz UserUpdateForm zamiast tylko ProfileUpdateForm gdzyż interesujące cię dane 
		    (czyli: username, email) znajdujące się w modelu User i chociaż model Profile poprzez pole typu
			OneToOneField(User) jest ścieśle z Userem połączony relacją 1:1 to nie dziedziczy po nim więc
			nie można się dostać z obiektu profilu do pól Usera
		   *wewnątrz formularzy najważniejsze jest zdeifiniowanie klasy wewnętrznej 'Meta' gdzie deklarujesz 
		    nazwę modelu na bazie której będzie formularz np: model=User oraz deklarujesz pola w liście 
			fields które interesują cię w formularzu
		   *ponadto mógłbyś stworzyć pola o tej samej nazwie co w liście fields w klasie Meta. Pola te mając
		    tę samą nazwę co w liście fields w klasie Meta zostałyby przedstawione w formularzu w jednym 
			miejscu. W polu utworzonym poza klasą Meta mógłbyś dać parametr ograniczający jakoś to pole np:
			#username = forms.CharField(max_length=10) albo #email=forms.EmailField(). Bez ograniczających 
			parametrów nie ma sensu tworzenie takich pól:
						from django.contrib.auth.models import User
						from .models import Profile
						from django import forms
						class UserUpdateForm(forms.ModelForm):
							#username = forms.CharField(max_length=1)	#nie musisz tego podawać ani email
							#email=forms.EmailField()					#chyba że chcesz jakoś ograniczyć 
																		#np pole email poprzez: max_width=10 
							class Meta:
								model=User
								fields = ['username', 'email']
						class ProfileUpdateForm(forms.ModelForm):
							class Meta:
								model = Profile
								fields=['image']
								
		2.1* WE VIEWS.PY APP/FUNCKJONALNOŚCI USERS ORAZ W SETTINGS.PY W GŁÓWNEJ APP/FUNCKJONALNOŚCI:
		   a)'RESTRICTED ROUTE' - Podstrona profile powinna być tylko dla zalogowanego użytkownika:
			    *WE VIEWS.PY tworzysz funkcje profile() przekierowującą do strony 'users/profile.html'i do 
			     której dostęp powinien być ograniczony tylko dla zalogowanego użytkownika. By móc takie
			     coś osiągnąć musisz skorzystać z wbudowanego w django dekoratora o nazwie login_required 
			     (z paczki django.contrib.auth.decorators):
						from django.contrib.auth.decorators import login_required
						@login_required
						def profile(request):
							return render(request, 'users/profile.html')
			    *W SETTINGS.PY W GŁÓNEJ APP/FUNKCJONALNOŚCI - ze wzgłędu na to że gdybyś nie był zalogowanym
			     a chciał wejść na stronę 'profile/' (która jest 'RESTRICTED ROUTE' (czyli tylko dla 
			     zalogowanych użytkowników)) NIE Z LINKU tylko wpisując w pasek adres (127.0.0.1/profile)
			     to django automatycznie przekieruję cię na domyślną stronę logowania (/acounts/login/). 
			     Ponieważ twoja strona logowania to adres '/login/' to musisz zrobić odpowiednie przypisanie
			     poprzez zmienną LOGIN_URL i przypisanie do niej 3 zmienną z funkcji path dla login w liscie
			     urlpatterns w pliku urls.py tj 'login':
						#w pliku settings.py w głównej app/funckjonalności
						LOGIN_URL ='login'
			     Dzięki temu nawet jak będziesz niezalogowany a będziesz chciał wejść na stronę 'profile/' 
			     która jest 'RESTRICTED ROUTE' to django automatycznie przeniesie cię do strony logowania
			     z dopiskiem w adresie strony '?next=/profile/' czyli kolejnej strony która zostanie 
			     automatycznie wybrana gdy już się zalogujesz. 
		   b)FORMULARZE z FORM.PY użyte WE VIEWS.PY:
				*formularze dziedzczące po forms.ModelForm 
				*w formularzu dziedziczącym po forms.ModelForm by móc zapisać dane w konkretnej 
				 tabeli/modelu/klasie oraz by mogły zostać wyświetlone dane z pól tegóż modelu/klasy w 
				 polach formularza trzeba podać jako parametr instancje obiektu: 'instance=request.instancja'
						u_form=UserUpdateForm(instance=request.user)
						p_form=ProfileUpdateForm(instance=request.user.profile)
				*w formularzach podczas submitowania formularza dochodzi do post requesta z powrotem do tej
 				 samej ścieżki wraz z danymi wprowadzonymi w formularz. By móc przekazać te dane wprowadzone
				 w formularz (niezależnie od tego czy dane te będą poprawnie wprowadzone czy niepoprawnie)
				 trzeba dla treści podać parametr 'request.POST' a dla plików/zdjęć 'request.FILES'
						u_form=UserUpdateForm(request.POST, instance=request.user)
						p_form=ProfileUpdateForm(request.POST, request.FILES ,instance=request.user.profile)
				*Po przekazaniu danych wprowadzonych do formularza trzeba:
				  *móc określić czy dane te są poprawnie wprowadzone czy nie, walidacja poprzez is_valid(). 
				  *jeżeli są poprawnie zapisane to trzeba te dane zapisać w tabeli poprzez metode save(). 
				  *na koniec możesz przekierować na inną strone (redirect()) oraz na przekierowanej stronie
				   pokazać wiadomość (messages.succes9request, 'text').
						login_required
						def profile(request):
							if request.method == 'POST':
								u_form=UserUpdateForm(request.POST, instance=request.user)
								p_form=ProfileUpdateForm(request.POST, request.FILES,
														 instance=request.user.profile)
								if u_form.is_valid() and p_form.is_valid():
									u_form.save()
									p_form.save()
									messages.success(request, f'Your account has been updated')
									return redirect('profile')

							else:
								u_form=UserUpdateForm(instance=request.user)
								p_form=ProfileUpdateForm(instance=request.user.profile)
							context={
								'u_form': u_form,
								'p_form': p_form 
							}
							return render(request, 'users/profile.html', context)
							
		3* W TEMPLATES'ACH W APP/FUNKCJONALNOŚCI USERS:
		   a) Tworzysz stronę profile.html gdzie zawierasz:
				  *nazwę użytkownika: 'user.username' 
				  *zdjęcie o ścieżce odwołującej się (dzięki polu OnoToOneField w klasie Profile w pliku 
				   models.py) do usera z wbudowanej w django bazy danych User: 'user.profile.image.url'
				  *formularz odpowiadający za edycję danych użytkownika (pola z modelu User)
				  *formularz odpowiadający za możliwość edycji zdjęcia profilowego (pola z modelu Profile)
			  KONIECZNIE PAMIĘTAJ O TYM BY dodać konstrukcje {% csrf_token %} do poprawnego działania
			  formularzy oraz 'enctype' w <form method ="POST" enctype="multipart/form-data"> by móc wysyłać 
			  zdjęcia (+ gdybyś nie miał zainstalowanego modułu PILLOW to: pipenv install pillow):
						{% extends "blog/base.html" %}
						{% block content %}
							<h1>{{ user.username }}</h1>
							<image src="{{ user.profile.image.url }}"></image>
										<!--FORM-->
							<form method ="POST" enctype="multipart/form-data">
								{% csrf_token %}
								{{ u_form }}
								{{ p_form }}
								<button class="btn btn-outline-info" type="submit">Update</button>
							</form>
						{% endblock content %}
		   b) Możesz rozszerzyć to o renderowanie w CSSie przez bootstrap oraz renderowanie formularzy
			  poprzez cripsy_forms:
						{% extends "blog/base.html" %}
						{% load crispy_forms_tags %}
						{% block content %}
						<div class="content-section">
							<div class="media">
							    <img class="rounded-circle account-img" src="{{ user.profile.image.url }}">
							    <div class="media-body">
									<h2 class="account-heading">{{ user.username }}</h2>
									<p class="text-secondary">{{ user.email }}</p>
								</div>
							</div>
							<!--FORM-->
							<form method ="POST" enctype="multipart/form-data">
							    {% csrf_token %}
							    <fieldset class="form-group">
									<legend class ="border-bottom mb-4">Profile_Info</legend>
									{{ u_form|crispy }}
									{{ p_form|crispy }}
								</fieldset>   
								<div class="form-group">
								    <button class="btn btn-outline-info" type="submit">Update</button>
								</div>
						  </form>
						  </div>
						{% endblock content %}	
						
============================================================================================================
====================================================PODSTAWY================================================
============================================================================================================
5. DEBUGOWANIE CAŁEGO PROJEKTU:
  *UTWORZENIE PLIKU potrzebnego DO DEBUGOWANIA
	*znajdując się wewnątrz jakiegokolwiek pliku z rozszerzeniem .py przechodzisz w panelu bocznym na ikonę 
	 "play z żuczkiem" i klikasz na napis: "create a launch.json file" i z dostępnych opcji wybierasz opcje 
	 z DJANGO.
	*Tworzy ci się plik launch.json w folderze .vscode. Ten plik służy tylko do debugowania więc jeżeli np 
	 zmienisz port w "args" dodając do listy w cudzysłowiu nowy nr portu to podczas odpalania projektu 
	 poprzez wpisywanie ręcznie komend w terminalu, nie będzie to miało znaczenia tylko podczas jego 
	 debugowania (chyba że odpalisz projekt przez CTRL + F5 (czyli Run without debugging))
	*launch.json - składa się z par kluczy i wartości dających "launch profile"
  *DEBUGOWANIE:	
	*żeby rozpocząć debugowanie to (już po zaznaczeniu breakpoint'ów), przechodzisz na ikonę "play z 
	 żuczkiem" i u góry wciskasz play. Uruchomi się Tobie projekt w taki sam sosób jakbyś uruchamiał go w 
	 terminalu (pipenv shell ;; python manage.py runserver) tylko w miejscach breakpointów się zatrzyma 
	 (otworzy ci się nowy teminal) 
	*KOLEJNE FUNKCJE wyświetlone w panelu:
		*STEP OVER f10- przejdź przez kolejną linijkę
			*panel boczny - wraz z przechodzeniem przez kolejne linijki panel będzie (inspect) sprawdzał 
			 wartości w tych linijkach 
		*STEP INTO f11 - jeżeli natrafisz w linijce na funkcje to możesz wejśc wewnątrz jej ciała i zobaczyć
		 czy tam nie ma jakiegoś buga
		*STEP OUT SHIFT +f11 - następnie możesz wyjśc z takiej funkcji 
		*RESTART - załączasz debugowanie od nowa
		*STOP - kończysz debugowanie
	*żeby włączyć projekt bez debugowania to robisz:
			CTRL + f5 (RUN --> Run without debugging)
  *DEBUGOWANIE poprzez DJANGO-DEBUG-TOOLBAR:
   https://django-debug-toolbar.readthedocs.io/en/latest/installation.html
    *ZALETY: 
		*mając odpowiednio przygotowany plik html (czyli conajmniej zawierający tagi html 
		 oraz body) mozesz w przeglądarce po wcześniejszym odpaleniu pliku (CTRL + f5 / F5) korzystać z 
		 panelu do debugowaniu gdzie masz wszystkie potrzebne opcje i informacje.
	*INSTALACJA:	
		*instalacja w wirtualce:
				pipenv install django-debug-toolbar
		*dodanie do settings.py w głównej APP/FUNKCJONALNOŚCI do sekcji INSTALLED_APPS:
				... ,
				'debug_toolbar' 
		*dodanie do urls.py w głównej APP/FUNKCJONALNOŚCI do urlpatterns (+ dodanie biliotek):
				import debug_toolbar
				from django.conf import settings
				from django.urls import include, path
				urlpatterns = [
					...
					path('__debug__/', include(debug_toolbar.urls)),
				]
		*dodanie do settings.py w głównej APP/FUNKCJONALNOŚCI do sekcji MIDDLEWARE:
				... ,
				'debug_toolbar.middleware.DebugToolbarMiddleware',
		*dodanie do settings.py w głównej APP/FUNKCJONALNOŚCI całej sekcji INTERNAL_IPS wraz ze swoim ip:
				INTERNAL_IPS = [
					# ...
					'127.0.0.1',
					# ...
				]
				
4. STRONA ADMINISTRATORA: [<sciezka_do_nazwyStrony_z_serwerem>/admin np 127.0.0.1/8000/admin]
	*PODSTAWY:
		*admin site daje możliwość przeglądania wszystkich baz danych wraz z tworzeniem, updatowaniem i 
		 usuwaniem tychże danych. 
		*ponadto masz tam bazę użytkowników (na których również możesz dokonywać powyższych operacji) wraz 
		 z hasłami które są domyślnie zahashowane i posolone. Użytkownicy ci składają się na 3 grupy w 
		 zależności od statusu dostępu: administratorzy (superuser), ci co mogą się zalogować do admin-site 
		 ale nie mają praw administratora (staff user) oraz ci o najwęższych prawach (active). 
		*znajduję się tam też panel boczny gdzie masz wyswietlone wszystkie historie wszystkich dokonanych 
		 operacji.
	*STWORZENIE I PIERWSZE UŻYCIE - najpierw trzeba stworzyć domyślne bazy danych (komenda migrate 
	 pozwala na zatwierdzenie zmian w bazie danych, ale jeżeli te bazy jeszcze nie istnieją to są tworzone 
	 takie domyślne jak auth_user). Następnie możesz utworzy pierwszego superusera (administratora).
					python manage.py migrate					#utworzenie domyślnych baz danych
					python manage.py createsuperuser			#utworzenie 1wszego administratora
				#jeżeli nie działa to przed komedą wpisz winpty: winpty python manage.py createsuperuser
	*AUTOMATYCZNE WYGENEROWANIE TABELI z KLASY w pliku MODELS.PY - w pliku admin.py musisz pobrać daną 
	 klasę/tabelę z pliku models.py i następnie ja zarejestrować. Dzięki temu będziesz mógł  modyfikować 
	 fane z tabeli z pozycji administratora będąc zalogowanym na stronie administracyjnej:
					#w admin.py danej app/funkcjonalności (w ty, przypadku w app/funckjonalności klasaPost):
					from . models import klasaPost
					admin.site.register(klasaPost)
			
3. MODUŁY i FOLDERY w APLIKACJACH/pojedyńczych_funkcjonalnościach:
	*module MODELS.PY 
		*PODSTAWY:
			*Django ma własny wbudowany ORM (Object-Relational Mapping), który zamienia utworzone obiekty na
			 bazy danych (na konkretne encje/tabele) oraz pozwala na automatyczne generowanie instrukcji sql.
			 Dzięki temu możesz używać różnych baz danych (SQLite, POSTGREsql) bez konieczności zmiany kodu. 
			*Users (użytkownicy) mają osobną baze danych więc w models.py zamiast budowania jej możesz ją
			 tylko modyfikować. Gdybyś chciał użyć tej tabeli użytkowników jako klucz obcy w innej tabeli
			 to musisz ją zaimportować z django.contrib.auth.models:
							from django.contrib.auth.models import User
							from django.db import models
							class Post(models.Model):
								author = models.ForeignKey(User, on_delete = models.CASCADE)
			*póżniej taką klasę/tabelę możesz zarejestrować w pliku admin.py w danej app/funckjonalności i 
			 zarządzać tą tabelą ze strony administracyjnej --> WIĘCEJ patrz 4.STRONA ADMINISTRATORA 
		*BUDOWA:
			*nasze bazy danych/tabele (dzieki Django ORM) są reprezentowane poprzez klasy zwane 'models'
			 a każdy atrybut reprezentuję pole w tabeli.
			*nasze klasy/modele będą dziedziczyć klasę Model z modułu models (który jest importowany z 
			 pakietu django.db)
							from django.contrib.auth.models import User
							from django.db import models
							from django.utils import timezone
							class Post(models.Model):
								title=models.CharField(max_length=100)
								content = models.TextField() 
								date_posted = models.DateTimeField(default = timezone.now)
								author= models.ForeignKey(User, on_delete=models.CASCADE)
								def __str__(self):
									return self.title									
			*TYPY DANYCH konkretnych pól:
				*models.ForeignKey(nazwaTabeli) - pole o kluczu w innym tabeli (czyli ForeignKey). Trzeba 
				 zaimportować wpierw tę tabele a póżniej podać ją jako argument nazwaTabeli					
							from django.contrib.auth.models import User
								...
								author = models.ForeignKey(User)
					**on_delete=models.CASCADE - parametr który każe usunąć wszystkie obiekty powiązane z
					    tą tabelą z klucza obcego gdy obiekt ztymże kluczem obcym zostanie usunięty. 
							from django.contrib.auth.models import User
								...
								author = models.ForeignKey(User, on_delete =models.CASCADE)
				*models.Charfield() - pole typu CHAR 
					**max_length=100 - możesz dodać parametr ograniczający max długość
								title = models.CharField(max_length=100)
				*models.TextField() - pole typu text (bez ograniczenia w max długości)
								content = models.TextField()
				*models.DateTimeField() - pole typu data i czas
					**auto_now=True - możesz dodać parametr który będzie generował automatycznie czas zawsze
						podczas edycji obiektu.
								date-posted = models.DateTimeField(auto_now=True)
					**auto_now_add= True - możesz dodać parametr który będzie generował automatycznie czas
						zawsze przy pierwszym tworzeniu obiektu. Nie daję to możliwości modyfikacji
								date-posted = models.DateTimeField(auto_now_add=True)
					**default=timezone.now - automatycznie generuję czas przy tworzeniu obiektu ORAZ daję
						możliwośc modyfikacji czasu. 
							from django.utils import timezone
								...
								date-posted = models.DateTimeField(default=timezone.now)	 
															#nie dajesz nawiasów na końcu metody now, gdyż 
															#nie chcesz jej wywoływać tylko jej referencje
			*metoda __str__() - metoda magiczna która ma zwrócić tytuł posta w momencie gdy będzie 
			 wywoływany z bazy danych w shellu (python manage.py shell) poprzez:
							Post.objects.all()				#zwróci:  <QuerySet [<Post: Title1>]>
															#zamiast: <QuerySet [<Post: Post object (1)>]>
						#w models.py:
							def __str__(self):
								return self.title
															
	*katalog MIGRATIONS 
		*PODSTAWY:
			*w katalogu MIGRATIONS są przechowywane 'migracje' które są zrzutami historii wszystkich 
			 operacji tworzenia i modyfikacji klas reprezentujących tabele w bazie danych od ostatniego 
			 użycia komendy makemigrations. Klasy te znajdują się w pliku models.py.
			*Wewnątrz pliku migracji zobaczysz że dana migracja zależy od poprzedniej (zmienna dependencies)
			 dzięki czemu można zauważyć historyczne przejście do pierwszej migracji, widząc dokładnie co 
			 się działo po drodze.
		*KOMENDY związane z katalogiem MIGRATIONS:
			*Migracja (która będzie wszystkimi zmianami na klasach w pliku models.py) tworzysz poprzez:
							python manage.py makemigrations
			*By podejrzeć jaka instrukcja sql zostaną wytworzone podczas komendy migrate w danej migracji 
			 możesz podejrzeć poprzez komendę sqlmigrate podając za nią argumenty w postaci nazwy 
			 aplikacji/funkcjonalnosci oraz numeru który jest na początku pliku danej migracji.
							python manage.py sqlmigrate blog 0001
			*By dokonać MIGRACJI z plików migracji (wszystkich plików migracji) do pliku danej bazy danych 
			 (domyślnie dla sqlite db.sqlite3) użyj instrukcji:
							python manage.py migrate 
							
	*module URLS.PY
	  **OPCJA 1:
		*JEZELI WIESZ ŻE TWOJA STRONA BĘDZIE MIAŁA PODSTRONY DLA DANEJ APP/FUNKCJONALNOŚCI to tworzysz moduł
		 urls.py w swojej app/funkcjonalności (moduł urls.py nie powstaje automatycznie przy tworzeniu nowej
		 app/funkcjonalnośći - trzeba go stworzyć samemu)
		*musisz zaimportować module django.urls oraz module views(ten poniżej) 
		*musisz stworzyć URLconf tworząc listę 'urlpatterns' (koniecznie tak nazwaną bo django będzie tego
		 szukał) i wpisać w nią obiekty typu 'URLpattern' za pomocą funkcji path(), którą zaimportowałeś z 
		 django.urls:
					#aplikacja/funkcjonalonośc o nazwie playground
					from django.urls import path
					from . import views		#kropka oznacza: 'z folderu rodzica' 
											#(czyli tego samego w którym się znajduję) 
					#URLConf:				#każda aplikacja/pojedyńcza funkcjonalność 
					urlpatterns = [			#ma swoje URLConf (URL configuration)
						path('hello/', views.says_hello, name='playground-hello')
					]			#path() zwraca obiekt typu URLpattern. Przyjmuję w argumencie ścieżkę 
								#względną pod którą będzie wyświetlać się funkcja podana w 2gim argumencie
								#pochodząca z katalogu views. Ścieżka ta nie ma zawierać nazwy 
								#folderu/aplikacji gdyż ten podamy w urlpatterns w urls.py w głównym
								#katalogu projektu.
										#trzeci argument (w postaci name) jest dodatkowy ale specjalnie go 
										#podajesz gdyż w templates w plikach html w linkach (<a href="...">)
										#zamiast podawania konkretnego linka podasz wartość tego argumentu
										#dzieki czemu gdybyś chiał zmienić tenże link to robisz to w 
										#pierwszym argumencie metody path zamiast w dwóch miejscach na raz
										#czyli w metodzie path i w pliku HTML. (-->patrz linki w templates)
					  ##path('', views.says_hello)	#say_hello z modułu views mógłbyś też wywołać dla pustej
													#2giej cześci linka tj wyświetlałoby się dla linka z
													#nazwą app/funkcjonalności tj:
													#http://127.0.0.1:8000/playground zamiast powyższego 
													#http://127.0.0.1:8000/playground/hello
		*następnie musisz zaimportować cały ten moduł do głównego URLConf (URL configuration który znajduję 
		 się w głównym folderze projektu w module URLS.PY. 
			*Wenwnątrz tego moduły urls.py z głównego katalogu projektu musisz zaimportować metody include 
			 i path z django.urls 
			*dodać do tamtejszej listy urlpatterns obiekt URLpattern poprzez funkcje path z 1wszym 
			 argumentem w postaci ścieżki/nazwy_folderu_projektu oraz drugim w postaci funkcji include z 
			 argumentem który będzie ścieżką do pliku urls.py w katalogu naszej funkcjonalnośći(aplikacji) 
			 nazwanym tak jakby to była funkcja w module: 'nazwa_katalogu.urls':
					from django.urls import include, path
					urlpatterns =[
						... ,
						path('blog/', include('blog.urls'))
					]
		 od teraz pod ścieżką: http://127.0.0.1:8000/playground/hello będzie wyświetlać się twoja podstrona.
	  **OPCJA 2:
		*JEŻELI WIESZ ŻE TWOJA STRONA NIE BĘDZIE MIAŁA ŻADNYCH PODSTRON DLA DANEJ APP/FUNKCJONALNOŚCI to nie
		 musisz tworzyć wewnątrz app/funkcjonalności modułu urls.py. (np strona do rejestracji (patrz 
		 formularz do rejestracji))
		*Całe przekierowanie na plik views.py app/funkcjonalności zrobisz w głównej app/funkcjonalności w 
		 pliku urls.py w liście urlpatterns.
		*importujesz moduł views ze swojej app/funkcjonalności (w tym przypadku playground) i w liście 
		 urlpatterns dodajesz ścieżkę ('hello/') która będzie wskazywać na moduł vievs w app/funkcjonalności
		 playground:
						#plik urls.py w app/funkcjonalności django-project
						from playground import views
						urlpatterns = [							
							...
							path('hello/', views.says_hello, name='playground-hello')
						]
		*ponieważ z innych app/funkcjonalnośći też możesz importować moduł views.py dlatego przypisz alias
 		 wg schematu: nazwaAppFunkcjonalności_views:
						from users import views as users_views
						urlpatterns = [						#poniżej odwołanie do metody register w 
							...								#module views w app/funkcjonalności users
							path('register/', users_views.register, name = 'register'),
						]
	*module VIEWS.PY:
		*PODSTAWY:
			*funkcje w views.py sa 'request handlerami' i przyjmują 'request' a zwracają 'response'
			*w inncyh frameworkach module view.py miałby imię ACTIONS
			*wewnątrz tych funkcji we view.py możesz:
				*wpisać logikę działania danej aplikacji czyli co ma się stac gdy użytkownik wejdzie w daną 
				 ścieżkę/link.
				*wysyłać dane z bazy danych do innej bazy danych 
				*przetwarzać dane i je modyfikować 
				*wysyłać maile, itp.
		*ZWRÓCENIE OBIEKTU TYPU RESPONSE: 
			*metoda HttpResponse z modułu django.http (zwraca podany tekst w obiekcie HttpResponse):
							from django.http import HttpResponse
							def say_hello(request):
								return HttpResponse('Hello World')
			*metoda render() z django.shortcuts która jako argumenty przyjmuję:
				**requesta (pierwszy argument funkcji we views.py), 
				**ścieżkę wewnątrz katalogu templates składającą się na nazwę katalogu projektu wraz z 
				  nazwą pliku html (te pliki musżą znajdować się w katalogu templates) 
				**mapping object np.: dictionary (którego później będziesz używał do przesłania danych do 
				  dokumentu html'a znajdującego się w katalogu templates)(drugi argument rendera)
							from django.shortcuts import render
							def say_hello(request):
								return render(request, 'playground/helloHTML.html',{'name':'Mosh'})
			*metoda redirect() z django shortcuts która jako argument przyjmuję zmienną name która jest 
			 3cim argumentem metody path() z urlpatterns z pliku URLS.PY zamiast ścieżki do pliku html z 
			 katalogu templates (jak ma to miejsce w metodzie render(). Ponadto funkcja redirect() nie 
			 przyjmuję argumentu w postaci słownika któym mógłbyś przekazać dane do kolejnej strony(jak w 
			 render):
							from django.shortcuts import redirect
							def say_hello(request):
								return redirect('blog-home')
		*ZESTAWY DANYCH PRZESYŁANE PRZY ZWRACANIU OBIEKTÓW response z powyższych 3 metod:
			*W METODACH REDIRECT() I RENDER() MESSAGES: 
				*messages nie trzeba ich zwracać w słowniku w 3cim argumencie metody render(). Messages są 
				 przesyłane automatycznie przy zwracaniu obiektu typu response tj: przy metodzie redirect()
				 oraz przy metodzie render()). 
				*Trzeba zaimportować klasę messages z modułu django.contrib:
							from django.contrib import messages
							from django.shortcuts import redirect, render
					1)		def say_hello(request):
								messages.success(request, f'Text sended')
								return redirect('blog-home')
					2)		def say_hello(request):
								messages.success(request, f'Text sended')
								return render(request, 'playground/helloHTML.html',{'name':'Mosh'})
				*jest 5 rodzajów messages tóre możesz wysyłać w ten sposób:
						**messages.debug
						**messages.info
						**messages.success 
						**messages.warning
						**messages.error
				*żeby ukazać messages w swoim pliku.html to musisz umieścić w szablonie html (w templates):
							 {% if messages %}									 #jeżeli messages istnieje
								{% for mess in messages %}
									<div class="alert alert-{{ message.tags }}"> #w bootstrapie dodatkowo
																				 #dobiera kolor do message'a
										{{ mess }}								 #pokazuję treść message'a
									</div>
								{% endfor %}
							{% endif %}
						    {% block content %}{% endblock %}				#message bedzie sie wyświetlał	
																			#nad podminianym block contentem
				*(we views.py) do messages możesz przekazać jakieś dane:
					*dane z formularza rejestracji poprzez odwołanie się do metody get na polu cleaned_data:
							def register(request):
								if request.method='POST':
									form=UserCreationForm(request.POST)
									if form.is_valid():
										form.save()
										username = form.cleaned_data.get('username')
										messages.success(request, f'Account created for {username}!')
							
			*W METODZIE RENDER() SŁOWNIK JAKO 3CI ARGUMENT:
			   **DANE Z FORMULARZA które podajesz jako wartości do klucza w słowniku. Klucz ten może zostać 
			     wykorzystany jako zmienna w pliku html w celu przekazania danych z nieudanego formularza
				 (jeżeli pojawi sie jakiś błąd w formularzu i nie zostanie on zaakceptowany to zamiast 
				 wpisywać wszystkie pola od początku to zostaną one uzupełnione tymi z poprzedniego 
				 formularza:
								form = UserCreationForm()	#form = UserCreationForm(request.POST)
								return render(request,'users/register.html', {'form':form})
				 WIĘCEJ W FORMULARZU REJESTRACYJNYM W DZIALE IIGIM: PRZYKŁADY RÓŻNYCH APLIKACJI WE VIEWS.PY
			   **ZESTAW DANYCH WYCIĄGNIĘTY PRZEZ ORM DJANGO PRZYPISANY JAKO KLUCZ DO SŁOWNIKA (W metodzie 
			     render podany jako 3ci argument)
							from django.shortcuts import render
							from blog.models import Post
							from django.contrib.auth.models import User					#baza uzytkowników
							def say_hello(request):
								return render(request, 'blog/home.html',{'user': User.objects.first()})
									##Przykład jednej z poniższych instrukcji w postaci User.objects.first() 
									##jest przypisany do klucza 'user'
					*INSTRUKCJE które zwracają zestaw danych w postaci obiektów których możesz uzyć jako 
					 KLUCZ SŁOWNIKA (na przykładzie tabeli User pobranej z django.contrib.auth.models).
						##Poniższych komend możesz użyć też w konsoli shella w DJANGO-PYTHON i nie tylko
						##wywołać ale też przypisać do jakieś zmiennej 
						***PAMIĘTEJ żeby najpierw zaimportować bazy danych (znajdującą się w module 
						   models.py) oraz bazę użytkownikow która jest wbudowana w django:
								from blog.models import Post
								from django.contrib.auth.models import User				#baza uzytkowników
						*wszystkie obiekty z danej tabeli:	
								User.objects.all()	#zwróci: <QuerySet [<User: marek>, <User: testUser>]>
										#  w render 3ci argument:{'users': User.objects.all()}
						*pierwszy obiekt z danej tabeli:
								User.objects.first()						#zwróci: <User: marek>
										#  w render 3ci argument:{'user': User.objects.first()}
						*ostatni obiekt z danej tabeli:		
								User.objects.last()							#zwróci: <User: testUser>					
										#  w render 3ci argument:{'user': User.objects.last()}
						*wybrany zbior obiektów ODFILTROWANY przez filter np: username:
								User.objects.filter(username='marek')	#zwróci: <QuerySet [<User: marek>]>
								User.objects.filter(username='marek').first()	    #zwróci:  <User: marek>
										#  w render 3ci argument:
										#  {'users': User.objects.filter(username='marek')}
										#  {'user': User.objects.filter(username='marek').first}
						*zwrócenie użytkownika na bazie jakiegoś pola np id:
								User.objects.get(id=1)								#zwróci:  <User: marek>
										#  w render 3ci argument:{'user': User.objects.get(id=1)}
						*zwrócenie pola konkretnego rekordu odbywa się po kropce:
							**Primary KEY / id
								User.objects.filter(username='marek').first().pk   /LUB   
								User.objects.filter(username='marek').first().id			
										#  w render 3ci argument:
										#  {'pk': User.objects.filter(username='marek').first().pk}
										#  {'id': User.objects.filter(username='marek').first().id}
							**pozostałe:
								User.objects.filter(username='marek').first().email
										#  w render 3ci argument:
										#  {'email': User.objects.filter(username='marek').first().email}
						*zwrócenie pól z tabeli klucza obcego w naszej tabeli (w models.py w klasie Post:
						 {author=models.ForeignKey(User, on_delete=models.CASCADE)	}):
								p1 = Post.objects.get(id=1)
								p1.author.id									#zwróci: 1
								p1.author.email									#zwróci: 'marek@gmail.com'
										#  w render 3ci argument:
										#  {'authorId': Post.objects.get(id=1).author.id}
										#  {'authorEmail': Post.objects.get(id=1).author.email}
						*jeżeli odwołujesz się do obiektu w tabeli który jest kluczem obcym dla innej tabeli
 						 to możesz zobaczyc zbiór wszystkich wystąpień tego obiektu w tej tabeli dla której 
						 obiekt jest kluczem obcym poprzez odwołanie się do tejże tabeli wraz z '_set'.all()
						 (czyli możesz zobaczyć wszystkie obiekty związane z obiektem klucza obcego na jego 
						 bazie):
								u1=User.objects.filter(username='marek').first()
								u1.post_set.all()		#zwróci wszystkie posty danego usera
														#zwróci <QuerySet [<Post: Blog 1>, <Post: Blog 2>]>
										#  w render 3ci argument:
										#  {'posts': User.objects.get(id=1).post_set.all()}
						 tak samo jest z polami obiektu który jest kluczem obcym - żeby się do nich dostać 
						 też musisz odwołać się do nich po podkreślniku:
								posts=Post.objects.all()
								for p in posts:
									p.author_id			#zwróci dla każdego posta jego ID autora
		*TWORZENIE OBIEKTÓW w module views.py I ZAPISYWANIE ICH W BAZIE DANYCH:
			*UTWORZENIE oraz ZAPISANIE OBIEKTU(z models.py)/REKORDU dla DANEJ TABELI:
				**tworzenie:
					*musisz wcześniej pobrać dany obiekt(z models.py)/tabelę
					*tworzysz rekord w tabeli poprzez utworzenie obiektu przez konstruktor:
								from blog.models import Post
								from django.contrib.auth.models import User
								post_1 = Post(title='Blog 1', content='First Post Content'/
											  ,author=User.objects.filter(username='marek').first())
													#w kluczu obcym nie podajesz tylko id klucza obcego ale 
													#podajesz cały obiekt. Gdybyś chciał przypisać id to w
													#argumencie obieku tabeli obcej dodajesz podkreślnik
													#a w przypisywanym obiekcie dodajesz kropkę:
											##,author_id=User.objects.filter(username='marek').first().id)
				**zapisywanie:
								post_1.save()		#teraz mozesz zobaczyć że masz post_1 zapisany we 
													#wszystkich Postach: Post.objects.all()
													#które zwróci: <QuerySet [<Post: Post object (1)>]>
			*UTWORZENIE OBIEKTU poprzez ODWOŁANIE SIĘ DO OBIEKTU który jest KLUCZEM OBCYM DLA TWOJEJ TABELI:
 			  (możesz utworzyć obiekt na bazie obiektu klucza obcego)(poprzez odwołanie się do jego 
			   wszystkich wystąpień (_set) i na tym wywołać metodę create):
								u1=User.objects.filter(username='marek').first()
								u1.post_set.create(title='Blog 3', content='Blog content 3')
														#autorowi tworzysz dany post, nie musisz w tymże 
														#konstruktorze dodawać autora na samym końcu 
			**PRZEKAZANIE DANYCH Z FORMULARZA REJESTRACYJNEGO I NA ICH BAZIE UTWORZENIE OBIEKTU USERa:
					#FORMULARZ REJSTRACYJNY JEST OMÓWIONY W DZIALE IIGIM W PRZYKŁADACH RÓŻNYCH APLIKACJI 
					#WYTWORZONYCH WE VIEWS.PY			
							def register(request):
								if request.method == 'POST':			##gdy na dole w else'ie formularz 
																		##zostanie uzupełniony danymi to w 
																		##w pliku html poprzez przycisk 
																		##submit oraz metodę 'POST' z tagu 
																		##form te dane są przesłane i można
																		##je przekazać requestem
									formWithData=UserCreationForm(request.POST)	
																	##utworzenie formularza z danymi 
																	##przekazanymi przez metodę 'POST'
																	##z tagu form w pliku html
									if formWithData.is_valid():			##walidacja danych w formularzu
										formWithData.save()			##utworzenie użytkownika z danych z 
																	##formularza
										return redirect('blog-home')	##przekierowanie na stronę podaną
																		##w zmiennej name w urls.py 
																		##app/funkcjonalności blog
									else:									
										return render(request,'users/register.html', {'form':formWithData})
																	##wysłane powtórnie formularz z 
																	##uzupełnionymi danymi gdy dane z 
																	##formularza mają jakiś błąd
								else:
									formWithoutData = UserCreationForm()
									return render(request, 'users/register.html', {'form':formWithoutData})
																		##na początku odpala się formularz
																		##bez danych ponieważ nie została
																		##w pliku html nie została jeszcze
																		##odpalona metoda POST z tagu form
					**formularz REJESTRACYJNY tworzy się poprzez klasę UserCreationForm() 
							from django.contrib.auth.forms import UserCreationForm
							form = UserCreationForm(request.POST)			#request.POST oznacza że 
																			#przekazuje dane z formularza
					**form.is_valid() pozwala zwalidować dane z formularza:
							form.is_valid():
					**form.save() pozwala zapisać dane z formularza (dla UserCreationForm() baza danych 
					  jest domyślnie ustawiona na USER:
							form.save()
					  
	*katalog TEMPLATES (którego tworzymy sami (musi być tak nazwany))
	   A*PODSTAWY:
			*w innych frameworkach byłoby to nazwane views ale w Django viev.py odpowiada za coś innego
			*są tam m.in dokumenty html które możesz przekazywać poprzez metodę render w module views.py 
			*praktyka jest taka że wewnątrz folderu templates musisz stworzyć jeszcze folder o nazwie 
			 app/funkcjonalności i to właśnie w nim umieszczasz pliki HTML --> Django domyślnie szuka 
			 ścieżki templates w danej aplikacji/funkcjonalnosci oraz przeszukuję w sekcji INSTALED_APPS
			 w pliku settings w głównym projekcie wskazane aplikacje/funkcjonalnosci.
			*żeby dokumenty HTMLa w folderze 'templates/nazwaAplikacji' działały to w pliku settings.py
			 w głównej app/funkcjonalności w sekcji INSTALED_APPS umieść nazwę klasy, która dziedziczy
			 po AppConfig z pliku apps.py z katalogu danej app/funkcjonalności (zapisane w cudzysłowiu)
			 np: 'mojBlog.apps.mojBlogConfig' (ALBO tylko nazwę app/funkcjonalności np 'mojBlog')
			 (ex: 'blog.apps.BlogConfig' )
	   B*MOŻLIWOŚC EDYTOWANIA PLIKÓW HTML:
		  *PODSTAWY:
			*możesz edytować pliki HTML dla różnych zmiennych poprzez przekazanie w metodzie render 
			 (w pliku views.py) słownika(dictionary). 
			*do wartości tego słownika odwołujesz się poprzez wypisanie kluczy bez cudzysłowiów. Jeżeli 
			 wartości słownika odpowiadają listom albo innym słownikom to odwołujesz się do ich elementów
			 NIE poprzez NAWIASY KWADRATOWE (wypisanie numeru elementu (dla list) lub nazwy klucza (dla 
			 słownika)) tylko poprzez wypisanie kolejnych elementów PO KROPCE (numer elementu po kropce 
			 (dla list) lub nazwa klucza po kropce (dla słownika)).
		  *ROZSZERZENIE:	 
			*KONSTRUKCJE UZYSKANE POPRZEZ EDYTOWANIE HTMLA (NAWIASY WĄSOWE{}):
				*zmienne - zawierasz w podwójnych nawiasach wąsowych:
						<h1>Hello {{name}}</h1>
					###(we views.py) dla danej funkcji zwracającej: 
					###render(request, 'playground/hello.html',{'name':'Mosh'}) 		
															#zwróci: <h1>Hello Mosh</h1>
					*chcąc odwołać się do zmiennej którą jest obiekt typu datetime możesz edytować go 
					 według schematu edytowania obiektów typu datetime (czyli '|date' + zmienne): 
						<h1>{{zmienna_date|date:"F d, Y"}}</h1>		#edycja: Month, day, YEAR
				*konstrukcje IF - zawierasz w nawiasach wąsowych ze znakiem procenta wg składni:
						{% if name %}				#jeśli klucz 'name' istnieje
						<h1>Hello {{name.0}}</h1>	#zwróc pierwszy element listy
						{% else %}
						<h1>Hello World</h1>
						{% endif %}
					###(we views.py) dla danej funkcji zwracającej rendera w którym przekazujesz słownik  
					###z kluczem któremu odpowiada wartość w postaci listy zawierającej imona). 
					###render(request, 'playground/hello.html',{'name':['Mosh','Gosh'}) 
															#zwróci: <h1>Hello Mosh</h1>
				*konstrukcje FOR - zawierasz w nawiasach wąsowych ze znakiem procenta wg składni:
						{% for p in posts %}	#przejdz przez liste ktora jest wartością dla klucza posts
							<h1>{{p.title}}</h1>
						{% endfor %}
					###(we views.py) dla danej funkcji zwracającej rendera w którym przekazujesz słownik 
					###z kluczem z odpowiadającą wartością w postaci listy zawierającej słowniki:
					###render(request, 'playground/hello.html',{'posts':'[{'title':'one'}{'title':'two'}]})
															#zwróci: <h1>one</h1>	  \n     <h1>two</h1>
			*SZABLONY w HTMLu:
				*tworzysz gdy wiele stron ma powtarzające się fragmenty.Miejsca te zastąpisz 1 szablonem
				*możesz go uzyskać poprzez stworzenie szablonowego pliku htmla i umieszczenie w nim w 
				 odpowiednich miejscach bloków {block content} gdzie treśc w zależności od linku/plikuHTML 
				 będzie się zmieniać. Te bloki oznaczasz w sposób: {% block blockName %}{% endblock %}
					#plik base.html który jest szablonem podstawowym dla innych plików html
						<!DOCKTYPE html>
						<html>
							<head>
								<meta charset="utf-8">
								<meta name="viewport" content="width=device-width, initial-scale=1">
								<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
								<title>Hello, world!</title>
							</head>
							<body>
								{% block blockName %}{% endblock %}
							</body>
						</html>
				**w odpowiednich plikachHTML/linkach wykorzystujesz ten szablon (ładując go na początku 
				 pliku poprzez podanie w cudzysłowiu ścieżki do szablonu (pliku HTML) zaraz za słowem 
				 extends. Szablon ten znajduję się w katalogu templates {% extends "blog/base.html %}) 
				 i nastęnie tworzysz wnętrze bloku który ma być podmieniony w szablonie, okalając go wg 
				 schematu:  {% block blockName %}...{% block blokName %}:
						#plik home.html (który będzie wykorzystywał szablon base.html):
						{% extends  "blog/base.html" %}
						{% block content %}
							{% for p in posts %}
								<h1>{{p.title}}</h1>
							{% endfor %}
						{% endblock content %}
				**jeżeli chciałbyś użyć szablonu z innej app/funkcjonalności to dzięki temu że Django
				  w pierwszej kolejności przechodzi przez sekcję INSTALLED_APPS w settings.py w której 
				  zapisujesz wszystkie aplikację/funkcjonalności i dzięki temu że w strukturze katalogu 
				  templates oprócz szablonu HTML dodajesz (pomiędzy) jescze katalog o nazwie aplikacji/
				  funkcjonalności to wystarczy że w swoim pliku html chcącym wykorzystać szablon z innej
				  app/funkcjonalności podasz: nazwa_aplikacji/nazwe_szablonu.html
						{% extends  "blog/base.html" %}		#plik register.html z app/funkcjonalności
															#users będzie wykorzystywał szablon base.html
															#z app/funkcjonalności blog 
											#nie musisz wpisywać specjalnej ścieżki żaby iśc w górę by 
											#przejś do katalogu innej app/funkcjonalności.
			*LINKI W HTMLU: 
				*zamiast wpisywać ścieżki w linkach to podawaj zmienne których nazwy będą odwoływać się do 
				 argumentu name w pliku urls.py w zmiennej urlpatterns w tej samej app/funkcjonalności 
				*dzięki temu gdybyś chciał zmienić link to będziesz mógł to zrobić w jednym miejscu czyli
				 w liście urlpatterns w metodzie path w pliku urls.py w naszej app/funkcjonalności
				 zamiast w dwóch miejscach czyli w metodzie path oraz pliku html.
					#w pliku urls.py w naszej głównej app/funkcjonalności:
						urlpattrens =[path('home/', views.say_hello, name='playground-hello')]	
					#od teraz w plikach html zamiast używać /home wpisujesz {% url 'plaground-hello' %}
						...<a href={% url 'plaground-hello' %}>...</a>...
			*FORMULARZ REJSETRACYJNY W HTMU:
						{% extends "blog/base.html" %}	   # ładujesz szablon
						{% block content %}				   # wpisujesz swoją wersję miejsca podmienianego
							<form method ='POST'>		   # dla tagu form dodajesz argument POST który
														   ##przesyła dane w formularzu
								{% csrf_token %}		   # bez csrf_token formularz nie zadziała
									{{ form|crispy }}	   # podajesz zmienną form wyrenderowaną CSSowo
							</form>						   ##względem pobranych stylów crispy
						{% endblock content %}				
				**możesz dodatkowo wyrenderować formularz poprzez funkcjonalność CSSową CRISPY_FORMS 
				  JEST TO DOKŁADNIE OMÓWIONE W OPCJI ROZSZERZONEJ FORMLARZA REJESTRACYJNEGO PKT2GIM
				  w DZIALE IIgim CZYLI RZYKŁADY RÓŻNYCH APLIKACJI WYTWORZONYCH WE VIEWS.PY
	   C*PLIKI CSS, javascript, MEDIA:
			*w katalogu templates musisz stworzyć specjalny katalog 'static' a w nim katalog o nazwie 
			 app/funkcjonalności w którym będziesz przechowywał pliki które się nie zmieniają przy 
			 przechodzeniu na inne podstrony (takie jak css, zdjęcia, javascript)
			*by załadować te pliki musisz w swoich szablonach html (NIE w plikach html które są na bazie 
			 szablonu) na samej górze umieścić ich załadowanie poprzez:
					{% load static %}
			 oraz w sekcji head umieścić do nich link css poprzez:
					<link rel="stylesheet" type="text/css" href="{% static 'playground/main.css' %}">
	
2. KOMENDY które warto opisać do 'django-admin' a raczej do 'python manage.py' który jest wrapperem do 
     django-admin (specjalnie używamy python manage.py _____ zamiast django-admin _______ gdyz ta pierwsza 
	 komenda bierze pod uwage plik settings.py a druga już nie):
		*runserver - URUCHOMIENIE SERWERA gdzie domyślnym portem jest 8000 ale można podać swój port jak
			kolejny argument - w tym przypadku jest to 8000.
					python manage.py runserver    ||   python manage.py runserver 9000  
				*Po tej komendzie pokażę się adres strony który będzie działał na lokalnym serwerze i będzie
				 odzwierciedleniem tego co zrobiłeś. Wklej go do przeglądarki.
				*jeżeli pojawi się Tobie błąd invalid syntax to oznacza to że nie została aktywowana 
				 wirtualka (pipenv shell) 
				*żeby zakończyć wciśnij CTRL + C
		*startapp - tworzy nową pojedyńczą funkcjonalność zwaną aplikacją. 
					python manage.py startapp nameapp
		*createsuperuser - tworzy użytkownika (administratora) w celu pierwszego uruchomienia/zalogowania
			do strony administrowania gdzie możesz zarządzać bazami danych oraz użytkownikami o różnych 
			polach dostępu. Żeby móc stworzyć pierwszego administratora (który pozwoli ci się zalogować
			do strony administratora musisz najpierw stworzyć domyślne bazy danych poprzez migrate):
					python manage.py migrate
					python manage.py createsuperuser
		*makemigrations - tworzy 'migracje' czyli na podstawie utworzenia bądz zmiany klasy w pliku 
			models.py tworzy plik migracji w katalogu migrations. Taki plik zawiera wszystkie zmiany jakie 
			były dokonane od ostatniego użycia komendy makemigrations. 
					python manage.py makemigrations
		*sqlmigrate nameAplications numberOfMigration - daję możliwość podejrzenia jakie instrukcje sql
			zostaną wytworzone na podstawie konkretnej 'migracji'
					python manage.py sqlmigrate blog 0001
		*migrate - wykonuję instrukcje sql które są automatycznie wytworzone przez ORM na podstawie 
			wszystkich migracji. Wynik tych instrukcji zostanie zapisany w plikach bazy danych (domyślnie 
			dla sqlite db.sqlite3):
					python manage.py migrate
		*shell - pozwala na interaktywne działanie na modelach (klasach reprezentujących tabele w bazie
			danych). Otwiera django-pythonową konsole shella (basha). Wewnątrz konsoli możesz odwoływać się 
			do obiektów które są zestawami danych zwróconymi z tabel przez odpowiednie metody - metody te 
			są wykorzystwane w module view.py jako wartośc do klucza słownika podawanego jako 3ci argument 
			w metodzie render (patrz module view.py)
					python manage.py shell
					
1. INSTALACJA, URUCHOMIENIE oraz STRUKTURA PROJEKTU:
	1) Stworzenie WIRTUALKI i pobranie django:
		*najważniejsze jest to że zanim stworzysz wirtualkę to najpierw zadbaj o to żeby być WEWNĄTRZ 
		 głównego katalogu projetku a nie folder wyżej:
			pip3 install pipenv 	#jeżeli nie masz pipenv'a zainstalowanego globalnie u siebie. Jest to 
									#wirtualka żeby nie instalować wszystkich modułów w jednym miejscu  
									#będąc w folderze projektu:
			pipenv install django	#kopiujesz link do virtualenv location i przechodzisz do miejsca gdzie
									#zosała zapisan wirtualka a w niej zainstalowane Django
	
	2) START PROJEKTu w terminalu: 
			*musisz aktywować wirtualkę tak żeby interpreter pythona mógł działać dlatego będąc w folderze 
			 projektu wpisujesz komendę:
						pipenv shell 
			*żeby wyświetlić wszystkie funkcje którymi można się posługiwać w Django użyj:
						django-admin
			*następnie rozpocznij start nowego projektu:
						django-admin startproject nameproject .	
									#dodaj kropkę na samym końcu żeby projekt został stworzony w aktualnym
									# folderze zmiast tworzyć dodatkowy pośredni folder
	
	3)URUCHOMIENIE PROJEKTU W TERMINALU:
				pipenv shell
				python manage.py runserver	-->  http://127.0.0.1:8000   /  http://localhost/8000   
												 CTRL + C (żeby przerwać)
												 exit ( żeby wyjść z pipenva)
												 
	4)STRUKTURA Twojego PROJEKTU (powstała ona poprzez komende django-admin startproject nameproject) a 
	  wewnątrz jej znajdują się pliki:
		A* folder nameproject:
			*__init__.py - mówi interpreterowi Pythona że jest to paczka Pythonowa
			*settings.py - odpowiada z austawienia naszej aplikacji - składa się z sekcji:
				**INSTALLED_APPS składa sie z:
						*wbudowanych aplikacji w Django zaczynających się od django.contrib:
							*.admin - admin interface to manage data,
							*.auth - authenticating app to authentication users
							*.contenttypes
							*.session - (no longer use this)
							*.messages - display user a one-time notifications
							*.staticfiles - for serving files (images, css files, itp)
						*z wpisanych przez nas nazwy app/funckjonalności po wcześniejszym jej utworzeniu
						 (python manage.py startsapp nameapp), (nazwę wpisujesz w cudzysłowiu)
			*urls.py - tutaj definiujemy linki url naszej aplikacji
			*asgi.py oraz wsgi.py - odpowiadają za deployment
		B* manage.py - to jest wrapper naszej komendy django-admin, który powinniśmy uruchamiać z komendami 
		    dajngo-admin (zamiast djagno-admin + komenda). Wszystko dlatego że manage.py bierzesz pod uwagę 
			również plik settings.py a komenda django-admin już nie.
					*zamiast używać: django-admin runserver 	
							#spowoduję Tobie to błąd django.core.excpetionsImproperlyConfigured
					*dlatego użyj: 
							  python manage.py runserver  
		C* FOLDERY Z POJEDYŃCZYMI APP/FUNKCJONALNOŚCIAMI:
			*(pojedyńczą app/funkcjonalnością a nie całym projektem)
			*pojedyńczy folder/APLIKACJA tworzy się w terminalu poprzez: 	  
							python manage.py startapp nameApp
			 i następnie trzeba go zarejestrować poprzez wpisanie jego nazwy w apostrofach w:
							folderZprojektem --> settings.py --> INSTALLED_APPS
			 *STRUKTURA APLIKACJI/pojedyńczego folderu:	
						*folder migrations - do generowania baz danych 
						*admin module - wygląd admin interface dla tej aplikacji 
						*app module - miejsce do konfigurowania aplikacji 
						*models module - miejsce do definiowania modeli klas - służy do przechowywania i 
						    pobierania danych; służy do wyciągania danych z bazy danych i przedstawiania 
							ich użytkownikowi.
						*tests module - miejsce do unittestów do aplikacji 
						*views module - request handler, używa się przy wymianie danych między użytkownikiem
						    (który wysyła rządanie (request)) a serwerem który odsyła odpowiedź (response).
	*) Aktywując wirtualkę (pipenv shell) automatycznie zostanie wybrany interpreter pythona z wirtualki ale
 	   możesz to zrboić ręcznie Visual Studio wybierz View --> Command Palette --> Select Intepreter
	   i tam wklej ścieżkę do wirtualki (będąc wcześniej w terminalu w ścieżce projektu uzyskasz ścieżkę 
	   do interpretera poprzez komendę pipenv --venv oraz dodając do uzyskanej ścieżki '\bin\python' ALBO 
	   '\Scripts\python') lub względem ścieżki którą udało ci się uzyskać poprzez komendę pipenv --venv 
	   możesz samemu wybrać interpreter Pythona klikając w opcję FIND.
	   
0. PODSTAWY:
	*Backend in Webdevelopment - "how you're going to respond to clients":
		*by generating requested page using HTML on the server and respond client by sending it 
		*by returning only the data needed on the requested page ---> Server is the gateway to the data 
		 ---> Server provides an API to the clients
	*Frameworki:
		*SERVER-SIDE FRAMEWORK:
			*Django
			*Node.js / Express
		*CLIENT-SIDE FRAMWORKS:
			*React
			*Angular
			*Vue
	*DJANGO:	
		*Advantages:
				*LESS TIME & LESS CODE with huge community
				*it's slower but can take more data
				*youtube, instagram, spotify, dropbox
		*Django is a collection of various apps each providing certain functionality - some examples of 
		 created builtins features:
				*admin site
				*Object-relational-mapper
				*authentication
				*caching
		
	