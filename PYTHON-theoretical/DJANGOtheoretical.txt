
TEMPLATES: 
	WSZYSTKIE KONSTRUKCJE:			https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#
	WRAZ Z FILTRAMI do edycji: 		https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#built-in-filter-reference

============================================================================================================
=======II.PRZYKŁADY RÓŻNYCH APLIKACJI WYTWORZONYCH WE VIEWS.PY W KONKRETNYCH APP/FUNKCJONALNOŚCIACH=========
============================================================================================================
	1)FORMULARZ DO REJESTRACJI
	  **OPCJA PODSTAWOWA - UserCreactionFrom
	  **OPCJA ROZSZERZONA - dziedziczenie po UserCreationForm
	2)STRONY DO LOGOWANIA, DO LOGOUTu
	  **LOGIN OPCJA 1 - include("django.contrib.auth.urls") --> login/ i logout/
	  **LOGIN OPCJA 2 - from django.contrib.auth import authenticate, login, logout
	  **LOGIN OPCJA 3 - AuthenticationForm + from django.contrib.auth import login, logout
	  **LOGIN OPCJA 4 - LoginView + Logoutview
	3)STRONA PROFILU:
	  **PROFILE OPCJA 1 - PRZESŁONIĘCIE KLASĄ AbstractBaseUser (kiedyś AbstractUser):
 	  **PROFILE OPCJA 2 - stworzenia klasy profile relacją jeden do jeden (OneToOneField) z klasą User
 
============================================================================================================
====================================================PODSTAWY================================================
============================================================================================================
6. ELEMENTY ROZSZERZONE:
	0)DODATKI:
		*DJANGO USER MODEL - from.django.contrib.auth.models import User
		*DJANGO TEMPLATING LANGUAGE - (w html'u metody bez nawiasów)
		*WYSZUKIWARKA HTML request.GET
		*OPEROWANIE CZASEM i DATAMI w DJANGO - (from django.utils import timezone i import datetime)
	1)OBIEKT REQUEST:
		*PODSTAWY:
		*DLA FORMULARZY:
			*REQUEST.GET: request.GET.get('my_attr')
			*REQUEST.POST: request.POST.get('my_attr') || request.POST.getlist('my_list')
	2)ZDJĘCIA UPLOADOWANE
		A)PODSTAWY
		B)RESIZING UPLOADOWANYCH ZDJĘĆ
	3)RESTRICTED ROUTE
	4)FLASH MESSAGES
5.ROZSZERZONE MODUŁY i FOLDERY w APP/FUNCKJONALNOŚCIACH:
  *1*SIGNALS (kontynuacja MODELS) oraz APPS.PY w danej app/funkc:
  *2*FORMULARZE i FORMS.PY (rozszerzenie VIEWS.PY)
		0.DZIAŁANIE STANDARDOWYCH FORMULARZY W HTMLu 
		1*PODSTAWOWY FORMULARZ W DJANGO:
			A*z POLAMI DLA KLASY
			B*z KLASĄ WEWNĘTRZNĄ
			***WŁASNA WALIDACJA DANYCH
			***RENDEROWANIE CRIPY FORM
		2*FORMULARZ PODSTAWOWY Z MODELEM MAJĄCYM POLE TYPU ManyToManyField
		3*MIESZANY FORMULARZ - zawierający pola standardowego formularza w HTMLu i pola oparte na zmiennych
  *3*CLASS-BASED-VIEWS		
    a)*PODSTAWY
		A*RÓŻNICE MIĘDZY FUNCTION-BASED-VIEWS a CLASS-BASED-VIEWS
		B*DZIAŁANIE
	b)*PRZYPADKI
		**LISTVIEW
		**DETAILVIEW
		**CREATEVIEW
		**UPDATEVIEW
		**DELETEVIEW
	c)*MIXINS:
		**PODSTAWY:
		**LOGINREQUIREDMIXIN
	d)*PORÓWNANIE FUNCTION-BASED-VIEWS z RAW CLASS-BASED-VIEWS z CLASS-BASED-VIEWS
4. PODSTAWOWE MODUŁY i FOLDERY w APP/FUNCKJONALNOŚCIACH:
	*1*module MODELS.PY 
		1*PODSTAWY:
		2*BUDOWA:
		   X*PODSTAWY - models.Model (from django.db import models) )
		   A*RELACYJNE TYPY PÓL W OBIEKCIE:
		   B*ZWYKŁE TYPY DANYCH konkretnych pól w obiekcie
		   C*METODY
		   D*KLASA WEWNĘTRZNA META  ('ordering' przy zwracaniu danych poprzez ORM)
		   E*ROZSZERZENIE
	*2*katalog MIGRATIONS 
	*3*module URLS.PY (instrukcja w urls.py w głównej app/funkc.)
		**URLS.PY TYLKO W GŁÓWNEJ APP/FUNKC.
		**URLS.PY W POZOSTAŁYCH APP/FUNKC.
		**REDIRECTVIEW
		**DYNAMIC URLS
			*PODSTAWY
			*PRZEKAZYWANIE PARAMETRÓW (DYNAMIC URL) Z URLS DO VIEW
			*ALTERNATYWA DO DYNAMIC URL - WYSZUKIWARKA (FORM method=GET)
	*4*module VIEWS.PY
		1*PODSTAWY
		2*ZWRÓCENIE OBIEKTU TYPU RESPONSE - METODY
		3*ZESTAWY DANYCH POBRANE Z BAZY DANYCH
		4*TWORZENIE OBIEKTÓW we views.py, ZAPISYWANIE ICH W BAZIE DANYCH i USUWANIE ICH Z BAZY DANYCH
	*5*katalog TEMPLATES
	   A*PODSTAWY
	   B*MOŻLIWOŚC EDYTOWANIA PLIKÓW HTML (DJANGO TEMPLATING ENGINE - JINJA )
			*PODSTAWY:
			*ROZSZERZENIE:
				*KONSTRUKCJE UZYSKANE POPRZEZ EDYTOWANIE HTMLA (NAWIASY WĄSOWE{})
					*zmienna user
					*zmienne
					*konstrukcje IF
					*konstrukcje FOR
					*SKRÓT -> szablony w HTMLu
					*SKRÓT -> linki w htmlu 
					*SKRÓT -> linki do podfolderów i ładowanie plików static 
				*SZABLONY w HTMLu
				*ZAINKLUDOWANIE WSTAWKI HTML do PLIKU HTML
				*LINKI W HTMLU
				*FORMULARZ REJSETRACYJNY W HTMU
3. ORM DJANGO:
   0*PODSTAWY
   1*INSTRUKCJE zwracające zestaw danych
   2*INSTRUKCJE zwracające zestawy danych ZWIĄZANE Z KLUCZEM OBCYM
   3*UTWORZENIE OBIEKTU - INSTRUKCJE TWORZĄCE I ZAPISUJĄCE DANE W TABELI
	   A*STANDARDOWO
	   B*METODA CREATE()
	   C*METODA get_or_create()
	   D*UTWORZENIE OBIEKTU poprzez ODWOŁANIE SIĘ DO KLUCZA OBCEGO
	   E*DODANIE OBIEKTU KTÓRY JEST KLUCZEM OBCYM DLA INNEGO MODELU - METODA ADD
   4*USUWANIE OBIEKTU Z TABELI
2. KOMENDY do 'django-admin' / 'python manage.py'
1. INSTALACJA, URUCHOMIENIE oraz STRUKTURA PROJEKTU:
0. PODSTAWY:

============================================================================================================
=======II.PRZYKŁADY RÓŻNYCH APLIKACJI WYTWORZONYCH WE VIEWS.PY W KONKRETNYCH APP/FUNKCJONALNOŚCIACH=========
============================================================================================================
	---------------------------
	---------------------------
	1)FORMULARZ DO REJESTRACJI:
	---------------------------
		*https://www.techwithtim.net/tutorials/django/user-registration/
		--------------------
		A) OPCJA PODSTAWOWA - UserCreactionForm
		--------------------
			1*W URLS.PY:
				*Tworzysz nową aplikację users
					python manage.py startapp users
				*dla głównej app/funkcjonalności w settings.py w INSTALLED_APPS dodajesz:
						'users.apps.UsersConfig',
				*w głównej app/funkcjonalności w pliku urls.py w urlpatterns dodajesz ścieżkę ('register') 
				 która będzie wskazywać na moduł views w app/funkcjonalności users. (ze względu na to że 
				 ścieżka register nie będzie miała żadnych innych podstron to nie musisz tworzyć dodatkowego
				 modułu urls.py w app/funkcjonalności users. Wystarczy zawrzeć przekierowanie w urls.py 
				 w głównej app/funkcjonalności)
						#plik urls.py w app/funkcjonalności django-project
						from django.urls import path
						from users import views
						urlpatterns = [							#poniżej odwołanie do metody register w 
							...									#module views w app/funkcjonalności users
							path('register/', views.register, name = 'register'),
						]
				*ponieważ z innych app/funkcjonalnośći też możesz importować moduł views.py dlatego 
				 przypisz alias wg schematu: nazwaAppFunkcjonalności_views:
						#plik urls.py w app/funkcjonalności django-project
						from users import views as users_views
						urlpatterns = [							#poniżej odwołanie do metody register w 
							...									#module views w app/funkcjonalności users
							path('register/', users_views.register, name = 'register'),
						]
						
			2*WE VIEWS.PY (logika działania): 
				*korzystasz z gotowego modułu UserCreationForm, do tworzenia schematycznych formularzy 
				 składających się z: 'username', 'password1', 'password2' (do zatwierdzenia password1).
				 moduł ten musisz zaimportować:
							from django.contrib.auth.forms import UserCreationForm
				*tworzysz funkcję odpowiedzialną przy rejestracji:
					*za utworzenie użytkownika z danych przesłanych przez formulasz, walidację i zapis
					*za przekierowanie na inną stronę po udanej operacji lub w przypadku niuedanej operacji
					 za ponowne otworzenie strony register wraz z danymi przekazanymi w poprzednim 
					 formularzu:
							def register(request):
								if request.method == 'POST':			##gdy na dole w else'ie formularz 
																		##zostanie uzupełniony danymi to w 
																		##w pliku html poprzez przycisk 
																		##submit oraz metodę 'POST' z tagu 
																		##form te dane są przesłane i można
																		##je przekazać requestem
									formWithData=UserCreationForm(request.POST)	
																	##utworzenie formularza z danymi 
																	##przekazanymi przez metodę 'POST'
																	##z tagu form w pliku html
									if formWithData.is_valid():			##walidacja danych w formularzu
										formWithData.save()			##utworzenie użytkownika z danych z 
																	##formularza
										return redirect('blog-home')	##przekierowanie na stronę podaną
																		##w zmiennej name w urls.py 
																		##app/funkcjonalności blog
									else:									
										return render(request,'users/register.html', {'form':formWithData})
																	##wysłane powtórnie formularz z 
																	##uzupełnionymi danymi gdy dane z 
																	##formularza mają jakiś błąd
								else:
									formWithoutData = UserCreationForm()
									return render(request, 'users/register.html', {'form':formWithoutData})
																		##na początku odpala się formularz
																		##bez danych ponieważ nie została
																		##w pliku html nie została jeszcze
																		##odpalona metoda POST z tagu form
				*możesz rozszerzyć tę funkcje o wewnątrzną modyfikację danych (np o to żeby username był
				 z małych liter zawsze - żeby użytkownik nie wpisał różnej wielkości liter). poprzez arg
				 commit=False w funkcji save() tworzysz użtykownika ale nie zapisujesz go na serwer
				 ORAZ o zalogowanie bezpośrednio po utworzeniu konta:
							from django.contrib.auth import login	
							def register(request):
								form = UserCreationForm()
								if request.method == 'POST':
									form=UserCreationForm(request.POST)					
									if form.is_valid():
										us = form.save(commit=False)	##utworzenie usera bez zapisania
										us.username = us.username.lower()
										us.save()						##zapisanie w bazie danych
										login(request, us)				##logowanie po rejestracji
										return redirect('blog-home')		
								return render(request, 'users/register
				*możesz rozszerzyć tę funkcję o wiadomość o udanej operacji zapisania (patrz: 6.ELEMENTY 
				 ROZSZERZONE -> 5.FLASH MESSAGES);
					*WE VIEWS.PY
							from django.contrib import messages
									...
									if formWithData.is_valid():
										formWithData.save()
										username = formWithData.cleaned_data.get('username')
														#pobiera wartość dla klucza'username' ze słownika 
														#cleaned_data należacego do formularza
										messages.success(request, f'Account created for {username}!')
														#tworzysz wiadomość która będzie automatycznie
														#przesłana wraz z metodą redirect() lub render()
										return redirect('login')
														#po stworzeniu logowania, po zarejestrowaniu 
														#niech od razu przenosi do możliwośći zalogowania. 
					*W TEMPLATES:
							{% if messages %}
								{% for message in messages %}
									<div class="alert alert-{{ message.tags }}">
																		#wystylizowanie poprzez bootstrapa 
																		#wg pola tags ze zmiennej messages
										{{ message }}					#wiadomość przekazana w formularzu
									</div>
								{% endfor %}
							{% endif %}
							
			3*W TEMPLATES'ACH UTWORZENIE PLIKU HTML (register.html):
				*Tworzysz katalog templates i podkatalog o nazwie app/funkcjonalności users i 
				 wewnątrz tworzysz plik html: register.html:
				*odwołujesz się do szablonu umieszczonego w templates'ach innej app/funkcjonalności 
				 (w tym przypadku aplikacji/funkcjonalnośći blog)(nie musisz wpisywać specjalnej ścieżki 
				 żaby iśc w górę by przejśc do katalogu innej app/funkcjonalności. Ze względu na to
				 że strukture plików tworzysz tak że oprócz katalogu templates zawsze tworzysz katalog o 
				 nazwie app/funkcjonalności to wystarczy że odwołasz się do nazwy tej aplikacji i 
				 nazwy szablonu w niej zawartego):
						{% extends "blog/base.html" %}				#odwołujesz się do szablonu base.html 
																	#w app/funkcjonalności blog
				*tworysz strukturę formularza html która będzie podmieniana w szablonie html'a (base.html).
				 Ponieważ to formularz to dodajesz atrybut method ='POST' do tagu <form> żeby móc wysyłać
				 treści znajdujące się w polach formularza:
						{% block content %}	
							<div class="content-section">
								<form method='POST'>
								...
								</form>
							</div>
						{% endblock %}
				*wewnąrz formularza by działał właściwie musisz dodać w pojedyńczych nawiasach wąsowych 
				 (ukryty_tag/token) csrf_token oraz w podwójnych nawiasach wąsowych zmienną form która
				 bedzie wyrenderowana poprzez pole as_p (nazwa_pola i pole_formularza będą zaczynać się
				 od nowej linii)). W ten sposób powstanie nam domyślny formularz, który trzeba jeszcze 
				 uzupełnić o button typu submit żeby móc wysyłać dany formularz (jest to możliwe dzięki 
				 przypisaniu 'POST' do atrybutu method w tagu form):
						{% block content %}	
							<div class="content-section">
								<form method='POST'>
									{% csrf_token %}
									{{ form.as_p }}
								</form>
							</div>
							<div class="form-group">
								<button type="submit">Sign Up</button>
							</div>
						{% endblock %}		
		--------------------
		B) OPCJA ROZSZERZONA - dziedziczenie po UserCreationForm:
		--------------------
			1*W URLS.PY tak samo jak w OPCJI PODSTAWOWEJ.
			2*WE VIEWS.PY
			 *Tworzysz swój własny typ formularza który nie będzie oparty o zaimportowany UserCreationForm
			  tylko o własną klasę która będzie dziedziczyć po UserCreationForm i która będzie rozszerzona 
			  o dodatkowe pola w formularzu:
			   2.0*WE FORMS.PY (class UserRegisterForm(UserCreationForm)):
					*wewnątrz swojej app/funkcjonalności users tworzysz moduł forms.py w którym tworzysz 
					 klasę UserRegisterForm dziedziaczącą po UserCreationForm. 
					*W tej klasie importujesz odpowiednie moduły, tworzysz dodatkowe pola w formularzu, 
					 wskazujesz bazę danych z modeli ze swojej app/funkcjonalności oraz wypisujesz kolejność 
					 swoich pól w liście fields:
							from django import forms		
										#do pobierania róznych typów pól dla formularzy, tutaj EmailField()
							from django.contrib.auth.forms import UserCreationForm
															#do możliwości dziedziczenia w swojej klasie
							from django.contrib.auth.models import User
															#do wskazania modelu Bazy danych w zmiennej model
							class UserRegisterForm(UserCreationForm):
								#email=forms.EmailField()	#nie musisz tego wpisywać gdyż pola formularz 
															#weżmie sobie z listy fields ale tutaj możesz
															#w parametrze wpisać ograniczenia (max_width=100)
															#lub format daty w przypadku pola Daty
								class Meta:					#w klasie wewn. Meta określasz model do form
									model=User				#określasz bazę danych gdzie mają być zapisane 
															#dane z formualrza
									fields = [ 'username', 'email','password1','password2']
															#lista fields gdzie określasz wszystkie pola
															
			   2.1*WE VIEWS.PY:
					*ponieważ klasa UserRegisterForm dziedziczy po UserCreactionFrom to tylko je podmieniasz,
					 wcześniej importując UserRegisterForm z modułu forms znajdującego się w tym samym 
					 katalogu
					*dodatkowo dodajesz messages (patrz 6.ELEMENTY ROZSZERZONE -> FLASH MESSAGES)
							from django.shortcuts import render, redirect
							from django.contrib import messages	
							from django.contrib.auth import login
							from . forms import UserRegisterForm
							def register(request):
								if request.method == 'POST':
									formWithData = UserRegisterForm(request.POST)
									if formWithData.is_valid():
										formWithData.save()
										###user = formWithData.save(commit=False) #utworzenie bez zapisania 
										###user.username = user.username.lower()  #modyfikacja danych
										###user.save()							  #zapis w bazie
										###login(request, user)  				  #logowanie po rejestracji 
										username = formWithData.cleaned_data.get('username')
										messages.success(request, f'Account created for {username}!')
										return redirect('login')
									else:
										return render(request,'users/register.html', {'form':formWithData})
								else:
									formWithoutData = UserRegisterForm()
									return render(request, 'users/register.html', {'form':formWithoutData})
									
			3*W TEMPLATESACH W PLIKU REGISTER.HTML 
			 *Zmieniasz formę renderowania i przedstawienia błędów przy walidacji danych w formularzu z 
			  form.as_p na form|crispy:
				*instalujesz django-crispy-forms w konsoli poprzez:
							pipenv install django-crispy-forms	  LUB    pip install django-crispy-forms
				*dodajesz w głównej app/funkcjonalności w sekcji INSTALLED_APPS informacje o nowej 
				 crispy_forms (nie wiem czy to jest nowa app/funkcjonalność ale trzeba to tam umieścić)
							INSTALLED_APPS = [
								...
								'crispy_forms',
							]
			     oraz dodajesz w tym samym pliku zmienną CRISPY_TEMPLATE_PACK = 'bootstrap4'
							CRISPY_TEMPLATE_PACK = 'bootstrap4'
				*w pliku html (register.html) odwołujesz się do szablonu html, ładujesz tagi związane z 
				 cripsy_forms. Umieszczasz w sekcji block kod który będzie podmieniony w szablonie w danym
				 blocku. W zmiennej form dodajesz renderowanie (czyli modyfikacje przy wyświetleniu) na 
				 form|crispy zamiast form.as_p:
							{% extends "blog/base.html" %}
							{% load crispy_forms_tags %}
							{% block content %}
								<div class="content-section">
									<form method ='POST'>
										{% csrf_token %}
											{{ form|crispy }}
										<div class="form-group">
											<button type="submit">Sign Up</button>
										</div>
									</form
								</div>
							{% endblock content %}									
				*możesz rozszerzyć plik register.html o wystylizowanie stylów poprzez bootstrapa
					**w pliku register.html:
							{% extends "blog/base.html" %}
							{% load crispy_forms_tags %}
							{% block content %}
								<div class="content-section">
									<form method ='POST'>
										{% csrf_token %}
										<fieldset class="form-group">
											<legend class ="border-bottom mb-4">Join Today</legend>
												{{ form|crispy }}
										</fieldset>
										<div class="form-group">
											<button class="btn btn-outline-info" type="submit">Sign Up</button>
										</div>
									</form>
									<div class="border-top pt-3">
										<small class="text-muted">
											Already Have An Account? <a class="ml-2" href=#>Sign In</a>
										</small>
									</div>
								</div>
							{% endblock content %}
					**w szablonie base.html w app/funkcjonalności blog, w sekcji head ładujesz Bootstrapa:
							<head>
								<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
								<link rel="stylesheet" type="text/css" href="{% static 'blog/main.css' %}">								
	----------------------------------
	----------------------------------
	2)STRONY DO LOGOWANIA, DO LOGOUTu:
	----------------------------------
	  *)Gdy się logujesz to jest tworzona sesja czyli plik ciasteczek który zawiera session_id pozwalające 
	    przy przechodzeniu na inne podstrony zachować iformacje o byciu zalogowanym. 
	  *)Chcąc zamiast username'a logować się poprzez email korzystając z opcji 3 i 4 (AuthenticationForm 
	    oraz LoginView) musisz wcześniej przesłonić Usera klasą AbstractUser i tam ustawić zmienne 
		USERNAME_FIELD = 'email' ;; REQUIRED_FIELDS = []. (patrz więcej: https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#django.contrib.auth.models.CustomUser)
	  ----------------
	  **LOGIN OPCJA 1 - include("django.contrib.auth.urls") --> login/ i logout/
	  ----------------
		****https://www.techwithtim.net/tutorials/django/login-logout/
		**zawierasz ścieżkę do pliku urls.py do wbudowanej biblioteki django.contrib.auth której funkcje
		  zawierają logikę działania i nie trzeba ich implementować tylko wystarczy je wywołać w linku  
		1.MODULE URLS.PY w głównej app/funkc. 
					path('', include("django.contrib.auth.urls")),
			*dzięki zainkludowaniu: django.contrib.auth.urls pojawią ci się ścieżki takie jak:
					login/ [name='login']
					logout/ [name='logout']
					password_change/ [name='password_change']
					password_change/done/ [name='password_change_done']
					password_reset/ [name='password_reset']
					password_reset/done/ [name='password_reset_done']
					reset/<uidb64>/<token>/ [name='password_reset_confirm']
					reset/done/ [name='password_reset_complete']
			*po wybraniu jednej z tych ścieżek zostanie uruchomiona jedna z funkcji w pliku views.py 
			 wbudowanej biblioteki django.contrib.auth
		2.FOLDER TEMPLATES
			*logika w pliku views.py w django.contrib.auth jest tak zbudowane że przekierowuję do pliku 
			 login.html (musi być tak nazwany). Plik ten musi znajdować się w folderze registration (musi być 
			 tak nazwany i musi znajdować się we folderze templates (templates w jakiejkolwiek app/funkc.))
					folder templates -> folder registration -> login.html
			*plik login.html zbudowany jest jak standardowy formularz:
					{% extends "site1/base.html" %}
					{% load crispy_forms_tags %}
					{% block content %}
						<form method="post" class="from-group">
							{% csrf_token %}
							{{form|crispy}}
							<p>Don't have an accoount? Create one <a href="/register/">here</a></p>
							<button type="submit" class="btn btn-success">Login</button>	
						</form>
					{% endblock %}
			*OGRANICZENIA DOSTĘPU:
				*OPCJA 1:
					*w base.html robisz ograniczenie dostępu - jeżeli użytkownik nie zalogowany to 
					 zamiast blocków  wyświetla się tylko opcja logowania:
								{%if user.is_authenticated %}
									{% block content %}{% endblock %}
								{% else %}
									{% block content-login %}{% endblock %}
								{% endif %}
					*a w każdym innym pliku html tworzysz dod. blok (widoczny dla User'ów niezalogowanych):
								{% block content-login %}
									<a href="{%url 'login'%}">LOGIN HERE</a>
								{% endblock %}
				*OPCJA 2:
					*w funkcjach we views.py wykorzystujesz obiekt request i sprawdzasz czy jest zalogowany:
								if request.user.is_authenticated:
									...
		3.SETTINGS.PY w głównej APP/FUNKC:
			*tworzysz 2 zmienne któe wskazują na jaką stronę ma być przekierowanie po loginie lub logout'cie:
					LOGIN_REDIRECT_URL='/'
					LOGOUT_REDIRECT_URL='/'
	  ----------------
      **LOGIN OPCJA 2 - from django.contrib.auth import authenticate, login, logout
	  ----------------
		**Utworzenie formularza w HTMLu i obsłużenie jego logiki we views przez function-based-views 
		1*URLS.PY - zwyczajne wywołanie funkcji z views.py:
				    path('login/', views.loginUser, name='login'),
					path('logout/', views.logoutUser, name='logout'),
		2*VIEWS.py - użycie funkcji authenticate, login, logout z paczki django.contrib.auth do logowania
		  i logout'u wraz z flash messages związanymi z komunikatami
					from django.contrib import messages
					from django.contrib.auth.models import User
					from django.contrib.auth import authenticate, login, logout
					def loginUser(request):
						if request.user.is_authenticated:
							return redirect('home')
						if request.method=="POST":
							username = request.POST.get('username')
							password = request.POST.get('password')
							try:
								user = User.objects.get(username=username)
							except:
								messages.error(request, 'User does not exist')
							else:
								user = authenticate(request, username=username, password = password)
								if user is not None:
									login(request, user)
									return redirect('home')
								else:
									messages.error(request, 'username or password does not exist')
						context={}                              #if request.method=="POST":
						return render(request, 'base/login_register.html', context)
					def logoutUser(request):
						logout(request)
						return redirect('home')
		3*TEMPLATES - zbudowanie formularza całkowice w HTML'u bez zmiennej 'form' przesyłanej z views.py:
			a)strona html przeznaczona do logowania
					<form method='POST' action="">
						{% csrf_token %}
						<input type="text" name ="username" placeholder="Enter Username" />
						<input type="password" name ="password" placeholder="Enter Password" />
						<input type="submit" value="login"/>
					</form>
			b)strona wyświetlająca linki do logowania i logout'u"
					{% if not request.user.is_authenticated %}
						<a href="{%url 'login' %}">LOGIN</a>
					{% else %}
						<a href="{%url 'logout' %}">LOGOUT</a>   
					{% endif %}
	  ----------------
	  **LOGIN OPCJA 3 - AuthenticationForm + from django.contrib.auth import login, logout
	  ----------------
		**wykorzystanie AuthenticationForm oraz login(), logout z django.contrib.auth:
		1*URLS.PY - zto samo co powyżej:
				    path('login/', views.loginUser, name='login'),
					path('logout/', views.logoutUser, name='logout'),
		2*VIEWS.py - zmiast funkcji authenticate użycie AuthenticationForm 
					from django.contrib.auth import login, logout
					from django.contrib.auth.forms import AuthenticationForm
					def login_view(request):
						form= AuthenticationForm(request)
						if request.method == "POST":
							form = AuthenticationForm(request, data = request.POST)
							if form.is_valid():
								user =form.get_user()
								login(request, user)
								return redirect('home')
						return render(request, "accounts/login", {})
		3*TEMPLATES - zbudowanie formularza w oparciu o zmienną 'form' przesłaną z views.py:
			a)strona html przeznaczona do logowania
					<form method='POST' action="">
						{% csrf_token %}
						{{ form }}
						<input type="submit" value="login"/>
					</form>
			b)strona wyświetlająca linki do logowania i logout'u"
					{% if not request.user.is_authenticated %}
						<a href="{%url 'login' %}">LOGIN</a>
					{% else %}
						<a href="{%url 'logout' %}">LOGOUT</a>   
					{% endif %}			
	  ----------------
	  **LOGIN OPCJA 4 - LoginView + Logoutview
	  ----------------
		**wykorzystanie class-based-views LoginView i Logoutview
		1.MODULE URLS.PY (w app/funckjonalności users - wykorzystujesz wcześniej utworzoną app/funkc.)
			*pobierasz module views z django.contrib.auth by móc wywołac z niego 'class-based views'
			 (LoginView dla login oraz LogoutView dla logout).
			*LoginView dodajesz do ścieżki 'login/' oraz LogoutView dodajesz do ścieżki 'logout/'. Ponieważ
			 ścieżki te nie będą miały podścieżek to na tych 'class-based views' wywołujesz metodę as_view()
			 i podajesz w niej parametetr template_name do którego przypisujesz ścieżki do plików html w
			 templates'ach w naszej app/funckjonalności users:
				#plik urls.py w głównej app/funckjonalności
				from django.urls import path
				from django.contrib.auth import views as auth_views
				urlpatterns = [							
					...									
					path( 'login/', auth_views.LoginView.as_view(template_name='users/login.html'), 
																 name='login'),
					path('logout/',auth_views.LogoutView.as_view(template_name='users/logout.html'),
																 name='logout'),
				]
				
		2*W SETTINGS.PY W GŁÓWNEJ APP/FUNCKJONALNOŚCI (zamiast views.py):
			*ponieważ cała logika działania aplikacji jest zawarta w 'class-based views' w pliku URLS.PY w 
			 głównej app/funkcjonalności to jedyne co zostaje to przekierowanie na inną stronę po poprawnym 
			 zalogowaniu. (standardowo DJANGO będzie przekierowac na http://127.0.0.1:8000/accounts/profile/)
			 By to zmienić musisz w pliku settings.py w głównej app/funckjonalności wpisać zmienną 
			 LOGIN_REDIRECT_URL i przypisując do niej interesującą cię stronę:
						#w settings.py w głównej app/funckjonalności
						LOGIN_REDIRECT_URL = 'blog-home' 	
						
		3*W TEMPLATES'ACH 
			a)W APP/FUNCKJONALNOŚCI USERS - login.html oraz logout.html :
			 **login.html:
				*tak samo jak register.html opierasz się na szablonie z app/funckjonalności blog,i zmieniasz
 				 tylko block content w którym musisz zawrzeć: tag form (z parametrem method='POST'),
				 koniecznie konstrukcje {% csrf_token %}, zmienną {{form}} oraz button submit:
						#minimalna wersja:
						{% extends "blog/base.html" %}
						{% block content %}
							<form method='POST'>
								{% csrf_token %}
								{{ form }}
								<button type="submit">Login</button> 
							</form>
						{% endblock content %}		
				*możesz dołożyć do tego renderowanie css'owe przez bootstrapa oraz renderowanie formularza 
				 przez crispy_forms (co omówiłeś w FORMULARZU REJESTRACYJNYM w pkt2 w OPCJI ROZSZERZONEJ):
						{% extends "blog/base.html" %}
						{% load crispy_forms_tags %}
						{% block content %}
							<div class="content-section">
								<form method ='POST'>
									{% csrf_token %}
									<fieldset class="form-group">
										<legend class ="border-bottom mb-4">Log In</legend>
											{{ form|crispy }}
									</fieldset>
									<div class="form-group">
										<button class="btn btn-outline-info" type="submit">Login</button>
									</div>
								</form>
							</div>            
						{% endblock content %}
			 **logout.html:
				*strona do logowania służy tylko temu żeby poinformować użytkownika że został wylogowany
				 (cała logika i tak dzieje się w module urls.py poprzez 'class-based views' LogoutView:
						{% extends "blog/base.html" %}
						{% block content %}
							<h2>You have been logged out</h2>
						{% endblock content %}
			b)W BASE.HTML (czyli szablonie) W GŁÓWNEJ APP/FUNKCJONALNOŚCI zmieniasz linki w zależności od
			  tego czy użytkownik jest zalogowany czy nie - używasz do tego pola is_authenticated na 
			  obiekcie user który jest wbudowany w django w paczce django.contrib:
						#jeżeli zalogowany -> nazwa profilu z linkiem do 'profile/' oraz link do 'logout/'
						#jeżeli niezalogowany -> link do podstrony 'register/' oraz 'logout/'
						{% if user.is_authenticated %}
							<a class="nav-item nav-link" href="{% url 'profile' %}">{{ user.username}}</a>
							<a class="nav-item nav-link" href="{% url 'logout' %}">Logout</a>
						{% else %}
							<a class="nav-item nav-link" href="{% url 'login' %}">Login</a>
							<a class="nav-item nav-link" href="{% url 'register' %}">Register</a>
						{% endif %}	
	-----------------
	-----------------
	3)STRONA PROFILU:
	-----------------
	  -----------------
	  **PROFILE OPCJA 1 - PRZESŁONIĘCIE KLASĄ AbstractBaseUser (kiedyś AbstractUser):
	  -----------------
		000*PODSTAWY - CUSTOMIZING USER MODEL czyli DZIEDZICZENIE PO AbstarctBaseUser:
			**cały przykład:
				https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#specifying-a-custom-user-model
			**tłumaczenie dziedziczenia po AbstarctBaseUser
				https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#a-full-example
			**tłumaczenie implementacji dziedziczenia po BaseUserManager (by móc tworzyć superuser'ów):
				https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#writing-a-manager-for-a-custom-user-model
		1*W MODELS:
			*klasa usera ('Account') dziedzicząca po AbstractBaseUser oraz po 'PermissionsMixin' albo 
			 po samej AbstractBaseUser z przesłonięciem metod 'has_perm()' i 'has_module_perms()'
			*utworzenie zmiennych:
				**objects = MyAccountManager() - przypisanie do pola 'objects' instancji klasy 
						dziedziczącej po BaseUserManager (musi znajdować się przed klasą modelu by móc 
						przypisać do pola objects jej instancje)
				**USERNAME_FIELD = 'email' (odpowiada za możliwośc logowania się  poprzez email zamiast 
						przez podanie username); 
				**REQUIRED_FIELDS = [] (wskazuję wymagane pola do wpisania przy rejestracji przy 
						tworzeniu obiektu. Są to pola wymagane przy metodach create_user i 
						create_superuser w klasie dziedziczącej po 'BaseUserManager' (są wymagane w 
						argumentach tych funkcji)
			*podanie pól: is_active, is_staff, is_admin, is_superuser:
			  ***is_active - wymagane pole ale nic nie dające - nie da się zalogować do panelu
			  ***is_staff - wymagane pole, da się zalogowac do panelu ale nie można do niego zajrzeć
						(przy tym 'active' musi być True)
			  ***is_admin - wymagane pole, da się zalogować do panelu i da się zajrzeć do niego do 
						środka (przy tym 'active' i 'staff' muszą być True)
			  ***is_superuser - niewymagane - daje wszystkie uprawnienia (przy tym 'active', 
						'staff' i 'admin' muszą być True)
			*utworzenie klasy dziedziczącej po BaseUserManager i przesłonięcie w niej metod 'create_user()' 
			 i 'create_superuser()' w której ustawiasz hasło i konfigurujesz pola administracyjne. Klasa 
			 dziedzicząca po BaseUserManager musi znajdować się nad klasą dziedziczącą po AbstractBaseUser.
			*do argumentów funkcji 'create_user' i 'create_superuser()' -> oprócz pola przypisanego do 
			 zmiennej USERNAME_FIELD (email) ORAZ hasła(password) MUSISZ PRZYPISAĆ pola przypisane do 
			 listy REQUIRED_FIELDS -> chodzi o pola wymagane z klasy dziedziczącej po AbstractBaseUser: 
								#KLASA KONFIGURACYJNA:
								from django.db import models
								from django.contrib.auth.models import (BaseUserManager, 
																		AbstractBaseUser, 
																		PermissionsMixin)
								class MyAccountManager(BaseUserManager):
									def create_user(self, email, username, password=None): 
										if not email:
											raise ValueError('Users must have an email address')
										if not username:
											raise ValueError('Users must have username')
										user = self.model(email = self.normalize_email(email), 	
														  username = username,
														  #password = password,
														 )
										user.set_password(password)
										user.save(using=self._db)
										return user
									def create_superuser(self, email, username, password=None):
										user = self.create_user(email = self.normalize_email(email),
																password = password,
																username = username,
															   )
										user.is_admin = True
										user.is_staff = True
										user.is_superuser = True
										user.save(using=self._db)
										return user
								#KLASA MODELU
								class Account(AbstractBaseUser, PermissionsMixin):       
									email = models.EmailField(verbose_name='email', max_length=60, 
															unique=True)
									username = models.CharField(max_length=30, unique = True)
									avatar =  models.ImageField(null=True, blank=True, 
															default='331050936_s.jpg')
									date_joined=models.DateTimeField(verbose_name='date joined',
															auto_now_add=True)
									last_login = models.DateTimeField(verbose_name='last_login', 
															auto_now=True)
									is_active = models.BooleanField(default=True)   	#wymagane pole 
									is_staff = models.BooleanField(default=False)  		#wymagane pole
									is_admin = models.BooleanField(default=False)   	#wymagane pole 
									is_superuser = models.BooleanField(default=False)   #niewymagane 
									def __str__(self):
										return self.email
									objects = MyAccountManager()        
									USERNAME_FIELD='email'
									REQUIRED_FIELDS=['username',]
									# PONIŻSZE FUNKCJE GDY NIE DZIEDZICZY PO PermissionsMixin:
									# def has_perm(self, perm, obj=None):   	#has permission to make 
									#     return self.is_admin              	#changes in databases?
									# def has_module_perms(self, app_label):  	#has module permission?
									#     return True						
		2*w ADMIN.PY w twojej app/funkc. 
			*musisz zaimplementować klasę dziedziczącą po UserAdmin -> bez tego nie bedziesz mógł się
			 zalogować. Klasa dziedzicząca po UserAdmin musi mieć pola:
			  **fields = ('email'... - domyślnie nie wyświetli się email przy tworzeniu usera dlatego 
				trzeba go wskazać
			  **list_display - gdzie wskazujesz wyświetlane pola dla listy
			  **dodatkowe pola: 
					fieldsets = () 
					filter_horizontal = () 
					list_filter = ()
			*musisz zarejestrować swój model ('Account') oraz swój model konfiguracyjny 'MyUserAdmin'
								from django.contrib import admin
								from . models import Account
								from django.contrib.auth.admin import UserAdmin
								class AccountAdmin(UserAdmin):
									fields = ('email', 'username','avatar', 'password', 
											  'is_admin', 'is_staff', 'is_superuser')
									list_display = ('email', 'username', 'date_joined', 
													'is_admin', 'is_staff','is_superuser')
									#readonly_fields = ('id', 'date_joined')
									#searh_fields = ('email','username')
									fieldsets = ()         
									filter_horizontal = ()
									list_filter = ()
								admin.site.register(Account, AccountAdmin)
		3*w SETTINGS.PY w głównej app/funkc.
			*wskazujesz na na klasę po któej będziesz się logować wg klucza 'my_app.my_class':
								AUTH_USER_MODEL = 'account.Account'
			*dla 'avatar' będącym uploadowanym zdjęciem instalujesz bibliotekę PILLOW: pipenv install 
			 PILLOW by móc zrobic migrację i działac na zdjęciach (trzeba zainstalować ponieważ nie jest 
			 ona w  standardowych bibliotekach).(patrz: 6.ELEMENTY ROZSZERZONE -> 2)Zdjęcia uplodowane)
								pipenv install pillow
			*dla pola 'avatar' będącym uploadowanym zdjęciem stworzenie katalogu bazowego dla 
			 wszystkich zapisywanych zdjęć ze wszystkich klas zawierających pola ImageField:
				*w settings.py
								MEDIA_ROOT= os.path.join(BASE_DIR,'media') #ścieżka do pliku dla 
																		   #zuplodowanych img
								MEDIA_URL='/my_media/'				   	   #publiczna reprezentacja 
																	       #ścieżki MEDIA ROOT
				*w urls.py w głównej app/funkc - by zdjęcia wyświetlały się w instrukcjach konsolowych
					from django.conf import settings										 !!!!!!!!!
								from django.conf.urls.static import static
								if settings.DEBUG:
									urlpatterns += static(settings.MEDIA_URL, 
														  document_root=settings.MEDIA_ROOT)
		4*we VIEWS w formularzu dla żądania POST dodajesz 'request.FILES' a w templatesach w tagu 'form' 
		  atrybut: enctype="multipart/form-data" (patrz: 6.ELEMENTY ROZSZERZONE -> 2)Zdjęcia uplodowane)
	  -----------------
 	  **PROFILE OPCJA 2 - stworzenia klasy profile relacją jeden do jeden (czyli OneToOneField) z klasą User:
	  -----------------
		000*PODSTAWY:
			**https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#extending-the-existing-user-model
			**zamiast klasy relacji OneToOneField z klasą User z django.contrib.auth.models możesz stworzyć
			  najpierw klasę dziedziczącą po AbstractBaseUser (z OPCJI 1) i to z nią zrobić relację 1 do 1
			  W klasie dziedziczącej po AbstractUser umieścisz wszystkie pola wymagane (niezbędne) do 
			  utworzenia użytkownika (np: email, telefon) a w klasie Profile ręsztę pól np 'avatar'
		0* W MODELS.PY 
		   A* KLASA PROFILE - model/klasa Profile dziedzicząca z models.Model (django.db.models) z polami:
			   1**pole user typu OneToOneField połączonych relacją 1 do 1 z klasą User --> patrz PODSTAWY 
																	-> 5.ELEMENTY PODSTAWOWE -> *1*MODELS
			   2**pole ImageField() --> patrz: PODSTAWY -> 6.ELEMENTY ROZSZERZONE -> 2)UPLOADOWANE ZDJĘCIA
			      (pobranie biblioteki PILLOW oraz  (MEDIA_ROOT, MEDIA_URL + zmiany w URLS.PY)
			   3**funkcja __str__() zwracjącą nazwę profilu/użytkownika zamiast adresu referencji:
								from django.db import models
								from django.contrib.auth.models import User
								class Profile(models.Model):
									user=models.OneToOneField(User, on_delete=models.CASCADE)
									image=models.ImageField(default='defualt.jpg', upload_to='profile_pics')
									def __str__(self):
										return f'{self.user.username} Profile'					  
		   B* MIGRACJA do DB oraz ZAREJESTROWANIE TABELI PROFILE W ADMIN.PY:
				*By móc zrobic migrację dla modelu z polem ImageField minstalujesz pakiet PILLOW 
				 W konsoli najpierw instalacja pillow:
								pipenv install pillow
				 A następnie zrobienie migracji:
								python manage.py makemigrations
								python manage.py migrate
				*W ADMIN.PY zarejestruj tabelę Profile żeby mieć do niej dostęp w panelu administracyjnym.
								from .models import Profile 		#'.' oznacza że z tego samego katalogu
								admin.site.register(Profile)
		   C* RESIZING ZDJĘCIA poprzez PRZESLONIĘCIE METODY SAVE w MODELS.PY --> patrz: PODSTAWY ->
									6.ELEMENTY ROZSZERZONE -> 2) UPLOADOWANE ZDJĘCIA -> C) RESIZING ZDJĘĆ
											
		1* SIGNALS.PY oraz APPS.PY:
			*W SIGNALS (więcej patrz 5.MODUŁY ROZSZERZONE --> 1.SIGNALS):
				*gdy User zostanie utworzony/zapisany (post_save) zostanie wysłany sygnał od Usera 
				 (sender=User) do app/funkc 'users' zawierającą klasy Profile w models.py. Sygnal
				 zostanie otrzymany przez funkcje mające dekorator @receiver. 
				*Pierwsza z nich stworzy obiekt Profile dzięki metodzie create() a druga zapisze go w 
				 tabeli dzięki metodzie save():
								from django.contrib.auth.models import User
								from . models import Profile
								from django.db.models.signals import post_save 
								from django.dispatch import receiver
								@receiver(post_save, sender=User)
								def create_profile(sender, instance, created, **kwargs):
									if created:
										Profile.objects.create(user=instance)
								@receiver(post_save, sender=User)
								def save_profile(sender, instance, **kwargs):
									instance.profile.save()
			*W APPS.py - żeby sygnały mogły działać importujez plik signals z app/funkc. 'users':
								class UsersConfig(AppConfig): 
									name = 'users'
									def ready(self):
										import users.signals
		2* W URLS.PY:
			A) przekierowania na stronę 'profile' w urlpatterns:
						from users import views as user_views
						urlpatterns = [
							...
							path('profile/', user_views.profile, name = 'profile'),
						]
			B) ze względu na to że stworzyłeś zmienne MEDIA_ROOT oraz MEDIA_URL musisz jeszcze dołożyć w 
			   pliku urls.py w głównej app/funkcjonalnośći linie kodu odpowiadające za wyświetlenie tychże
			   plików/zdjęć poprzez instrukcje konsolowe w pliku views.py np: user.profile.image.url, lub 
			   bezpośrednie wpisanie ścieżki w wyszukiwarkę: 127.0.0.1:8000/media/profile_pics/nazwa.jpg 			   
						#w wersji dla developmentu a nie dla deploymentu
						#w pliku urls.py w głównej app/funkcjonalności
						from django.conf import settings
						from django.conf.urls.static import static
						...
						if settings.DEBUG:
							urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
		3* W SETTINGS w głównej app/funkc. zmienne:
				*MEDIA_ROOT i MEDIA_URL w celu stworzenia folderu pośredniego dla folderów przechowujących 
				 zuploadowane pliki:
						*ścieżka do pliku dla zuplodowanych img:
								MEDIA_ROOT= os.path.join(BASE_DIR,'media') 
						*publiczna reprezentacja ścieżki MEDIA ROOT
								MEDIA_URL='/my_media/'	
				*LOGIN_URL w celu wskazania przekierowanie na domyślną stronę dla funkcji 'RESTRICTED 
				 ROUTE' czyli udekorowanej dekoratorem @login_requireed (patrz--> 6.ELEMENTY ROZSZERZONE 
				 --> 3.RESTRICTED ROUTE)
		4* WE FORMS.PY APP/FUNCKJONALNOŚCI USERS (forms.py który jest przedłużeniem pliku VIEWS.PY):
		   *Na początku musisz zaimportować modele User i Profile by móc dodawac formularze na ich bazie
		   *Tworzysz formularze UserUpdateForm oraz ProfileUpdateForm które dziedziczą po klasie ModelForm
		    z pakietu models (from django import forms) - klasa specjalnie przystosowana do pracy z
			formularzami powiązanymi z konkretnym typem danych. 
		   *Specjalnie tworzysz UserUpdateForm zamiast tylko ProfileUpdateForm gdzyż interesujące cię pola
		    (czyli: username, email) znajdujące się w modelu User i chociaż model Profile poprzez pole typu
			OneToOneField(User) jest ścieśle z Userem połączony relacją 1:1 to nie dziedziczy po nim więc
			nie można się wskazać tychże pól w liści fields.
		   *wewnątrz formularzy najważniejsze to zdeifiniowanie klasy wewnętrznej 'Meta' gdzie deklarujesz 
		    nazwę modelu na bazie której będzie formularz np: model=User oraz deklarujesz pola w liście 
			fields które interesują cię w formularzu
		   *ponadto mógłbyś stworzyć pola o tej samej nazwie co w liście fields w klasie Meta. Pola te mając
		    tę samą nazwę co w liście fields w klasie Meta zostałyby przedstawione w formularzu w jednym 
			miejscu. W polu utworzonym poza klasą Meta mógłbyś dać parametr ograniczający jakoś to pole np:
			#username = forms.CharField(max_length=10) albo #email=forms.EmailField(). Bez ograniczających 
			parametrów nie ma sensu tworzenie takich pól:
						from django.contrib.auth.models import User
						from .models import Profile
						from django import forms
						class UserUpdateForm(forms.ModelForm):
							#username = forms.CharField(max_length=1)	#nie musisz tego podawać ani email
							#email=forms.EmailField(max_width=10 )		#chyba że chcesz jakoś ograniczyć 
																	    #np dla pola email: 
							class Meta:
								model=User
								fields = ['username', 'email']
						class ProfileUpdateForm(forms.ModelForm):
							class Meta:
								model = Profile
								fields=['image']
								
		5* WE VIEWS.PY app/funkc. USERS:
		   a)RESTRICTED ROUTE dla 'profile/' (WIĘCEJ patrz 6.ELEMENTY ROZSZERZONE --> 3.RESTRICTED ROUTE)
						from django.contrib.auth.decorators import login_required
						@login_required
						def profile(request):
							return render(request, 'users/profile.html')
			   
		   b)FORMULARZE z FORM.PY użyte WE VIEWS.PY:
				*formularze dziedzczące po forms.ModelForm 
				*by w polach formularza mogły zostać wyświetlone dane z pól modelu/klasy trzeba podać jako
				 parametr instancje obiektu: 'instance=request.instancja'
						u_form=UserUpdateForm(instance=request.user)
						p_form=ProfileUpdateForm(instance=request.user.profile)
				*w formularzach podczas submitowania formularza dochodzi do post requesta z powrotem do tej
 				 samej ścieżki wraz z danymi wprowadzonymi w formularz. By móc przekazać te dane wprowadzone
				 w formularz (niezależnie od tego czy dane te będą poprawnie wprowadzone czy niepoprawnie)
				 trzeba dla treści podać parametr 'request.POST' a dla plików/zdjęć 'request.FILES'
						u_form=UserUpdateForm(request.POST, instance=request.user)
						p_form=ProfileUpdateForm(request.POST, request.FILES ,instance=request.user.profile)
				*Po przekazaniu danych wprowadzonych do formularza trzeba:
				  *móc określić czy dane te są poprawnie wprowadzone czy nie, walidacja poprzez is_valid(). 
				  *jeżeli są poprawnie zapisane to trzeba te dane zapisać w tabeli - metoda save(). 
				  *na koniec możesz przekierować na inną strone (redirect()) oraz na przekierowanej stronie
				   pokazać wiadomość - messages.success(request, 'text')
						@login_required
						def profile(request):
							if request.method == 'POST':
								u_form=UserUpdateForm(request.POST, instance=request.user)
								p_form=ProfileUpdateForm(request.POST, request.FILES,
														 instance=request.user.profile)
								if u_form.is_valid() and p_form.is_valid():
									u_form.save()
									p_form.save()
									messages.success(request, f'Your account has been updated')
									return redirect('profile')	#specjalnie używasz redirect a nie render
																#ze względu na: post-get-redirect pattern
							else:
								u_form=UserUpdateForm(instance=request.user)
								p_form=ProfileUpdateForm(instance=request.user.profile)
							context={
								'u_form': u_form,
								'p_form': p_form 
							}
							return render(request, 'users/profile.html', context)
							
		6* W TEMPLATES'ACH W APP/FUNKCJONALNOŚCI USERS:
		   a) Tworzysz stronę profile.html gdzie zawierasz:
				  *nazwę użytkownika: 'user.username' - parametr user jest automatycznie przesyłany (jeżeli
				   istnieje) (nie trzeba go wysyłąc przez słownik w metodzie render)
				  *zdjęcie o ścieżce odwołującej się (dzięki polu OnoToOneField w klasie Profile w pliku 
				   models.py) do usera z wbudowanej w django bazy danych User: 'user.profile.image.url'
				  *formularz odpowiadający za edycję danych użytkownika (pola z modelu User)
				  *formularz odpowiadający za możliwość edycji zdjęcia profilowego (pola z modelu Profile)
			**KONIECZNIE PAMIĘTAJ O TYM BY dodać konstrukcje 
			      *{% csrf_token %} do poprawnego działania formularzy
				  *'enctype' w <form method ="POST" enctype="multipart/form-data"> by móc wysyłać zdjęcia 
				  *zainstalowanie modułu PILLOW (gdybyś nie miał zainstalowanego): pipenv install pillow
						{% extends "blog/base.html" %}
						{% block content %}
							<h1>{{ user.username }}</h1>
							<image src="{{ user.profile.image.url }}"></image>
										<!--FORM-->
							<form method ="POST" enctype="multipart/form-data">
								{% csrf_token %}
								{{ u_form }}
								{{ p_form }}
								<button class="btn btn-outline-info" type="submit">Update</button>
							</form>
						{% endblock content %}
		   b) Możesz rozszerzyć to o renderowanie w CSSie przez bootstrapa oraz renderowanie formularzy
			  poprzez cripsy_forms:
						{% extends "blog/base.html" %}
						{% load crispy_forms_tags %}
						{% block content %}
						<div class="content-section">
							<div class="media">
							    <img class="rounded-circle account-img" src="{{ user.profile.image.url }}">
							    <div class="media-body">
									<h2 class="account-heading">{{ user.username }}</h2>
									<p class="text-secondary">{{ user.email }}</p>
								</div>
							</div>
							<!--FORM-->
							<form method ="POST" enctype="multipart/form-data">
							    {% csrf_token %}
							    <fieldset class="form-group">
									<legend class ="border-bottom mb-4">Profile_Info</legend>
									{{ u_form|crispy }}
									{{ p_form|crispy }}
								</fieldset>   
								<div class="form-group">
								    <button class="btn btn-outline-info" type="submit">Update</button>
								</div>
						  </form>
						  </div>
						{% endblock content %}	
						
	4)STRONY DO TWORZENIA POSTÓW:
	-----------------------------
	
	
============================================================================================================
====================================================PODSTAWY================================================
============================================================================================================
6. ELEMENTY ROZSZERZONE:	
	----------
	0)DODATKI:
		*DJANGO USER MODEL:
			*https://docs.djangoproject.com/en/4.0/ref/contrib/auth/
				*OPCJA 1:
					from django.contrib.auth.models import User
					user = models.ForeignKey(User, on_delete = models.CASCADE)
				*OPCJA 2:
					from django.contrib.auth import get_user_model
					user = get_user_model()		
		*DJANGO TEMPLATING LANGUAGE:
			*metody wywołane na kluczach przekazywanego słownika do templatesów np as_p normalnie we 
			 views byłby wywoływane z nawiasami okrągłymi a w templatesach są wywoływane bez tych nawiasów
			 (pole request.user.is_authenticated się nie liczy)
					#we views.py:
					if request.user.is_authenticated:
						form = myForm().as_p()
					#w templatesach, w plikach HTML:
					{% if user.is_authenticated %}	
						{{form.as_p}}
			*chąc dostać się do obiektów klucza obcego to operujesz bez nawiasów tj:'_set.all()' 
					#we views.py
					if request.user.is_authenticated:
						t = request.user.todolist_set.all()
					#w templatesach, w plikach HTML:
					{% if user.is_authenticated %}	
						{% for item in user.todolist_set.all %}
							...
						{% endfor %}
		*WYSZUKIWARKA HTML request.GET:	
			*w TEMPLATES - wyszukiwarka utworzona przez formularz wysyła zapytanie na serwer typu 'GET' 
			 dołączając do linku zmienną wpisaną w atrybucie name ( 'q') wraz z wpisanym tekstem
					<form method="GET" action="{% url 'home' %}">
						<input type="text" name="q" placeholder="Search rooms..."/ >
						<input type="submit" value="search">
					</form>
				#po wciśnieciu ENTERa lub przycisku 'submit' zostanie wysyłany link:
					127.0.0.1:800/?q=wpisany+mojText
			*WE VIEWS.PY pobierasz wpisane dane przypisane do zmiennej atrybutu 'name' czyli 'q' i 
			 wykorzystujesz je w celu wyszukania danych o podanych parametrach z bazy danych:
					q= request.GET.get('q') if request.GET.get('q') != None else ''
					rooms = Room.objects.filter(topic__name__contains= q)
				#request.GET.get('q') NIE MOże BYĆ RÓWNE 'None' dlatego dodajesz linijki:
					request.GET.get('q') if request.GET.get('q')!=None else ''
		*OPEROWANIE CZASEM i DATAMI w DJANGO:
			*w django:
					from django.utils import timezone
					pub_date = timezone.now()
					current_year = timezone.now().year 
			*standardowe:
					import datetime
					datetime.datetime(2016,9,24,12,01,01)
			*operowanie czasem w django i standardowe:
					date = timezone.now()-datetime.timedelta(days=1)						
	------------------
	1) OBIEKT REQUEST:
		1*PODSTAWY:
			*w pierwszym arg. we funkcjach we views.py zamiast 'request' może być inna nazwa np 'response'
			*w funkcjach we views.py możemy srawdzić czy na serwer zostało wysłane zapytanie 'GET' / 'POST'
							if request.method =='POST':
									...
			*we views.py:
				*return HttpResponseRedirect(request.META.get('HTTP_REFERER', '/')) - POWRÓT na poprzednią 
				 stronę
				*if request.user.is_authenticated - sprawdzenie czy user jest zalogowany (we views.py)
			*W TEMPLATES:
				*{{request.META.HTTP_REFERER}} - POWRÓT na poprzednią stronę
							<a href="{{request.META.HTTP_REFERER}}">go back</a>	
				*{{request.user}} || {% if request.user.is_authenticated %} - zwraca zaogowanego user'a
				 lub pozwala sprawdzic czy user jest zalogowany 
		
		2*DLA FORMULARZY:
			*REQUEST.GET:
				*request.GET zwróci słownik zmiennych w linku
				*W TEMPLATES:
					***ustawiasz zmienną po znaku zapytania i po równa się wpisujesz zmienną która 
					   zostanie przekazana jako klucz do słonika GET:
							<a href="{% url 'home' %}?q={{topic.name}}">{{topic.name}}</a>
					***da to link:
							127.0.0.1:8000/home?q=jakisTekst
					***zwróci słownik:
							<QueryDict: {'q': ['jakisTekst']}>
				*WE VIEWS - można pobrac te klucze poprzez:
							request.GET.get('q')
					***request.GET.get('q') oraz request.POST.get('q') NIE MOGĄ BYĆ RÓWNE None:
							request.GET.get('q') if request.GET.get('q')!=None else ''
			*REQUEST.POST:
				*request.POST zwróci słownik z kluczami będącymi:														
					*wszystkimi tagami: input type='text' o nazwie klucza wpisaną w atrybut 'name' i 
					 wartością wpisaną w pole tego tagu.
					*wszystkimi tagami: button type='submit' o nazwie klucza wpisaną w atrybut 'name' i 
					 wartością wpisaną do atrybutu 'value' w tym tagu
					*wszystkimi tagami: input type='checkbox' (które będą zaznaczone) o nazwie kluczów
 					 wpisanych w atrybut 'name' i wartościami z atrybutu 'value': value= 'clicked'
					*polem 'csrf_token' z wartością w postacu klucza szyfrowanego do odszyfrowania 
				*POBRANIE DANYCH - można zrobić poprzez	atrybut 'name' i metody get() dla wartości
				 pojedyńczych i metody getlist() dla wartośi będącymi listami:	
							request.POST 						#zwróci cały słownik
							request.POST.get('attrName')		#zwróci wartość taga name o atrybucie 
																#"name='attrName'"
							request.POST.get('attrListName')	#zwróci listę będącą wartością w tagu 
																#o atrybucie "name='attrListName'"
				*PRZYKŁAD:
					*W TEMPLATES:
							<form action="" method="POST">
								<input type="text" name='title' />
								<input type="text" name='title2' value='my_title' />
								<input type="checkbox", name="wybor1", value='a' clicked />
								<input type="checkbox", name="wybor2", value='b' />
								<input type="checkbox", name="wybor2", value='c' />
								<div>
									<label for="room_participants">Participants</label>
									<select id="room_participants" name="participants" multiple>
										<option value="opt1">option1</option>
										<option value="opt2">option2</option>
										<option value="opt3">option3</option>
									</select>
								</div>
								<button type="submit", name="saveItem">saveClicked</button>
								<button type="submit", name="saveItem2">saveNotClicked</button>
							</form>
					*PO WYSŁANIU STWORZY SŁOWNIK (z klikniętą opcją 'wybor1' na stałe (clicked), z 
					 klikniętą przez użytkownika opcją 'wybor3' i wybranymi 'option2' i 'option3' dla 
					 'participants' oraz wduszonym przyciskiem 'saveClicked'):
							<QueryDict: {'csrfmiddlewaretoken': ['yXRRDKvKzskjdvdbvkjh70bRK...'], 
							'title': ['wpisana_value'], 'title2': ['my_title'], 
							'wybor1': ['a'], 'wybor3': ['c'], 'participants': ['opt1', 'opt2'],
							'saveItem': ['saveClicked'], 'saveItem2': ['']}>
					*WE VIEWS.PY:
							def download(request):
								title= request.POST.get('title')					#'wpisana value'
								title2= request.POST.get('title2')					#'my_title'
								wybor1 = request.POST.get('wybor1')					#'a'
								wybor2 = request.POST.get('wybor2')					#''
								wybor3 = request.POST.get('wybor3')					#'c'
								participants = request.POST.getlist('participants')	#['opt2', 'opt3']
	----------------------
	2)ZDJĘCIA UPLOADOWANE:
		A)PODSTAWY:
			*w bazie danych zamiast zdjęć są przechowywne wskaźniki do nich. (Zdjęcia są na dysku twardym)
			*jeżeli zuploadujesz zdjęcie o nazwie która już istnieje w bazie danych to nie zostanie ono 
			 nadpisane tylko DJANGO doda hasha do nazwy zdjęcia (dzięki czemu będzie unikatowe)
			*możliwość dostania się do różnych atrybutów image:
						Profile.objects.get(id=1).image.url
						Profile.objects.get(id=1).image.path
						Profile.objects.get(id=1).image.size
						Profile.objects.get(id=1).image.width
						Profile.objects.get(id=1).image.height
		 **W MODELS.PY 
			*tworzysz pole typu ImageField z polami:
				*default - czyli zdjęcie domyślne (gdy nie zostanie podane inne): default= 'default.png'
				*upload_to - parametr wskazujący nazwę folderu gdzie mają być przechowywane uploadowane 
				 zdjęcia: upload_to='profile_pics'. Django automatycznie w głównym katalogu (czyli tam 
				 gdzie są wszystkie foldery app/funkcjonalności stworzy folder o podanej nazwie):
						class Profile(models.Model):
							img=models.ImageField(default= 'default.png', upload_to='profile_pics')
							...
			*instalujesz w konsoli paczkę PILLOW potrzebną do działania na zdjęciach (pola ImageField)
			 oraz dokonujesz migracji żeby usankcjonować bazę danych:
						pip install PILLOW
						python manage.py makemigrations
						python manage.py migrate
		 **W SETTINGS.PY i URLS.PY w głównej APP/FUNKC. (WERSJA DLA DEVELOPMENTU NIE DLA DEPLOYMENTU):
			*Zuploadowane zdjecia będą przechowywane w folderze uploads/profile_pics/ i można się dostać 
			 do nich w pliku views.py poprzez instrukcje konsolowe np:
						user.profile.image.url 	
			 lub wpisując w wyszukiwarce:
						127.0.0.1:8000/profile_pics/nazwaZdjęcia.jpg'  
			*W przypadku gdybyś stworzył wiele pól typu ImageField to w głównym katalogu (czyli tam gdzie 
			 znajdują się wszystkie app/funkc.) Django stworzy ci tak dużo folderów na uploadowane pliki 
			 że będziesz mieć w głównym katalogu bałagan. Dlatego rozwiązaniem jest utworzenie jednego 
			 wspólnego katalogu plików zwanego np: 'uploads', ew. 'media'. Do tego musisz stworzyć: 
					   **MEDIA_ROOT - zmienna w settings.py. Tworzy i wskazuje folder gdzie będą 
					     przechowywane zuploadowane pliki (FULL PATH to directory where django store 
						 uploaded files). Pliki te będą przechowywane w zwykłym katalogu zamiast w bazie 
						 danych. Ścieżkę dla MEDIA_ROOT tworzysz poprzez zmienną BASE_DIR i nazwę folderu 
						 np: 'uploads' (BASE_DIR jest to domyślnia zmienna w settings.py):
									#pliku settings.py w głównej app/funckjonalności
									#BASE_DIR = Path(__file__).resolve().parent.parent #domyślna zmienna
									import os
									MEDIA_ROOT=os.path.join(BASE_DIR, 'uploads')
						 Bez przypisania ścieżki do zmiennej MEDIA_ROOT będzie ustawiona na BASE_DIR							 
					   **MEDIA_URL - zmienna w settings.py. Jest publiczną reprezentacją adresu zmiennej
						 MEDIA_ROOT. Jeżeli w wyszukiwarce wpiszesz wartość MEDIA_URL np: '/files/' to 
						 reprezentuje on całą zmienną MEDIA_ROOT ('uploads' dla '127.0.0.1:8000/files/')
									#pliku settings.py w głównej app/funckjonalności
									MEDIA_URL = '/files/'		
					   **w URLS.PY - żeby zdjecia/pliki mogły się wyświetlić (zarówno poprzez instrukcje 
					     konsolowe tj: user.profile.image.url jak i poprzez wpisanie w wyszukiwarke 
						 dokładnej ścieżki do zdjęcia):
									#w pliku urls.py w głównej app/funkcjonalności
									from django.conf.urls.static import static
									from django.conf import settings											
									if settings.DEBUG:
										urlpatterns += static(settings.MEDIA_URL, 
																		document_root=settings.MEDIA_ROOT)
			*Po stworzeniu zmiennych MEDIA_ROOT, MEDIA_URL oraz dodaniu 'static' w urls.py nadal będziesz 
			 mógł się dostać do zdjęć w pliku views.py poprzez instrukcje konsolowe - WE VIEWS.PY do 
			 ZDJECIA DOSTANIESZ SIĘ poprzez: 'image.url':
						user.profile.image.url 	
			 lub wpisując w wyszukiwarce (z uwzględnieniem folderu wskazanego w MEDIA_URL):
						127.0.0.1:8000/files/profile_pics/nazwaZdjęcia.jpg'			
		 **WE VIEWS.PY i w TEMPLATES'ach w PLIKU HTML - konfiguracja dla uploadu zdjęć:
			*we VIEWS.PY - przy wywoływaniu formularza dla żadania POST by móc przekazać pliki/zdjęcia do 
			 formularza oprócz 'request.POST' trzeba podać parametr 'request.FILES':
						@login_required
						def updateUser(request):
							form = UserForm(instance=request.user)
							if request.method == "POST":
								form = UserForm(request.POST, request.FILES, instance=request.user)
			*w TEMPLATES'ach w PLIKU HTML:
				*w formularzu (tag form) dodaJ enctype="multipart/form-data" by móc przy żadaniu 'POST' 
				 wysyłać zdjęcia ( <form method ="POST" enctype="multipart/form-data"> ):
				*zainstaluj moduł PILLOW (gdybyś nie miał zainstalowanego): pipenv install pillow
						<form class="form" action="" method="POST"  enctype="multipart/form-data">
							{% csrf_token %}
							{% for f in form %}
								<label for="profile_pic">{{f.label}}</label>
								{{f}}
							{% endfor %}
							<button type="submit">Update</button>
						</form>		
		B)RESIZING UPLOADOWANYCH ZDJĘĆ:
			*We Views.py - AUTOMATYCZNY RESIZING ZDJĘCIA PRZY UPLOAOWANIU przez przesłonięcie metody 
			 save(self, *args, **kwargs). Żeby móc to wykonać musisz zaimportować klase Image z biblioteki 
			 PILLOW, którą wczesniej zainstalowałeś. (Poniżej automatyczna ZMIANA na wymiar 300 na 300)
						from PIL import Image							#PILLOW ma skrót PIL
						class Profile(models.Model):
							...
							def save(self, *args, **kwargs):
								super().save( *args, **kwargs)			#przesłonięcie 
								img = Image.open(self.image.path)		#img jako zmienna do której
																		#przypisano obiekt Image (z 
																		#argumentem w postaci ścieżki:
																		#profile.image.path
								if img.height > 300 or img.width >300:	
									output_size= (300,300)
									img.thumbnail(output_size) 			#zmiana wielkości zdjęcia
									img.save(self.image.path)			#zapis nowego zdjęcia
	-------------------
	3)RESTRICTED ROUTE:
		*WŁASNORĘCZNE restricted route:
							#we views.py:
								def function(request):
									room=Room.objects.get(id=pk)
									if request.user.is_authenticated:
										return redirect('home')
									if request.user != room.host:
										return HttpResponse('You are not allowed here')
							#w htmlu:
								{% if request.user == r.host%}
									<a href="{% url 'update-room' r.id %}">Update Room</a>
									<a href="{% url 'delete-room' r.id %}">DELETE Room</a>
								{% endif %}
		*DEKORATOR @LOGIN_REQUIRED:
			*wykorzystuję plik ciasteczek 'session_id' przechowujący informację o tym czy użytkownik jest 
			 zalogowany. Jezeli pliku ciasteczek nie ma to użytkownik zostanie przeniesiony na inną 
			 podstronę podaną w arg. @login_required lub w zmiennej LOGIN_URL w settings.py:
						*OPCJA 1:
							#WE VIEWS.PY:
								from django.contrib.auth.decorators import login_required
								@login_required(login_url='/login/')
								def function(request):
									...
						*OPCJA 2:
							#W SETTINGS.PY:
								LOGIN_URL = 'login'  #podajesz zmienną do ścieżki lub ścieżkę'/login/'
							#WE VIEWS.PY:
								from django.contrib.auth.decorators import login_required
								@login_required
								def function(request):
									...
			*dekorator @login_required bez podania strony w argumencie na którą ma byc przekierowanie 
 			 oraz bez podania zmiennej LOGIN_URL w settings.py domyślnie przekierowuję na '/acounts/login/' 
			*Gdy użytkownik będzie niezalogowany a będzie chciał przejśc na 'RESTRICTED ROUTE' np:'profile'
			 to django automatycznie przeniesie na stronę logowania z dopiskiem w adresie strony 
			 '?next=/profile/' czyli kolejnej strony na którą będzie przekierowanie po zalogowaniu.
			*@login_required zadziała nie tylko dla linków na podstrony 'RESTRICTED ROUTE' ale także w 
			 przypadku wpisania ścieżki w pasek wyszukiwarki.
	-----------------
	4)FLASH MESSAGES:
		https://docs.djangoproject.com/en/4.0/ref/contrib/messages/#using-messages-in-views-and-templates
		*WE VIEWS.PY:
			*nie zwracasz w metodzie render()-> messages są przesyłane jako klucz w słowniku request.
			*RODZAJE MESSAGES: debug ; info ; success ; warning ; error
			*podstawowe utworzenie messages:
					from django.shortcuts import redirect, render
					from django.contrib import messages
					def say_hello(request):
						messages.add_message(request, messages.INFO, 'HELLO WORLD')
						messages.success(request, 'Text sended')
						return redirect('blog-home')
			*przekazanie danych do messages:
					def register(request):
						if request.method='POST':
							form=UserCreationForm(request.POST)
							if form.is_valid():
								form.save()
								username = form.cleaned_data.get('username')
								messages.success(request, f'Account created for {username}!')	
		*w TEMPLATES:
					{% if messages %}
					<ul class="messages">
						{% for message in messages %}
						<li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
						{% endfor %}
					</ul>
					{% endif %}

5. ROZSZERZONE MODUŁY i FOLDERY w APP/FUNCKJONALNOŚCIACH:
  *1*SIGNALS (kontynuacja MODELS) oraz APPS.PY w danej app/funkc:
		*W APPS.PY:
			*po stworzeniu pliku signals.py żeby sygnały mogły działać to w apps.py wewnątrz klasy o 
			 nazwie nazwaAppConfig dziedziczącej po AppConfig trzeba stworzyć funkcję ready() i wewnątrz 
			 jej zaimportować plik signals pochodzący z danej app/funkc (poniżej dla users)
							class UsersConfig(AppConfig): 
								name = 'users'
								def ready(self):
									import users.signals
		*W SIGNALS.PY:
		   A)PODSTAWY:
				*signals.py jest kontynuacją models.py (to co jest w w signals można zrobić w models)
				*w pliku signals.py potrzebujesz zaimportować modele/klasy użyte w sygnale:
							from .models import Profile
							from django.contrib.auth.models import User
				*sygnały: pre_save, post_save - uruchomią się przed i po wywołaniu save() z models.py
							from django.db.models.signals import pre_save, post_save 
				*musisz utworzyć funkcje powiązaną z sygnałem, która musi przyjmować dane argumenty:
					-sender - jako klasa wysyłająca sygnał
					-instance - jako instacja klasy podanej w senderze
					-created - (tylko dla post_save) sprawdza czy obiekt zostal stworzony czy nie 
					-**kwargs - jako jakieś pozostałe elementy 
							def create_profile_post_save(sender, instance, created, **kwargs):
								if created:
									Profile.objects.create(user=instance)
							def save_profile_post_save(sender, instance, **kwargs):
								instance.profile.save()
							
		   B)WYWOŁANIE FUNKCJI POWIĄZANEJ Z SYGNAŁEM:
				a)POPRZEZ wywołanie FUNKCJI SYGNAŁU (pre_save(), post_save(), post_delete()):
							from .models import Profile
							from django.contrib.auth.models import User
							from django.db.models.signals import pre_save, post_save 
							def create_profile_post_save(sender, instance, created, **kwargs):
								if created:
									Profile.objects.create(user=instance)
							def save_profile_post_save(sender, instance, **kwargs):
								instance.profile.save()
						#WYWOŁANIE SYGANŁU:
							post_save.connect(create_profile_post_save, sender=User)
							post_save.connect(save_profile_post_save, sender=User)
				b)POPRZEZ dekorator RECEIVER:
					*importujesz dekorator receiver 
							from django.dispatch import receiver
					*dekorujesz dekoratorem @receiver funkcję tworzącą inną klasę (@receiver przyjmuję 
					 w parametrze typ sygnału oraz sender'a -klasę wysyłającą sygnał)
							@receiver(post_save, sender=User)
							def ...
					*2 funkcje wewnątrz receivera - do tworzenia i do zapisywania. 
							from django.contrib.auth.models import User
							from . models import Profile
							from django.db.models.signals import post_save 
							from django.dispatch import receiver

							@receiver(post_save, sender=User)
							def create_profile_post_save(sender, instance, created, **kwargs):
								if created:
									Profile.objects.create(user=instance)

							@receiver(post_save, sender=User)
							def save_profile_post_save(sender, instance, **kwargs):
								instance.profile.save()		

  *2*FORMULARZE i FORMS.PY (rozszerzenie VIEWS.PY):
		0.DZIAŁANIE STANDARDOWYCH FORMULARZY W HTMLu (nie musisz czytać możesz przejść od razu do punktu 1):
			*GET - metoda/żądanie do pobierania informacji z serwera (domyślna dla form):
				*gdy w pliku html w tagu 'form' stworzysz 'input' typu 'text' (do wpisywania) oraz 'input' 
				 typu 'submit' (do wysyłania) to przy wysłaniu żadania, do linku zostanie dołączony atrybut
				 'name' w inputcie oraz wpisany tekst(ztego ssmego inputu). Dodając do tagu 'form' jeszcze
				 atrybut 'action' możemy stworzyć z tego wyszukiwarkę linków:
							#dla pliku basic_form.html:
							<form action='search/' method='GET'>
								<input type="text" name='title' placeholder='Your title' />   
								<input type='submit' value="Save" />
							</form>
				*wpisując w inputcie 'abc' da to link: http://127.0.0.1:8000/basic_form/search/?title=abc  
				*we views.py poprzez: 'print(request.GET)' możesz wyświetlić dane z formularza - zwróci 
				 QuerySet czyli słownik kluczy (atrybuty name w inputcie) i wartości (to co wpisywane)
				*po wysłaniu formularza atrybut 'action' przeniesie nas do linka 'search/' ktory w urls.py
				 wywoła funkcję we views.py - tam możesz odebrać dane z inuputu o name="title" za pomocą: 
				 request.GET.get('title') i wyświetlić je na wywołanej zrenderowanej stronie html:
							def product_view(request):
								my_t=request.GET.get('title')
								objects = Product.objects.filter(title=my_t) if my_t !=None else None
								return render(request, 'product/searched.html',{'objects':objects})
				*w templates w searched.html możesz wyświetlić te produkty 
							{% if objects %}
								{% for obj in objects %}
									<h3>{{obj.title}}</h3>
								{% endfor %}
							{%endif %}
			*POST - metoda/żądanie do wysłania informacji na serwer. 
				*Trzeba użyć konstrukcji {% csrf_token %} gdyż żądanie 'POST' jest żądaniem zaszyfrowanym	
				 oraz atrybut 'autocomplete="off"' dla tagu 'form' żeby przy cofaniu formularza nie 
				 uzupełniało pól wpisanymi danymi:
							<form action='search/' method='POST' autocomplete="off">
								{% csrf_token %}
								<input type="text" name='title' placeholder='Your title' />   
								<input type='submit' value="Save" />
							</form>
				*mógłbyś wyświetlić te wpisywane dane robiąc w pliku views.py: print(request.POST). Zwróci
 				 QuerySet, czyli słownik kluczy (atrybut name w inputcie) i wartości (to co wpisywane)
				*OPCJA 1 - WYŚWIETLENIE DANYCH z przesłanego formularza we views.py:
					*we views.py poprzez: 'print(request.POST)' możesz wyświetlić dane z formularza -zwróci 
					 QuerySet czyli słownik kluczy (atrybuty name w inputcie) i wartości (to co wpisywane)
					*dane te możesz przesłać dalej - atrybut 'action' przeniesie nas do linka 'search/' 
					 ktory w urls.py wywoła funkcję we views.py - tam tak samo jak w żądaniu 'GET' możesz 
					 odebrać dane z inuputu name="title"za pomocą: request.POST.get('title') i wyświetlić 
					 je na stronie searched.html:
							def product_view(request):
								my_title=request.POST.get('title')
								objects = Product.objects.filter(title=my_title)
								return render(request, 'product/searched.html',{'objects':objects})
					*w templates w searched.html możesz wyświetlić te produkty ALE BY MÓC TO ZROBIĆ musisz 
					 dodać token {% csrf_token %}:
							{% csrf_token %}
							{% if objects %}
								{% for obj in objects %}
									<h3>{{obj.title}}</h3>
								{% endfor %}
							{%endif %} 
				*OPCJA 2 - UTWORZENIE OBIEKTU, ZAPIS DANYCH, MODYFIKACJA DANYCH (m.in. inkrementacje) z 
				 przesłanego formularza we views.py:
					*żądania POST (zamiast wyświetlenia danych) możemy użyć do zapisu/modyfikacji danych 
					 na serwerze - wtedy NIE WOLNO UŻYWAĆ METODY RENDER()!!! Zamiast niej UŻYWAJ METODY
					 HttpResponseRedirect() z metodą reverse() po to by przy odświeżaniu lub cofaniu strony
					 nie renderowało strony 2gi raz i tym i samym nie przesyłało formularza 2gi raz (czyli 
					 nie wykorzystywało danych ze słownika request 2gi raz)(Views -> HttpResponseRedirect()):
							from django.http import HttpResponseRedirect
							from django.urls import reverse
							def product_view(request):
								my_title=request.POST.get('title')
								Product.objects.create(title=my_title)
								return HttpResponseRedirect(reverse('product_create'))
								#NIE WOLNO: return render(request, "products/product_create.html", {})
						# Always return an HttpResponseRedirect after successfully dealing with POST data.
						# This prevents data from being posted twice if a user hits the Back button.
		1*PODSTAWOWY FORMULARZ W DJANGO:
		    *WE FORMS.PY:
				A*z POLAMI DLA KLASY:
					*utworzona klasa dziedziczy po standardowych formularzach form.Form
					*wewnątrz klasy wpisujesz pola wraz z możliwość wpisania im odpowiednich ograniczeń. 
							from .models import Product
							from django import forms
							class ProductRawForm(forms.Form):
								title       = forms.CharField(label='', widget=forms.TextInput(attrs={
																	"placeholder":"your title"
																}))
								description = forms.CharField(required=False, widget=forms.Textarea(attrs={
																	"class":"new-class-name two",
																	"id":"my_id",
																	"rows":20,
																	"cols":120
																}))
								price       = forms.DecimalField(initial=199.99)
								summary     = forms.CharField()
								featured    = forms.BooleanField(required=False)
					*INNE TYPY PÓL: https://docs.djangoproject.com/en/4.0/ref/forms/fields/)
						*MultipleChoiceField(choices = MyObject.objects.all()) - do obiektu po stronie 
												'WIELE' w relacji 'WIELE DO WIELE' i 'JEDEN DO WIELE'		
				B*z KLASĄ WEWNĘTRZNĄ:
					*klasa główna dziedziczy po forms.ModelForm 
					*zamiast wpisywania pól w klasie głównej wszystkie ustawienia robisz w klasie 
					 WEWNĘTRZNEJ. Mógłbyś w klasie głównej przypisywac te pola co pola w klasie
					 wewnętrznej ale ma to sens tylko wtedy gdy chcesz dać jakieś ograniczenia dla pola
					 np dla pola EmailField() maksymalną ilość liter - max_width=100
					*w klasie wewnętrznej wskazujesz model i pola modelu (fields)(żeby przy przesyłaniu 
					 formularza nie wyskakiwały błędy trzeba wskazać wszystkie wymagane pola modelu. 
					 Pola opcjonalne (lub z domyślną wartością) można pominąć). 
					 *Do klasy wewnętrznej możesz też wpisać '__all__'  by wszystkie pola były uwzględnione
					  w formularzu, a jeżeli chciałbyś żeby niektóre nie byly wyświetlane to w polu
					  'exclude' wpisujesz odpowiednią listę
							from .models import Product
							from django import forms
							class ProductCreateForm(forms.ModelForm):
								####poniżej wpisujesz ograniczenia dla poszczególnych pól
								title = forms.CharField(widget=forms.TextInput(
																			attrs={"placeholder":"ex"}))
								description = forms.CharField(widget=forms.Textarea(
																			attrs={"placeholder":"ex"}))
								featured    = forms.BooleanField(required=False)
								class Meta:
									model=Product
									fields =['title', 'description', 'price', 'summary', 'featured']
									#fields = '__all__'
									#exclude =['price', 'summary']
				***WŁASNA WALIDACJA DANYCH (dla forms.Form i forms.ModelForm):
						*wewnątrz korzystasz z atrybutu cleaned_data
						*podnosisz wyjątek ValidationError z biblioteki forms ALBO wywołujesz metodę 
						 add_error() dla danego pola ( self.add_error('email', 'this is error) )
						*tworzysz we forms.py funkcję wg schematu nazewnictwa: 'clean_<my_field_name>' 
						 Funkcja ta będzie automatycznie odpaloana przy przesyłaniu formularza. 
								def clean_email(self, *args, **kwargs):
									email=self.cleaned_data.get("email")
									if email.endswith("edu"):
										raise forms.ValidationError('it is error')
									else:
										return email
								  # if email.endswith("edu"):
								  #		self.add_error('email', 'this is error)
						*dla walidacji wszystkich danych przesłonisz metodę clean:
								def clean(self):
									title=self.cleaned_data.get("title")
									qs = Product.objects.all().filter(title__icontains=title)
									if qs.exists():
										self.add_error('title', f"{title} already exists")
									return self.cleaned_data
			*WE VIEWS.PY: 
				*FUNKCJE i ATRYBUTY związane z formularzami:
					**form.cleaned_data - atrybut zwracający słownik przesłanych danych z formularza
					**form.errors - atrybut zwracający wszystkie błędy z danego formularza
					**form.is_valid() - waliduje dane z formularza
					**form.save() - zapisuję dane z formularza w modelu/tabeli
					**form.save_m2m() - oprócz form.save() trzeba zapisać tez wszystkie relacje 'WIELE DO
					  WIELE' (jeżeli istnieją) gdyż inaczej te dane nie będą przekazane przy zapisie ob.
					**My_model.objects.get_or_create(request.POST.get('formAttr'))  LUB
					  My_model.objects.get_or_create(form.cleaned_data['formAttr']) - na bazie pobranych 
					  danych z formularza tworzy lub pobiera z tabeli dany obiekt. (patrz 1*FORMULARZ DLA 
					  MODELU KTORY JEST KLUCZEM OBCYM DLA INNEGO MODELU)					  
				*PODSTAWOWE DZIAŁANIE 
					*przy pierwszym odpaleniu strony z formularzem występuję żądanie GET dla requesta 
					 dlatego najpierw tworzysz i wysyłasz pusty formularz. 
					*przy wpisaniu danych do formularza i wysłaniu go występuję żądanie 'POST' dla 
					 requesta i następuję odswieżenie strony (praktyka jest taka że jeżeli formularz jest 
					 poprawnie zwalidowany to przekierowuję się na inną podstronę, a gdy jest niepoprawnie 
					 zwalidowany to przesyła się tę samą podstronę wraz z uzupełnionym formularzem z 
					 poprzednio wpisanymi danymi dzięki 'request.POST'):
					 #OPCJA CREATE
							from .forms import ProductCreateForm
							from django.shortcuts import render, redirect
							def product_create_view(request):
								if request.method != 'POST':			  #if request.method =='GET'
									form_empty = ProductCreateForm()
									context={'form':form_empty}
									return render(request, "products/product_create.html",context)
								else:     								  #if request.method =='POST'
									########################### WERSJA STANDARDOWA
									### form_with_data = ProductCreateForm(request.POST)
									### if form.is_valid():
									### 	form_with_data.save()
									########################### WERSJA STANDARDOWA ROZSZERZONA
									### form_with_data = ProductCreateForm(request.POST)
									### if form.is_valid()
									### 	my_prod = form_with_data.save(commit=False)	
									### 	my_prod.price = 23.10
									### 	my_prod.summary = request.POST.get('summary')
									### 	my_prod.save()
									###		return redirect('home')
									########################### WERSJA ZE SŁOWNIKIEM CLEANED_DATA V1
									### form_with_data = ProductCreateForm(request.POST)
									### if form.is_valid()
									### 	p1 = Product(**form_with_data.cleaned_data)
									###		p1.save()
									### 	return redirect('home')
									########################### WERSJA ZE SŁOWNIKIEM CLEANED_DATA V2
									### form_with_data = ProductCreateForm(request.POST)
									### if form.is_valid()
									### 	n = form_with_data.cleaned_data
									### 	Product.objects.create(title = n["title"], 
									###				description = n["description"], 
									### 			price = n["price"], 
									###				summary = n["summary"],
									###    			featured = n["featured"])
									### 	return redirect('home')
									########################### WERSJA Z REQUESTEM:
									### if request.POST.get('title') is not None and 
									###				request.POST.get('description') is not None and 
									###				request.POST.get('price') is not None and 
									###				request.POST.get('summary') is not None and 
									###				request.POST.get('featured') is not None:
									###		Product.objects.create(title = request.POST.get('title'),
									###				description = request.POST.get('description'),
									###				price = request.POST.get('price'), 
									###				summary = request.POST.get('summary'),
									###				featured = request.POST.get('featured'))
									###		return redirect('home')
									else:
										context={'form':form_with_data}
										return render(request, "products/product_create.html",context)
					 #OPCJA UPDATE:
							from .forms import ProductCreateForm
							from django.shortcuts import render, redirect
							from django.urls import reverse
							def product_update_view(request, my_id):
								obj = Product.objects.get(id=my_id)
								if request.method != 'POST':			  #if request.method =='GET'
									form_with_downloaded_data = ProductCreateForm(instance=obj)
									context = {'form':form_with_downloaded_data}
									return render(request, "products/product_create.html",context)
								else:     								  #if request.method =='POST'
									form_with_data = ProductCreateForm(request.POST, instance=obj)
									if form_with_data.is_valid():
										my_prod = form_with_data.save(commit=False)
										my_prod.price = 23.10
										my_prod.summary = request.POST.get('summary')
										my_prod.save()
										return redirect(reverse("product_detail", kwargs={'my_id':obj.id}))
									else:
										context = {'form':form_with_data}
										return render(request, "products/product_create.html",context)
				*PRZEKAZANIE DO FORMULARZA DANYCH DOMYŚLNYCH jako obiekt z bazy danych ('instance') i 
				 jako tekst inicjalizowany ('initial). Ten drugi zawsze będzie miał pierszeństwo nad
				 obiektem z bazy danych dlatego trzeba zrobić warunkowe przekazanie obiektu:
							def product_create_view(request):
								if request.method != 'POST':
									initial_Data={'title':'awesome title'}	#dane zainiclizowane 
									obj = Product.objects.get(id=1)			#instancja z bazy danych
									if obj ==None:
										form_empty = ProductCreateForm(initial=initial_Data)
									else:
										form_empty = ProductCreateForm(instance=obj)
									context={'form':form_empty}
									return render(request, "products/product_create.html",context)
								...
				*RENDEROWANIE CRISPY FORM - zmiana formy renderowania i przedstawienia błędów przy
				 walidacji danych w formularzu z 'form.as_p' na 'form|crispy':
						*instalujesz django-crispy-forms w konsoli poprzez:
									pipenv install django-crispy-forms  /  pip install django-crispy-forms
						*W SETTINGS.PY w głównej app/funkc. w sekcji INSTALLED_APPS dodajesz crispy_forms:
									INSTALLED_APPS = [
										...
										'crispy_forms',
									]
						 oraz dodajesz w tym samym pliku zmienną CRISPY_TEMPLATE_PACK = 'bootstrap4'
									CRISPY_TEMPLATE_PACK = 'bootstrap4'
						*WE VIEWS.PY - od teraz w zmiennej form korzystasz z renderowania '|cripsy':
									...
									{form|crispy}
			*W TEMPLATES:
				*dla tagu 'form' żtrzeba dodać atrybut 'autocomplete="off"' żeby przy cofaniu formularza nie 
				 uzupełniało pól wpisanymi danymi
				*Możliwości ukazania formularza:
					*jako zmienna:
							###<form action={% url 'meetup-detail' zmienna.slug %}" method ="POST" >
							<form action ="" method="POST" autocomplete="off">		
								{% csrf_token %}
								{{form.as_p}}
								<button type="submit">SAVE</button> #<input type='submit' value="SAVE"/>
							</form>
					*przechodząc przez każde pole formularza w pętli:
							###<form action={% url 'meetup-detail' zmienna.slug %}" method ="POST">
							<form action ="" method="POST" autocomplete="off">		
								{% csrf_token %}
								{% for my_field in form %}
									{{my_field.label}}
									{{my_field}}
								{% endfor %}
								<button type="submit">SAVE</button> #<input type='submit' value="SAVE"/>
							</form>
					*wypisując każde pole z osobna:
							#dla modelu o polach ['title', 'description']
							###<form action={% url 'meetup-detail' zmienna.slug %}" method ="POST">
							<form action ="" method="POST" autocomplete="off">		
								{% csrf_token %}
								{{form.title.label}}
								{{form.title}}
								{{form.description.label}}
								{{form.description}}
								<button type="submit">SAVE</button> #<input type='submit' value="SAVE"/>
							</form>		
				*ELEMENTY potrzebne do działania formularza:
					**<form method="POST" autocomplete="off">	  
											  - tag form z metodą ustawioną na 'POST' oraz autocomplete="off"
					  <form action={% url 'meetup-detail' selected_meetup.slug %}" method ="POST">
											  - możesz ale nie musisz podać atrybut action do form. Action 
											    przy POST może przekierowywać na tę samą stronę co pozwoli 
												zobaczyć dane w oknach formularza, możesz też przekierować 
												na inną podstronę z danymi z formularza
					**{% csrf_token %}		  - ukryty_tag/token do prawidłowego działania żądania 'POST' 
					**{{ form.as_p }}		  - wyrenderowana zmienna/klucz 'form' z przesyłanego słownika 
					**<button type="submit">  - tag przycisku (button / input) z ustawieniem type ="submit"
				*możliwości renderowania formularza:
					*jako 'paragraph'							{{form.as_p}}
					*jako 'table' (w rzędzie - domyślnie)		{{form.as_table}}
					*jako 'unordered list'						{{form.as_ul}}
					
		2*FORMULARZ PODSTAWOWY Z MODELEM MAJĄCYM POLE TYPU ManyToManyField - dotyczy formularzy dla modeli 
		 które są w relacji 'jeden do wiele' lub 'wiele do wiele' do innych obiektów:
			*W MODELS.PY:
							class Participant(models.Model):
								name=models.CharField(max_length=200)
								email=models.EmailField(unique=True)
							class Meetup(models.Model):
								host=models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
								title=models.CharField(max_length=200)
								participants = models.ManyToManyField(Participant, blank=True, null=True)
			*WE FORMS.PY:
							### DLA PRZYKŁADU 1:
							class RegistrationForm(forms.Form):
								name = CharField(max_length=200)
								email = forms.EmailField(label = 'Your email')
							### DLA PRZYKŁADU 2:
							class MeetupForm(forms.Form):
								title=models.CharField(max_length=200)
								participants=forms.MultipleChoiceField(choices = Participant.objects.all())
			*WE VIEWS.PY (wykorzystujesz get_or_create(MyOBJ) - twrozy obiekt lub pobiera go z bazy danych 
			 jeżeli istnieje (Get_or_create() zwraca krotkę: (obiekt, flaga_CzyUtworzono)):
				1*DODANIE POJEDYŃCZEGO OBIEKTU będacego POLEM typu ManyToManyField() w innym OBIEKCIE
				  DO TEGO INNEGO OBIEKTU:
							def register_user_in_meetup(request, meetup_slug):
								selected_meetup = Meetup.objects.get(slug=meetup_slug)
								########################### WERSJA ZE SŁOWNIKIEM CLEANED_DATA
								### form = RegisterForm()
								### if request.method='POST':
								### 	form=RegistrationForm(request.POST)
								### 	if form.is_valid():
								### 		### CHCĄC SKORZYSTAĆ z metody get_or_create() NIE MOŻESZ użyć
								###			### wersji standardowej: p=form.save() + selected_meetup.add(p)
								### 		p, was_created = Participant.objects.get_or_create(
								### 								name = form.cleaned_data['name'],
								### 								email = form.cleaned_data['email'])
								### 		selected_meetup.add(p)
								### 		return redirect('home')
								########################### WERSJA Z REQUESTEM - nie działająca dla 
								########################### 			pojedyńczej zmiennej {{form}} 
								### form = RegisterForm()
								### if request.method='POST':
								### 	form=RegistrationForm(request.POST)
								### 	if request.POST.get('name') is not None and 
								### 							request.POST.get('email') is not None:
								### 		p, was_created = Participant.objects.get_or_create(
								### 							name = request.POST.get('name'),
								### 							email = request.POST.get('email'))
								### 		selected_meetup.add(p)
								### 		return redirect('home')
								context={'selected_meetup':selected_meetup, 'form': form}
								return render(request, 'meetups/meetup-detail.html', context)
				2*DODANIE WIELU OBIEKTÓW będącyh POLEM typu ManyToManyField() w innymm OBIEKCIE DO TEGO 
				  INNEGO OBIEKTU PODCZAS TWORZENIA GO:
							def create_meetup(request):
								form = MeetupForm()
								if request.method='POST':
								########################### WERSJA STANDARDOWA:
								###	form=MeetupForm(request.POST)
								###	if form.is_valid():
								###		m = form.save(commit=False)
								###		m.host = request.user
								###		m.save()
								###		form.save_m2m()
								###		return redirect('home')
								########################### WERSJA ZE SŁOWNIKIEM CLEANED_DATA
								###	form=MeetupForm(request.POST)
								###	if form.is_valid():
								###		### Meetup.objects.create(**form.cleaned_data) ###tak nie można
								###						### gdyż obiekty pól ManyToManyField muszą byc 
								###						### zapisywane po utworzeniu obiektu głównego
								###		m = Meetup(host = request.user,
								###			  			  title = form.cleaned_data('title'))
								###		m.save()
								###		for p in form.cleaned_data['participants']):
								###			m.participants.add(p)
								###		return redirect('home')
								########################### WERSJA Z REQUESTEM - nie działająca dla 
								########################### 			pojedyńczej zmiennej {{form}} 
								###	if request.POST.get('title') is not None and 
								###						request.POST.getlist('participants') is not None:
								###		m = Meetup.objects.create(host=request.user,
								###								  title=request.POST.get('title'))
								###		for participant_id in request.POST.getlist('participants'):
								###			p = Participant.objects.get(id=participant_id)
								###			m.participants.add(p)
								###		return redirect('home')
								context={'form': form}
								return render(request, 'meetup/create_meetup.html', context)
			*W TEMPLATES:
				1*WERSJA html'a NIE DAJĄCA MOŻLIWOŚCI działania WERSJI Z REQUESTEM we views.py:
					ad1*FORMULARZ DLA PKT1 WE VIEWS.PY:
							<form action="" method ="POST" autocomplete="off">
								{% csrf_token %}
								{{form.as_p}}
								<button type="submit">REGISTER USER IN MEETUP</button>
							</form>
					ad2*FORMULARZ DLA PKT2 WE VIEWS.PY:
							<form action="" method ="POST" autocomplete="off">
								{% csrf_token %}
								{{form.as_p}}
								<button type="submit">CREATE ROOM</button>
							</form>
				2*WERSJA html'a DAJĄCA MOŻLIWOŚC działania WERSJI Z REQUESTEM we views.py:
					ad1*FORMULARZ DLA PKT1 WE VIEWS.PY:
							<form action="" method ="POST" autocomplete="off">
								{% csrf_token %}
								{{form.name.label}}
								{{form.name}}
								{{form.email.label}}
								{{form.email}}
								<button type="submit">REGISTER USER IN MEETUP</button>
							</form>
					ad2*FORMULARZ DLA PKT1 WE VIEWS.PY:
							<form action="" method ="POST" autocomplete="off">
								{% csrf_token %}
								{{form.title.label}}
								{{form.title}}
								{{form.participants.label}}
								{{form.participants}}
								<button type="submit">REGISTER USER IN MEETUP</button>
							</form>
				***chcąc wyświetlić pole ManyToMany w liscie trzeba do zmiennej dodać '.all':
								...
								{{form.participants.all}}
								....
		3*MIESZANY FORMULARZ - zawierający pola standardowego formularza w HTMLu i pola oparte na zmiennych.
		  Ponadto pokazanie DODAWANIA OBIEKTÓW W RELACJACH JEDEN DO WIELE i WIELE DO WIELE: 
			*w MODELS.PY :
				*w klasie Room pole 'topic' w relacji JEDEN DO WIELE i pole 'participants' w relacji 
				 WIELE DO WIELE:
							class Participant(models.Model):
								email = models.EmailField(unique=True)
							class Topic(models.Model):
								name = models.CharField(max_length=200)
							class Room(models.Model):
								host = models.ForeignKey(User, on_delete=models.SET_NULL, null=True)
								topic = models.ForeignKey(Topic, on_delete=models.SET_NULL, null=True)
								participants = models.ManyToManyField(Participant, blank=True, null=True)
								name = models.CharField(max_length =200)
								description = models.TextField(null=True, blank=True)
			*we FORMS.PY:
							from django import forms
							class RoomForm(forms.ModelForm):
								#participants=forms.MultipleChoiceField(choices = Participant.objects.all())
								class Meta:
									model =Room
									fields = '__all__'
									exclude = ['host']
			*we VIEWS.PY:
				*pola standardowe ('name' i 'description') pobierasz na 3 sposoby:
					**w wersji standardowego formularza
					**słownik cleaned_data wywołany na formularzu (klucze o nazwach zmiennych formularza) 
					**obiekt request.POST.get('attrName') gdzie daną zmienną z formularza pobierasz 
					  poprzez nazwę danej zmiennej z fomularza (odpowiadającą atrybutowi 'name' w tagu
					  w standardowym formularzu)
				*pole 'topic' w relacji JEDEN DO WIELE jest tworzone przy pomocy metody get_or_create() 
				 która tworzy obiekt gdy ten nie istnieje lub pobiera go z listy wszystkich obiektów.
				*ponieważ formularz zawiera pole 'topic' które jest wymagane do zwalidowania formularza 
				 przesłaniasz słownik request'a ('updated_data') z przypisaną wartością 'topic'
				*dla pól ManyToManyField do zapisu używasz na formularzu metody form.save_m2m() ALBO
				 po zapisaniu obiektu pojedyńczo dodajesz obiekt poprzez metodę add() na pojedyńczych
				 el. listy: form.cleaned_data('participants') LUB (request.POST.getlist('participants')				 
							def createRoom(request):
								form = RoomForm()
								if request.method == "POST":
									topic_name= request.POST.get('t_name')
									topic, was_created = Topic.objects.get_or_create(name = topic_name)
									############################### WERSJA STANDARDOWA:	
									### form=RoomForm(request.POST)
									### if topic is not None: ### w formularzu pole 'topic' musi istnieć
									###						  ### żeby formularz mógł zostać zwalidowany
									###     updated_data = request.POST.copy()
									###     updated_data.update(topic=topic)
									###     form = RoomForm(data=updated_data) #zamiast request.POST
									### if form.is_valid():
									###     room = form.save(commit=False)
									###     room.host = request.user
									###     room.save()
									###     form.save_m2m()   ### pole 'participants' będące polem typu 
									###						  ###'WIELE' w relacji 'WIELE DO WIELE' musi 
									###						  ### zostać zapisane po utworzeniu obiektu 
									###     return redirect('home')
									############################### WERSJA ZE SŁOWNIKIEM CLEANED_DATA:
									### form=RoomForm(request.POST)
									### if topic is not None:
									###     updated_data = request.POST.copy()
									###     updated_data.update(topic=topic)
									###     form = RoomForm(data=updated_data)
									### if form.is_valid():
									###     #### room= Room(**form.cleaned_data)  ### tak nie wolno gdyż 
									### 					  ### pole MultipleChoices będące po stronie 
									###						  ### 'WIELE' w relacji WIELE DO WIELE musi 
									###						  ### zostać zapisane po zapisaniu obiektu
									###     room = Room(name=form.cleaned_data["name"], 
									###                 description = form.cleaned_data["description"],
									###                 topic = topic)
									###     room.save()
									###     for participant in form.cleaned_data['participants']:
									###         room.participants.add(participant)
									###     return redirect('home')
									############################### WERSJA Z REQUESTEM:
									### r1 = Room.objects.create(
									###     host=request.user,
									###     topic=topic,
									###     name = request.POST.get('name'),
									###     description = request.POST.get('description')	
									### )
									### for participant_id in request.POST.getlist('participants'):
									###     p=Participant.objects.get(id=int(participant_id))
									###     r1.participants.add(p)
									### return redirect('home')
								topics = Topic.objects.all()
								#participants = Participant.objects.all() #gdy participants są wyświetlani
															 ### w czystym HTMLu zamiast zmiennych form'u
								context = {'form':form, 'topics' : topics, 'participants': participants}
								return render(request, 'app1/create.html', context)
			*W TEMPLATES plik html:
				*budujesz formularz w HTMLa częsciowo w oparciu o samego HTMLa a częsciowo o zmienną 'form'
				 reprezentującą formularz utworzony na bazie formularza dziedziczącego po ModelForm
				*we views będziesz pobierał dane poprzez request.POST.get(___) wpisując nazwy dla atrybutu
				 'name' każdego tagu. Dla zmiennych, atrybut 'name' domyślnie jest ustawiony na nazwę 
				 zmiennej formularza (czyli zmienna {{form.description}} ma domyślny atrybut 'name' 
				 ustawiony na 'description'):
								<form action="" method ="POST" autocomplete="off">
									{% csrf_token %}
									<div>
										<div>
											<label for="room_topic">Topic</label>
											<input required type="text" name="t_name" list="topic-list"/>
											<datalist id="topic-list">
												<select id="room_topic">
													{% for t in topics %}
														<option value="{{t.name}}">{{t.name}}</option>
													{% endfor %}
												</select>
											</datalist>
										</div>
										{{form.participants.label}}
										{{form.participants}}
										{{form.name.label}}
										{{form.name}}
										{{form.description.label}}
										{{form.description}}
										<button type="submit">Create Room</button>
									</div>
								</form>
				*zamiast {{form.participants}} mógłbyś użyć wersji czystego HTML'a ale wtedy dane we 
				 views.py mógłbyś pobierac tylko poprzez: request.POST.getlist('participants') ,zamiast:
					for p in form.cleaned_data['participants']:     	 ALBO:		  form.save_m2m()
						room.participants.add(p)  
				 WTEDY w HTML'u:
								<form action="" method ="POST" autocomplete="off">
									{% csrf_token %}
									<div>
										<div>
											<label for="room_topic">Topic</label>
											<input required type="text" name="t_name" list="topic-list"/>
											<datalist id="topic-list">
												<select id="room_topic">
													{% for t in topics %}
														<option value="{{t.name}}">{{t.name}}</option>
													{% endfor %}
												</select>
											</datalist>
										</div>
										<div>
											<label for="room_participants">Participants</label>
											<select id="room_participants" name="participants" multiple>
												{% for par in participants %}
													<option value="{{par.email}}">{{par.email}}</option>
												{% endfor %}
											</select>
										</div>
										{{form.name.label}}
										{{form.name}}
										{{form.description.label}}
										{{form.description}}
										<button type="submit">Create Room</button>
									</div>
								</form>
								
  *3*CLASS-BASED-VIEWS		
    a)*PODSTAWY:
		A*RÓŻNICE MIĘDZY FUNCTION-BASED-VIEWS a CLASS-BASED-VIEWS:
			*FUNCTION-BASED-VIEWS:
				*w urls.py (w path) przekazywaliśmy jaka funkcja we views ma się uruchomić gdy zostanie 
				 wybrana dana ścieżka. We views.py (w funkcji w render) wskazywaliśmy stronę HTML w 
				 katalogu templates do otwarcia i przekazywaliśmy do niej zmienne za pomocą słownika w 
				 3 arg funkcji render() (name).
			*CLASS-BASED-VIEWS (generic views):
				*NAJWAŻNIEJSZE: class-based-views zamiast przekazywania danych z bazy danych przez render()
				*class-based-views robią za nas powtarzalną backendową logikę
				*we views.py zamiast funkcji (gdzie musiałbyś wyrenderować całą funkcję) tworzysz klasę 
				 dziedziczącą po class-based-view (gdzie tylko konfigurujesz wartości dla pól)
				*w class_based-views można zostawić wartości wszystkich pól jako domyślne (oprócz model lub
				 queryset) i działać na domyślnej nazwie template'u i domyślnej nazwie zwracanych danych co 
				 zmniejsza ilość kodu.
		B*DZIAŁANIE:
			*class-based-views domyślnie wyciąga dane z bazy danych (i przekazuję je do katalogu templates)
			 Robi to poprzez domyślną metodę get_object() zwracającą albo instrukcje ORM/SQL albo funkcję 
			 get_object_or_404. Get_object() jest domyślnie skonfigurowana wg podanego modelu oraz typu 
			 danego class-based-view. (patrz --> get_object())
			*w templates tworzysz plik HTML wg fomuły: <app>/<model>_<class-based-viewtype>.html która 
			 będzie domyślną nazwą dla pola templates_name w danym class-based-view. Strona ta będzie 
			 wywoływana po uruchomieniu danego class-based-views (w urls.py) przez dany link.
			 (Tak jakbyś użył funkcji render w zwyczajnej funkcji we views):
			*RODZAJE class-based-views:
				*list views		-zwraca listę wszystkich obiektów z modelu/tabeli np: list of all posts 
				*detail views	-zwraca konkretny obiekt z modelu/tabeli np: post with specific id
				*create views	-tworzy formularz do tworzenia obiektu modelu/tabeli. np: form of new post
				*update views	-pozwala updatować konkretny obiekt modelu/tabeli np: update specific post 
				*delete views   -pozwala usunąć konkretny obiekt modelu/tabeli np: delete specific post
				*...more
			*PODSTAWOWE OBOWIĄZKOWE POLA DO PRZESŁONIĘCIA W DANYM VIEWS:
				*model - wskazuję model z models.py. Podajesz nazwę klasy pobraną z models a nie stringa. 
				 (Jeżeli przesłaniasz 'queryset' to nie musisz przesłaniać 'model')
						class PostListView(DetailView):
							model = Post
				*queryset - zawęża obszar wyszukiwania zamiast zwracać konkretne interesujące rekordy.
				 Podajesz instrukcje ORM/SQL. (Jeżeli przesłaniasz 'model' to nie musisz już 'queryset')
						class PostListView(DetailView):	
							queryset = Post.objects.all()
				*get_queryset() - zamiast queryset możesz użyć get_queryset() który zamiast zwracać 
				 konkretne rekordy to zaweża obszar poszukiwań:
						class PostListView(DetailView):	
							def get_queryset(self):
								...
								return Post.objects.all()

	b)*PRZYPADKI:
	  ----------
	  ----------
	  **LISTVIEW - przekaże do wskazanej strony HTML listę wszystkich obiektów danego modelu/tabeli 
		odpowiadającej instrukcji ORM/SQL:  <nazwa_modelu>.objects.all()
		   A*W URLS.PY:
				*najpierw musisz stworzyć klase dziedziczącą po ListView
				*uruchomienie klasy dziedziczącej po ListView jako funkcji (as_view()) dla danej ścieżki
						from .views import PostListView
						urlpatterns = [
							path('',views.PostListView.as_view(), name='blog-home'),
						...
		   B*WE VIEWS.PY:
				*podstawowy ListView - utworzenie klasy dziedziczącą po ListView i wskazanie modelu
						from django.views.generic import ListView
						from .models import Post
						class PostListView(DetailView):
							model=Post
			 ***OBOWIĄZKOWE POLA/FUNKCJE w LISTVIEW- tylko te podstawowe (model, ew queryset)
			 ***OPCJONALNE (DOMYŚLNE) POLA/FUNKCJE z możlwiością PRZESŁONIĘCIA:
				*template_name - pole przypisujące stronę html z katalogu templates. Bez przesłaniania 
				 wskazuję na stronę wg formuły nazewnictwa <app>/<model>_<class-based-viewtype>.html 
				 Najlepiej jakbyś stworzył stronę HTML wg tej formuły nazewnictwa i nie musiał przesłaniać
				 tego tego pola. (dla ' model = Post ' musiałbyś stworzyć plik post_list.html):
						class PostListView(DetailView):
							model = Post	
							templates_name='blog/home.html'	   #zamiast post_list.html przypisuję home.html
				*context_object_name - we function-based-views odpowiadało y to nazwie klucza w słowniku 
				 przekazanemu jako 3 arg metody render. context_object_name to zmienna z przypisaną nazwą 
				 zmiennej dla pliku html odpowiadająca instrukcji: <nazwa_modelu>.objects.all(). Wynik 
				 daje listę wszystkich obiektów danego modelu. Domyślna wartość dla context_object_name
				 to 'object_list'
						class PostListView(ListView):
							model=Post
							templates_name='blog/home.html'
							context_objects_name='posts' 		#zamiast domyślnej nazwy 'object_list'
				 Gdybyś w 1 pliku html miał kilka ListView to dla każdej przesłoń to pole, dzięki temu w 
				 templatesach w zmiennej zamiast 'object_list' używasz 'posts':
						{% for post in posts %}					#zamiast {% for post in object_list %}
				*ordering - sortowanie listy wg jednego z pól jej obiektów (przypisujesz listę z nazwą 
				 pola w cudzysłowiu). Jezeli dodasz na początku '-' to odwróci kolejność
						class PostListView(ListView):
							model=Post
							templates_name='blog/home.html'
							context_objects_name='posts'
							ordering=['-date_posted']				
		   C*W TEMPLATES:
				*zamiast przypisywać do template_name: 'blog/home.html' to w templates tworzysz plik HTML 
				 wg formuły nazewnictwa  <app>/<model>_<class-based-viewtype>.html  
				*Dla modelu 'Post' i ListView (jako typu class-based-view) tworzysz plik 'post_list.html' 
	  ------------
	  ------------
	  **DETAILVIEW - przekaże do wskazanej strony HTML konkretny obiekt z danego modelu/tabeli
  	    odpowiadający instrukję ORM/SQL  <nazwa_modelu>.objects.get(id=x) ID będzie wskazane w ścieżce
		w 1szym arg funkcji path w pliku urls.py.	
		   A*W URLS.PY 
				*najpierw musisz stworzyć klase dziedziczącą po DetailView
				*uruchomienie klasy dziedziczącej po DetailView jako funkcji (as_view()) dla danej ścieżki
				 z użyciem dynamic url czyli zmiennymi w ścieżkach (poprzez nawiasy trójkątne: '<...>')
				*dla class-based-views musisz w DYNAMIC URL wskazać: <pk> ALBO <slug>
				*mozesz wskazać django że Primary Key może być tylko integer'em: <int:pk>
						from .views import PostDetailView
						urlpatterns = [
							path('post/<pk>/', PostDetailView.as_view(), name='post-detail')
						...
			****W MODELS.PY:
				*Chcąc skorzystać z 3 zmiennej funkcji path tj 'post-detail' w linkach oraz w CREATEVIEW 
				 i UPDATEVIEW (przy przekierowaniu na DETAILVIEW po update'owaniu lub utworzeniu obiektu)
				 musisz wskazać jakos id Postu na który ma być przekierowanie. Robisz to tworząc metodę
				 get_absolute_url() w models.py gdzie w funkcji reverse wskazujesz w argumencie kwargs 
				 'pk' lub 'slug' (klucz musi się nazywać 'pk' albo 'slug'):
						    def get_absolute_url(self):
								return reverse('post-detail', kwargs={'pk':self.pk})
		   B*WE VIEWS.PY:
				*podstawowy DetailView - utworzenie klasy dziedziczącą po DetailView i wskazanie modelu		
						from django.views.generic import DetailView
						from .models import Post
						class PostDetailView(DetailView):
							model=Post
			 ***OBOWIĄZKOWE POLA/FUNKCJE w DETAILVIEW - tylko te podstawowe (model, ew. queryset)
			 ***OPCJONALNE (DOMYŚLNE) POLA/FUNKCJE z możlwiością PRZESŁONIĘCIA:
				*template_name - domyślnie ustawione wg składni: <model>_<class-based viewtype>.html. 
				 Dla modelu Post na post_detail.html (Pole przypisujące stronę html z katalogu templates)
				*context_object_name  - będzie domyślnie ustawione na wartość: 'object', chyba że podasz 
				 pole model to wtedy będzie to 'object' albo nazwa modelu z małej litery. Będzie to 
				 odzwierciedlać instrukcję ORM/SQL zwracającą obiekt z danej tabeli/modelu o danym id. We 
				 function-based-views odpowiadałoby to nazwie klucza w słowniku przekazanemu jako 3 arg 
				 metody render. 
						class PostDetailView(DetailView):
							model=Post
							context_object_name='post' 			#zamiast domyślnej nazwy 'object'
				*pk_url_kwarg wskazuję na nazwę zmiennej w dynamic url. Będzie domyślnie ustawione na 'pk' 
				 jako Primary Key i w dynamic url w urls.py rónież powinno być ustawione na pk: <int:pk>
						class PostDetailView(DetailView):
							model=Post
							pk_url_kwarg = 'pk'
				*get_object(self) - teoretycznie nie musisz tego przesłaniać ale dzięki temu przesłonięciu
				 używasz metody get_object_or_404 która gdy obiekt nie istnieje zamiast błędu zwróci 
				 stronę 404:
						from django.shortcuts import get_object_or_404
						class PostDetailView(DetailView):
							def get_object(self):
								my_pk = self.kwargs.get("pk")     	 #pk pobrane ze ścieżki url <int:pk> 
								return get_object_or_404(Article, pk =my_id)   #musisz podać id albo pk
				 *x*chcąc pobrać dynamic url uzywasz:
								my_pk = self.kwargs.get("pk") 
		   C*W TEMPLATES:
			 ***STRONA HTML POWIĄZANA Z DETAILVIEW:
				*tworzysz stronę html wg fomuły nazewnictwa <app>/<model>_<class-based-viewtype>.html która 
				 będzie domyślną nazwą dla pola template_name w danym class-based-view. Dla modelu 'Post' 
				 i DetailView (jako typu class-based-view) stworzyłbyś plik 'post_detail.html'.
				*wewnątrz odwołujesz się do danego postu za pomocą pola: 'object' które odzwierciedla 
				 instrukcje SQL/ORM: Post.objects.get(id=x)  #id wskazane w dynamic url w urls.py: <int:pk> 
						object.author.profile.image.url = Post.objects.get(id=1).author.profile.image.url  
						object.title = Post.objects.get(id=1).title
						object.content = Post.objects.get(id=1).content
			 ***LINKI W INNYCH STRONACH HTML (NIEPOWIĄZANYCH Z DETAILVIEW):
				*chcąc wskazać link do konkretnej strony html powiązanej DetailView to oprócz nazwy 3 arg.
				 funkcji path w urls musisz jeszcze wpisać id danego wywoływanego obiektu (jeżeli w swojej
				 stronie nie powiązanej z DetailView operujesz na zmiennej 'object' to wywołujesz id:
						<a href="{% url 'post-detail' object.id %}">...</a> 
			 ***OPCJE DO EDYTOWANIA I USUWANIA wyświetlające się dla zalogowanego usera który operuję na 
			    obiekcie który stworzył (dokładasz to do post_detail.html gdy masz UPDATEVIEW, DETAILVIEW):
						{% if object.author == user %}
							<a href= "{% url 'post-update' object.id %}"></a>Update</a>
							<a href="{% url 'post-delete' object.id %}"></a>Delete</a>
						{% endif %}
						
	  ------------
	  ------------
	  **klasy CreateView, UpdateView, DeleteView korzystają zazwyczaj z LOGINREQUIREDMIXIN (patrz 2*MIXINS)
	  ------------
	  ------------
	  **CREATEVIEW - związany domyślnie z plikiem <model>_form.html tworzy formularz dla danego modelu.
		Żeby mógł działać ten formularz trzeba wskazać stronę na którą będzie przekierowanie po przesłaniu 
		formularza (success_url lub get_success_url() lub w models: get_absolute_url()). Ponadto użytkownik 
		powinien być zalogowany (LoginRequiredMixin) oraz powinien być przekazany autor tworzącego się 
		obiektu do formularza (przesłonięcie metody form_valid).
		   A*W URLS.PY 
				*dla ścieżki 'post/new/' uruchomi class-based-view utworzony we views.py. 
				*3ci arg w funkcji path to zmienna używana w linkach w plikach html 
						from .views import PostCreateView
						urlpatterns = [
							path('post/new/', PostCreateView.as_view(), name='post-create')
						...
		   B*WE VIEWS.PY:
				*podstawowy CreateView - utworzenie klasy dziedziczącą po CreateView, wskazanie modelu,
				 wskazanie 
				*klasa ta będzie formularzem więc wewnątrz musisz przypisać ALBO pola dla tego formularza
				 (pole fields) ALBO wskazać klasę z wczesniej stworzonym formularzem (pole form_class):
						from django.views.generic import CreateView
						from .models import Post
						class PostCreateView(CreateView):
							model=Post
							fields =['title', 'content']				#lub pole class_form
							success_url='/about'						#lub get_success_url() 
																		#lub w models get_absolute_url()
			 ***OBOWIĄZKOWE POLA/FUNKCJE w CREATEVIEW:
				*pola podstawowe (model, ew. queryset)
				*fields - wskazuję na pola jakie mają być w formularzu. Koniecznie muszą mieć takie same 
				 nazwy jak pola danego modelu - na bazie tych stringów stworzy konstrukty formularzowe
						class PostCreateView(CreateView):
							model=Post
							success_url='/'
							fields =['title', 'content']	
				*class_form - zamiast fields możesz stworzyć własny formularz w swoim pliku forms.py i 
				 w CreateView tylko go wskazać:
					*wewnątrz pliku forms.py tworzysz własny formularz:
						from .models import Post
						from django import forms
						class PostForm(forms.ModelForm):
							title = forms.CharField(widget=forms.TextInput(attrs=
																	{'placeholder':'input your title'}))
							content = forms.CharField(widget=forms.Textarea(attrs=
																	{'placeholder':'input your content'}))
							class Meta:
								model = Article
								fields=['title', 'content']
					*wewnątrz views.py:
						from .forms import PostForm
						class PostCreateView(CreateView):
							model=Post
							success_url='/'
							class_form = PostForm
				*success_url - wskazuję na stronę HTML do przekierowania po stworzeniu nowego obiektu po 
				 wysłaniu formularza. Przesłaniasz żeby nie występował błąd RedirectError:
						class PostCreateView(CreateView):
							model=Post
							success_url='/blog/about/'	#'/'   		#tylko statyczne URL bez przekazania pk
							fields =['title', 'content']	
				 Zamiast success_url to W MODELS W KLASIE POST możesz przesłonić metodę get_absolute_url() 
				 do przekierowania na DetailView z nowostworzonym obiektem po przesłaniu formularza. 
				 W funkcji reverse podajesz dodatkowy arg. kwargs z pk dla class-based-view DetailView.
					*W models.py w klasie Post:
							def get_absolute_url(self):
								return reverse('post-detail', kwargs={'pk':self.pk})
				*get_success_url() - zamiast success_url. Wewnątrz CreateView możesz przekazać tylko 
				 statyczne ścieżki (bez zmiennych czyli bez dynamic url) 
							def get_success_url(self):
								return '/about'
				 Jednakże jeżeli w MODELS W KLASIE POST przesłonisz metodę get_absolute_url() w której
				 zrobisz przekierowanie do DETAILVIEW nowo utworzonego obiektu to możesz wywołać 
				 odziedziczoną metodę get_success_url() z CreateView. 
					*W models.py w klasie Post:
							def get_absolute_url(self):
								return reverse('post-detail', kwargs={'pk':self.pk})
					*We views.py:
							def get_success_url(self):
								return super().get_success_url()
			 ***OPCJONALNE (DOMYŚLNE) POLA/FUNKCJE z możlwiością PRZESŁONIĘCIA:
				*template_name - domyślnie ustawione wg składni: <model>_form.html zamiast składni 
				 <model>_<class-based viewtype>.html Dla Post: post_form.html (pole przypisujące html'a)
				*form_valid() - metoda do zwalidowania formularza przed wysłaniem
			 ***UŻYCIE LOGINREQUIREDMIXIN: (więcej: CLASS-BASED-VIEWS->MIXINS)
						from django.views.generic import CreateView, UpdateView, DeleteView
						from django.contrib.auth.mixins import LoginRequiredMixin
						class PostCreateView(LoginRequiredMixin, CreateView):
							model=Post
				*form_valid() - metoda którą koniecznie trzeba przesłonić by nie wystąpił IntegrityError 
				 Musisz przekazać do formularza autora - przed wysłaniem formularza zostanie wywołana 
				 funkcja form_valid (z przypisaniem autora) 
							def form_valid(self, form):
								form.instance.author = self.request.user
								return super().form_valid(form)
		   C*W TEMPLATES:
				*domyślna nazwa pliku HTML wg formuły nazewnictwa <model>_form.html zamiast formuły 
				 <model>_create.html czyli dla modelu Post będzie to post_form.html
				*wewnątrz pliku html podajesz:
					*tag form o metodzie 'POST'
					*{% csrf_token %}
					*zmienną {{form}} która będzie wyświetlać konstrukty formularzowe o polach podanych w 
					 zmiennej fields w class-based-views lub pola formularza przypisanego class_form:
					*button o typie 'submit':
						{% extends "blog/base.html" %}
						{% load crispy_forms_tags %} 
						{% block content %}
								<form method ='POST' autocomplete="off">
									{% csrf_token %}
									{{ form|crispy }}
									<button type="submit">Post</button>
								</form>
							</div>
						{% endblock content %}
	  ------------
	  ------------
	  **UPDATEVIEW - związany domyślnie z plikiem <model>_form.html czyli tym samym co PostCreateView.
		Pola do przesłonięcia takie same jak w CreateView. Ponadto przy updatowaniu użytkownik powininen
		być zalogowany (LoginRequiredMixin) oraz powinno być sprawdzenie czy update robi autor postu
		(przesłoniecie metody test_func()). Dodatkowo przy kolejnym zapisie po edycji musi by przekazany
		autor postu na nowo (przesłonięcie metody form_valid).
		   A*W URLS.PY:
				*dla class-based-views w DYNAMIC URL musisz wskazać Primary Key czyli: <pk> ALBO <slug>
				*dla ścieżki 'post/<int:pk>/update/' uruchomi class-based-view utworzony we views.py. 
				*3ci arg w funkcji path to zmienna używana w linkach w plikach html 
						from .views import PostUpdateView
						urlpatterns = [
							path('post/<int:pk>/update', PostUpdateView.as_view(), name='post-update')
						...
		   B*WE VIEWS.PY 
				*wszystko tak samo jak w CreateView tylko dziedziczy po UpdateView
						from django.views.generic import UpdateView
						from .models import Post
						class PostUpdateView(UpdateView):
							model=Post
							fields =['title', 'content']				#lub pole class_form
							success_url='/about'						#lub get_success_url() 
																		#lub w models get_absolute_url()
			 ***OBOWIĄZKOWE POLA/FUNKCJE w UPDATEVIEW - takie same jak w CREATEVIEW czyli:
				*model, ew. queryset
				*fields albo class_form
				*success_url albo get_absolute_url() (models.py) albo get_success_url() + get_object()
			 ***OPCJONALNE (DOMYŚLNE) POLA/FUNKCJE z możlwiością PRZESŁONIĘCIA:
				*context_object_name -domyślnie ustawione na 'object'. Zmienna 'object' w pliku HTML
				 reprezentuję konkretny wyciągnięty obiekt z modelu/tabeli.
				*template_name - domyślnie ustawione wg składni: <model>_form.html zamiast składni 
				 <model>_<class-based viewtype>.html Dla Post: post_form.html (pole przypisujące html'a)
				*form_valid() - metoda do zwalidowania formularza przed wysłaniem
				*get_object(self) - metoda zwracająca obiekt któy jest updatowany. Teoretycznie nie 
				 musisz tego przesłaniać ale dzięki temu przesłonięciu używasz metody get_object_or_404 
				 która gdy obiekt nie istnieje zamiast błędu zwróci stronę 404:
						from django.shortcuts import get_object_or_404
						class PostUpdateView(UpdateView):
							model=Post
							fields =['title', 'content']				
							success_url='/about'				
							def get_object(self):
								my_pk = self.kwargs.get('pk')  	    #pk pobrane ze ścieżki url <int:pk>
								return get_object_or_404(Post, id=my_pk)   #musisz podać 'id' albo 'pk'
				 mając metodę get_object() możesz przesłonić get_success_url() (lub korzystać tylko z 
				 metody get_absolute_url() w MODELS.PY)
						from django.shortcuts import get_object_or_404
						from django.urls import reverse
						class PostUpdateView(UpdateView):
							model=Post
							fields =['title', 'content']				
							def get_object(self):
								my_pk = self.kwargs.get('pk')  	   
								return get_object_or_404(Post, id=my_pk) 
							def get_success_url(self):
								return reverse('post_detail', kwargs={'pk':self.get_object().id}) 
			 ***UŻYCIE LOGINREQUIREDMIXIN oraz USERPASSESTESTMIXIN (więcej: CLASS-BASED-VIEWS->MIXINS)
				*trzeba dodać możliwość edycji tylko przez użytkownika który dodał dany post. 
				 (dziedziczenie po UserPassesTestMixin oraz przesłonięcie funkcji test_func() która 
				 uruchomi UserPassesTestMixin gdy test_func() zwróci True) 
						from django.views.generic import UpdateView
						from .models import Post
						from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
						class PostUpdateView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
							model=Post
							fields=['title','content']
							#przekirowanie robisz poprzez get_absolute_url() w models.py
							def form_valid(self, form):
								form.instance.author = self.request.user
								return super().form_valid(form)
							def test_func(self):
								post = self.get_object()
								if self.request.user == post.author:
									return True 
								return False
		   C*W TEMPLATES:
				*korzystasz z tej samej strony co CreateView wg formuły nazewnictwa: <model>_form.html
				*dla Post będzie to plik post_form.html
	  ------------
	  ------------
	  **DELETEVIEW																
			A*W URLS.PY:
				*dla class-based-views w DYNAMIC URL musisz wskazać Primary Key czyli: <pk> ALBO <slug> 
				*dla ścieżki 'post/<int:pk>/delete/' uruchomi class-based-view utworzony we views.py. 
				*3ci arg w funkcji path to zmienna używana w linkach w plikach html 
						from .views import PostDeleteView
						urlpatterns = [
							path('post/<int:pk>/delete', PostDeleteView.as_view(), name='post-delete')
						...
		   B*WE VIEWS.PY
				*dziedziczy po DeleteView a domyślną strona HTML jest <model_name>_confirm_delete.html
			 ***OBOWIĄZKOWE POLA/FUNKCJE w UPDATEVIEW:
				*model, ew. queryset
				*success_url (get_absolute_url() z models nie zadziała tutaj gdyż nie da się zrobić
				 przekierowania na DetailView obiektu który wlaśnie został usunięty)
						from django.views.generic import DeleteView
						from .models import Post
						class PostDeleteView(DeleteView):
							model=Post
							success_url = '/blog/about/'
				*get_success_url(self) - zamiast succes_url. Też tylko statyczne przejście:
						from django.urls import reverse
						class PostDeleteView(DeleteView):
							model=Post
							def get_success_url(self):
								return reverse('blog:article-list' ) 
			 ***OPCJONALNE (DOMYŚLNE) POLA/FUNKCJE z możlwiością PRZESŁONIĘCIA:
				*context_object_name -domyślnie ustawione na 'object'. Zmienna 'object' w pliku HTML
				 reprezentuję konkretny wyciągnięty obiekt z modelu/tabeli.
				*template_name - domyślnie ustawione wg składni: <model>_confirm_delete.html zamiast 
				 składni <model>_<class-based viewtype>.html Dla Post: post_confirm_delete.html
				*form_valid() - metoda do zwalidowania formularza przed wysłaniem
				*get_object(self) - metoda zwracająca obiekt któy będzie usuwany. Teoretycznie nie 
				 musisz tego przesłaniać ale dzięki temu przesłonięciu używasz metody get_object_or_404 
				 która gdy obiekt nie istnieje zamiast błędu zwróci stronę 404:
						from django.views.generic import DeleteView
						from .models import Post
						class PostDeleteView(DeleteView):
							model=Post
							success_url = '/blog/about/'
							def get_object(self):
								my_pk = self.kwargs.get('pk')  	    #pk pobrane ze ścieżki url <int:pk>
								return get_object_or_404(Post, id=my_pk)   #musisz podać 'id' albo 'pk'
			 ***UŻYCIE LOGINREQUIREDMIXIN oraz USERPASSESTESTMIXIN (więcej: CLASS-BASED-VIEWS->MIXINS):
				*tak jak przy CreateView oraz przy UpdateView trzeba dodać możliwość usuwania tylko 
				 przez użytkownika który jest zalogowany i dodał dany post - klasa PostDeleteView będzie
				 dodatkowo dziedziczyć po LoginRequiredMixin i po UserPassesTestMixin. Ponadto trzeba 
				 przesłonić test_func() która uruchomi UserPassesTestMixin gdy funkcja zwróci True. 
						from django.views.generic import DeleteView
						from .models import Post
						from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
						class PostDeleteView(LoginRequiredMixin,UserPassesTestMixin,DeleteView):
							model=Post
							success_url = '/blog/about/'
							def test_func(self):
								post = self.get_object()
								if self.request.user == post.author:
									return True 
								return False
		   C*W TEMPLATES
				*domyślnie plik wg schematu <model>_confirm_delete.html ex:  post_confirm_delete.html 
				*tworzysz formularz bez formularza - tylko potwierdzasz operację usunięcia ale do tego 
				 potrzebujesz zmiennej {% csrf_token %} oraz button'u submit 
				*operujesz na 'object' który zwraca konkretny rekord w tabeli. 
						{% extends "blog/base.html" %}
						{% block content %}
							<form method ='POST'>
								{% csrf_token %}
								<h2>Are you sure you want to delete the post "{{ object.title}}"</h2>
								<button type="submit">Yes, Delete</button>
								<a href="{% url 'post-detail' object.id %}">Cancel</a>
							</form>
						{% endblock content %}
						
	c)*MIXINS:
	  **PODSTAWY:
		*dają możliwość rozszerzania naszego class-based-view o dodatkowy kod
		*pozwalają przy pomocy dziedziczenia uniknąc redundacji w innych class-based-views i korzystać
		 z pól i funkcji zawartych w Mixins:
						#dla urls.py: path('<int:pk>/', CourseDetailView.as_view(), name='course_detail')
						from .models import Course
						class CourseObjectMixin(object):
							model = Course
							def get_object(self):
								id = self.kwargs.get('pk')
								obj=None
								if id is not None:
									obj=get_object_or_404(self.model, id=id)
								return obj
						class CourseDetailView(CourseObjectMixin, View):
							template_name = 'courses/course_detail.html'
							def get(self, request, pk=None, *args, **kwargs):       
								context={}
								if pk is not None:
									obj=self.get_object() 
														  #zamiast obj = get_object_or_404(Course, id=pk)
									context = {'object':obj}
								return render(request, self.template_name, context)
	  --------------------
	  **LOGINREQUIREDMIXIN
		*klasa używana w class-based-views do dziedziczenia gdy chcesz by uruchomienie class-based-views
		 było uzależnione od zalogowania użytkownika (niezalogowany użytkownik nie uruchomi danego
		 class-based-view). Dla Function-Based-Views użyłbyś dekoratora @loginrequired ale dla klasy 
		 trzeba użyć dziedziczenia. 
		*dziedziczenie LoginRequiredMixin musi być po skrajnie lewej stronie żeby działało:
						from django.views.generic import CreateView, UpdateView, DeleteView
						from django.contrib.auth.mixins import LoginRequiredMixin
						class PostCreateView(LoginRequiredMixin, CreateView):
							model=Post
						class PostUpdateView(LoginRequiredMixin, UpdateView):
							model=Post
						class PostDeleteView(LoginRequiredMixin, DeleteView):
							model=Post

	d)*PORÓWNANIE FUNCTION-BASED-VIEWS z RAW CLASS-BASED-VIEWS z CLASS-BASED-VIEWS
	  ----------
	  **PODSTAWY
		*RAW class-based-view to widok przejściowy dziedziczący po klasie View z paczki django.views
		 Jego największą zaletą jest możliwość stworzenia widoku któy może wysłać dane przez słownik
		 wykorzystując metodę render()
		*Raw class-based-view opiera się na przesłonięciu metody 'get(self, request, *args, **kwargs)' 
		 i/lub 'post(self, request, *args, **kwargs)'. 
		*W danym class-based-view np.:CreateView gdy ustawiasz pola klasowe to są one wykorzystywane w 
		 metodach odziedziczonych od View ( get() i post() ) 
		*W docelowych class-based-views (<model_name>CreateView, <model_name>DetailView ...)  gdy 
		 ustawiasz pola klasowe to są one wykorzystywane w metodach odziedziczonych od widoków z paczki 
		 generics tj: CreateView, DetailView ... (metody takie jak: get_success_url(), is_valid() ...)
		*W docelowych class-based-views (<model_name>CreateView, <model_name>DetailView ...) możesz 
		 przesłaniać metody get() i post() ale wtedy musisz stworzyć wariant class-based-views 
		 praktycznie taki sam jak przy RAW CLASS-BASED-VIEWS -> patrz pkty B)
	  ----------
	  **LISTVIEW
			A)FUNCTION-BASED-VIEW (zamiast class-based views)
				*dla urls.py: path('post/', post_list_view, name='post-list')
						from django.shortcuts import get_list_or_404
						from .models import Post
						def post_list_view(request):
							queryset = get_list_or_404(Post)
							context={'object_list':queryset}
							return render(request, "courses/post_list.html", context)
			B)RAW CLASS-BASED-VIEW:
				*dla urls.py: path('post/', PostListView.as_view(), name='post-list')
						from django.shortcuts import render 
						from .models import Post
						class PostListView(View):
							template_name = 'post/post_list.html'
							def get(self, request, *args, **kwargs):
								obj_lst=Post.objects.all()
								context={'object_list': obj_lst}
								return render(request, self.template_name, context) 
			C)FINAL CLASS-BASED-VIEW (basic)
				*dla urls.py: path('post/', PostListView.as_view(), name='post-list')
						from .models import Post
						from django.views.generic import ListView
						class PostListView(ListView):
							model=Post	
	  -------------
	  **DETAILEVIEW
			A)FUNCTION-BASED-VIEWS (zamiast class-based views)
				*dla urls.py: path('post/<my_id>/', post_detail_view, name='post-detail')
						from django.shortcuts import get_object_or_404
						from .models import Post
						def post_detail_view(request, my_id):
							obj = get_object_or_404(Post, id=my_id)
							context={'object':obj}
							return render(request, "post/post_detail.html", context)
			B)RAW CLASS-BASED-VIEWS:
				*dla urls.py: path('courses/<int:pk>/', PostDetailView.as_view(), name='post-detail') 
						from ,models import Post
						class PostDetailView(View):
							template_name = 'post/post_detail.html'
							def get(self, request, pk=None, *args, **kwargs):       
								context={}
								if pk is not None:
									obj = get_object_or_404(Post, id=pk)
									context = {'object':obj}
								return render(request, self.template_name, context)
			C)FINAL CLASS-BASED-VIEWS:
				*dla urls.py: path('post/<int:pk>/', PostDetailView.as_view(), name='post-detail') - w 
				 class-based-views w urls.py w dynamic url możesz używać tylko 'pk' (a nie własnej np: 
				 my_id) ponieważ pole pk_url_kwarg w PostView jest domyślnie ustawione na 'pk' 
						from .models import Post
						from django.views.generic import DetailView
						class PostDetailView(DetialView):
							model=Post	
	  ------------
	  **CREATEVIEW
			A)FUNCTION-BASED-VIEWS (zamiast class-based views)
				*dla urls.py: path('post/new/', post_create_view, name='post-create')
						from django.contrib.auth.decorators import login_required
						from django.urls import reverse
						from django.shortcuts import render, redirect
						@loginrequired
						def post_create_view(request):
							if request.method != 'POST':					#dla request.method == 'GET'
								initial_Data={'title':'awesome title'}
								form_empty = PostCreateForm(initial=initial_Data)
								context = {'form':form_empty}
								return render(request, "posts/post_create.html",context)
							else:       									#if request.method =='POST':
								form_with_data = PostCreateForm(request.POST)
								if form_with_data.is_valid():
									form_with_data.save()
									context={'my_id':form_with_data.instance.id}
									return redirect(reverse('post-detail', kwargs=context))
								else:
									context = {'form':form_with_data}
									return render(request, "posts/post_create.html",context)
			B)RAW CLASS-BASED-VIEWS:
						from django.views import View
						from django.shortcuts import get_object_or_404, render
						from .models import Post
						from .forms import PostCreateForm
						class PostCreateView(View):
							template_name = "post/post_form.html"
							def get(self, request, *args, **kwargs):
								form = PostCreateForm()
								context ={'form': form} 
								return render(request, self.template_name, context)
							def post(self, request, *args, **kwargs): 
								form = PostCreateForm(request.POST)
								if form.is_valid():
									form.save()
									return redirect(reverse('courses:post_detail', kwargs=
																				{'pk':form.instance.id}))
								context ={'form':form}  
								return render(request, self.template_name, context)	
			C)FINAL CLASS-BASED-VIEWS:
				*dla urls.py: path('post/new/', PostCreateView.as_view(), name='post-create')
				*przy metodzie redirect z poprzedniego punktu musiałbyś w kwargs podac klucz 'pk' zamiast
				 'my_id' gdyż class-based-view wykorzystuję z models.py metodę get_absolute_url() która 
				 wykorzystuję klucz 'pk' ze względu na domyślne pole pk_url_kwarg='pk' w DetailView 
						from .models import Post
						from django.views.generic import CreateView
						from .forms import PostCreateForm
						class PostListView(ListView):
							model=Post	
							form_class=PostCreateForm
							#w models przesłonieta metoda get_absolute_url() (przekierowanie na nią)
	  ------------
	  **UPDATEVIEW
			A)FUNCTION-BASED-VIEWS (zamiast class-based views)
				*dla urls.py: path('post/<my_id>/update', post_update_view, name='post-update')
						from django.contrib.auth.decorators import login_required
						from django.urls import reverse
						from django.shortcuts import render, redirect, get_object_or_404
						@loginrequired
						def post_update_view(request, my_id):
							obj = get_object_or_404(Post, id=my_id)
							if request.method != 'POST':						#dla request.method == 'GET'
								form_with_initial_data = PostCreateForm(instance=obj)
								context = {'form':form_with_initial_data}
								return render(request, "posts/post_create.html",context)
							else:       										#if request.method =='POST':
								form_with_updated_data = PostCreateForm(request.POST, instance = obj )
								if form_with_updated_data.is_valid():
									form_with_updated_data.save()
									context={'my_id':form_with_updated_data.instance.id}
									return redirect(reverse('post-detail', kwargs=context))
								else:
									context = {'form':form_with_updated_data}
									return render(request, "posts/post_create.html",context)
			B)RAW CLASS-BASED-VIEWS:
				*dla urls.py: path('post/<int:pk>/update', PostUpdateView.as_view(), name='post-update')
						from django.views import View
						from django.shortcuts import get_object_or_404, render
						from .models import Post
						from .forms import PostCreateForm
						class PostUpdateView(View):
							template_name = "courses/course_form.html"
							def get(self, request,pk=None, *args, **kwargs):
								form = PostCreateForm()
								if pk is not None:
									obj = get_object_or_404(Post, id=pk) 
									form= PostModelForm(instance=obj)
								context ={'form': form} 
								return render(request, self.template_name, context)
							def post(self, request, pk=None, *args, **kwargs): 
								context={}
								if pk is not None:
									form = PostCreateForm(request.POST, 
																instance=get_object_or_404(Post, id=pk))
									if form.is_valid():
										form.save()
										return redirect(reverse('post_detail', 
																		kwargs={'pk':form.instance.id}))
									context ={'form':form}  
									return render(request, self.template_name, context)
			C)FINAL CLASS-BASED-VIEWS:
				*dla urls.py: path('post/<int:pk>/update', PostUpdateView.as_view(), name='post-update')
				*W class-based-views w urls.py nie mógłbyś używać nazwy 'my_id' (tak jak w powyżej) 
				 tylko 'pk' (ponieważ pole pk_url_kwarg w DetailView jest domyślnie ustawione na 'pk')
				*W redirect'cie też musiałbyś zmienić nazwy z 'my_id' na 'pk' ponieważ w ścieżce URL 
				 masz wpisany dynami url w postaci 'pk'
						from django.views.generic import UpdateView
						from .models import Post
						from .froms import PostCreateForm
						class PostUpdateView(UpdateView):
							model = Post
							form_class = PostCreateForm
							#w models przesłonieta metoda get_absolute_url() (przekierowanie na nią)
	  ------------
	  **DELETEVIEW
			A)FUNCTION-BASED-VIEWS (zamiast class-based views)
				*dla urls.py: path('post/<my_id>/delete', post_delete_view, name='post-delete')
				*OPCJE USUWANIA:
				   A*USUWANIE poprzez GET REQUEST (tylko poprzez link bez strony html)
						from django.contrib.auth.decorators import login_required
						#musiałbyś dodać jeszcze dekorator który sprawdzałby czy usuwa właściciel postu 
						@login_required
						def post_delete_view(request, my_id):
							obj = get_object_or_404(Post, id=my_id)
							obj.delete()
							return redirect("home")
				   B*USUWANIE poprzez POST REQUEST (czyli z potwierdzeniem przez stronę html)
						from django.contrib.auth.decorators import login_required
						#musiałbyś dodać jeszcze dekorator który sprawdzałby czy usuwa właściciel postu 
						@login_required
						def post_delete_view(request, my_id):
							obj = get_object_or_404(Post, id=my_id)
							if request.method != 'POST':					#if request.method == 'GET'
								context ={"object":obj}
								return render(request, "posts/post_confirm_delete.html", context)
							else:   										#if request.method == 'POST'
								obj.delete()
								return redirect("home")
			B)RAW CLASS-BASED-VIEWS:
				*dla urls.py: path('post/<int:pk>/delete', PostDeleteView.as_view(), name='post-delete')
						from django.views import View
						from django.shortcuts import get_object_or_404, render
						from .models import Post
						class PostDeleteView(View):
							template_name = "post/post_form.html"
							def get(self, request, pk=None, *args, **kwargs):
								obj = get_object_or_404(Post, id=pk) 
								context ={'object': obj} 
								return render(request, self.template_name, context)
							def post(self, request, pk=None, *args, **kwargs): 
								obj= get_object_or_404(Post, id=pk)
								context={}
								if obj is not None:
									obj.delete() 
									return redirect('/')
								return render(request, self.template_name, context)
			C)FINAL CLASS-BASED-VIEWS:
				*dla urls.py: path('post/<int:pk>/delete', PostDeleteView.as_view(), name='post-delete')
				*W class-based-views w urls.py nie mógłbyś używać nazwy 'my_id' (tak jak w powyżej) 
				 tylko 'pk' (ponieważ pole pk_url_kwarg w DetailView jest domyślnie ustawione na 'pk')
						from django.views.generic import DeleteView
						from .models import Post
						class PostDeleteeView(DetleteView):
							model = Post
							succes_url= '../'
							
4. PODSTAWOWE MODUŁY i FOLDERY w APP/FUNCKJONALNOŚCIACH:
	*1*module MODELS.PY 
		*https://docs.djangoproject.com/en/4.0/intro/overview/#design-your-model
		1*PODSTAWY:
		   A*Django ma własny wbudowany ORM (Object-Relational Mapping), który zamienia utworzone obiekty 
		     na bazy danych (na konkretne encje/tabele) oraz pozwala na automatyczne generowanie instrukcji
			 sql.Dzięki temu możesz używać różnych baz danych (SQLite, POSTGREsql) bez konieczności zmiany 
			 kodu. A gdy chcesz już podłączyć konkretną bazę danych to zmieniasz w ustawieniach z którą 
			 chcesz się podłączyć (czy z PostgreSQLem czy MySqlem).
		   B*Users (użytkownicy) mają osobną baze danych więc w models.py zamiast budowania jej możesz ją
			 tylko modyfikować. Gdybyś chciał użyć tej tabeli użytkowników jako klucz obcy w innej tabeli
			 to musisz ją zaimportować z django.contrib.auth.models:
							from django.contrib.auth.models import User
							from django.db import models
							class Post(models.Model):
								author = models.ForeignKey(User, on_delete = models.CASCADE)
		   C*po każdej zmianie w models i po każdym działaniu w ORMie rób migrację:
							Python manage.py makemigrations
							Python manage.py migrate
		   D*póżniej taką klasę/tabelę możesz zarejestrować w pliku admin.py w danej app/funckjonalności i 
			 zarządzać tą tabelą ze strony administracyjnej --> WIĘCEJ patrz pkt5.STRONA ADMINISTRATORA 
		2*BUDOWA:
		   X*PODSTAWY - models.Model (from django.db import models) - bazy danych/tabele (dzieki Django ORM)
			 są reprezentowane poprzez klasy zwane 'models' a każdy atrybut reprezentuję pole w tabeli. 
			 Klasy/modele dziedziczą po klasie Model.
							from django.contrib.auth.models import User
							from django.db import models
							from django.utils import timezone
							class Post(models.Model):
								title=models.CharField(max_length=100)
								content = models.TextField() 
								date_posted = models.DateTimeField(default = timezone.now)
								author= models.ForeignKey(User, on_delete=models.CASCADE)
								def __str__(self):
									return self.title	
		   A*RELACYJNE TYPY PÓL W OBIEKCIE:
				*RELACJE - przy relacjach definuiujesz relację tylko w jednej klasie - tej 'ważniejszej'.
				 Nie definiujesz ich w dwóch modelach (tj że w klasie Participant masz relacje 'wiele do 
				 wiele' z klasą Meetup a w Meetup masz relacje 'wiele do wiele' z Participant). W ten 
				 sposób w pole relacyjne zdefiniowane będzie widoczne tylko w klasie w której było
				 zdefiniowane.
				*PARAMETRY DLA RELACYJNYCH TYPÓW PÓL:
					**on_delete=models.CASCADE - parametr który każe usunąć wszystkie obiekty powiązane z
					  obiektem będącym kluczem obcym,(tj ten w argumencie pola)gdy ten zostanie usunięty.
					  Dotyczy tylko relacji  '1 do 1' i '1 do wiele'. Nie dotyczy relacji 'wiele do wiele'
							#dla Profile - profil zostanie usunięty gdy User zostanie usunięty
								class Profile(models.Model):	
									user = models.OneToOneField(User, on_delete =models.CASCADE)
							#dla Post - wszystkie posty Usera zostają usunięte gdy User zostanie usunięty
								class Post(models.Model):
									author = models.ForeignKey(User, on_delete =models.CASCADE)
					**on_delete=SET_NULL - parametr który każe wpisać null w momencie usunięcia powiązanego 
					  obiektu będącego kluczem obcym (tj argumentem w nawiasach). Dotyczy wszystkich relacji:
					  Przy tym polu musi istnieć inne pole gdzie zezwalasz na nulle dla kolumny: null=True
							#pole user w klasie Profile przyjmie NULL gdy obiekt User zostanie usunięty
								class Profile(models.Model):
									user = models.OneToOneField(User, on_delete=models.SET_NULL, null=True)
							#pole author w klasie Post przyjmie NULL gdy obiekt User zostanie usunięty
								class Post(models.Model):
									author = models.ForeignKey(User, on_delete =models.SET_NULL, null=True)
							#pole participants w klasie Meetup przyjmie NULL gdy wszystkie obiekty
							#Participant mające odwołanie do Meetup zostaną usunięte.
								class Meetup(models.Model):
									participants = models.ManyToManyField(Participant, null=True,
																	on_delete =models.SET_NULL, null=True)
				****RELATIONSHIP ONE_TO_ONE:		
					*models.OneToOneField(nazwaTabeli) - pole w relacji 1:1. np 1 User może być związany 
					 z 1 profilem oraz 1 profil może być związany z 1 Userem. W ten sposób profil jest 
					 rozszerzeniem klasy użytkownika (User) bez użycia dziedziczenia. 
								from django.db import models
								from django.contrib.auth.models import User
								class Profile(models.Model):
									user=models.OneToOneField(User, on_delete=models.CASCADE)
									...
				****RELATIONSHIP ONE_TO_MANY:
					*models.ForeignKey(nazwaTabeli) - pole w relacji 1 do wiele gdzie jeden jest jako ten
					 wewnątrz argumentu czyli pole Rodzica. Pole o kluczu w innej tabeli (czyli ForeignKey).				
								from django.db import models
								from django.contrib.auth.models import User
								class Post(models.Model):
									author = models.ForeignKey(User, on_delete.CASCADE)
									...
					*użycie ograniczonej listy stringów/obiektów:
						*atrybut choices w models.CharField()
								from django.db import models
								from django.contrib.auth.models import User
								class Order(models.Model):
									STATUS = (
										('Pending','Pending'),
										('Out of delivery','Out of delivery'),
										('Delivered','Delivered'),
									)
									status = models.CharField(max_length=200, null=True, choices = STATUS)
						*utworzenie pliku validators.py wraz z ograniczoną listą stringów i wyrzucenie 
						 wyjątkiem ValidationError gdy wpisane hasło przy tworzeniu obiektów nie znajduję 
						 się w liście:
						 #https://docs.djangoproject.com/en/4.0/ref/validators/
								from django.core.exceptions import ValidationError
								my_lst = ['pdf','doc','svg']
								def validate_MY(value):
									if value not in my_lst:
										raise ValidationError(f'{value} is not in list')
							*wewnątrz models.py
								from django.db import models
								from . import validators.py
								class Post(models.Model):
									extension = models.CharField(max_length=50, validators = [validate_MY]
									...
				****RELATIONSHIP MANY_TO_MANY:
					*models.ManyToManyField(nazwaTabeli) - pole w relacji 'wiele do wiele'. Nie trzeba 
					 podawać w dwóch klasach tego pola wiele do wiele ale można -> wtedy w klasie 
					 znajdującej się wyżej w argumencie pola ManyToManyField wpisujesz nazwę modelu/klasy 
					 w cudzysłowiu
								from django.db import models
								class Participant(models.Model):
									email=models.EmailField(unique=True)
								class Meetup(models.Model):
									name=models.CharField(max_length=200)
									participants = models.ManyToManyField(Participant, null=True,
																			on_delete =models.SET_NULL)
		   B*ZWYKŁE TYPY DANYCH konkretnych pól w obiekcie:
				*https://docs.djangoproject.com/en/4.0/ref/models/fields/#model-field-types
				*ATRYUBTY DO KAŻDEGO RODZAJU POLA:
					**blank=True - w adminie pole może być puste (wypełnienie pustym stringiem)
								description = models.TextField(blank=True)
					**null=True  - pole gdy nie zostanie wypełnione będzie nullem (występuję z blank=True)
								description = models.TextField(null=True, blank=True)
					**default='...' - domyślna wartość
								summary = models.TextField(default='This is cool')
					**unique=True 
								slug = SlugField(unique=True)			 
				*models.ImageField(upload_to="my_folder") 
					**WIĘCEJ patrz: PODSTAWY -> 6.ELEMENTY ROZSZERZONE -> 2)UPLOADOWANE ZDJĘCIA
					**upload_to='folder' -wskazanie nazwy folderu do przechowywania uploadowanych plików
								img = models.ImageField(upload_to="my_folder")
								#pip install PILLOW + makemigrations + migrate
								#w urls.py +static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
				*models.SlugField(unique=True) - pole używane w Dynamic URLS zamiast pk/id
					**unique=True -każdy slug musi być unikalny tak jak unikalny jest pk/id:
								slug = SlugField(unique=True)
					****automatyczne tworzenie w SlugField poprzez przesłonięcie metody save():
					    *ogólne podejście:
								import random
								from django.utils.text import slugify
								...
									slug = models.SlugField(unique=True, null=True, blank=True)
									def save(self):
										slug = f'{slugify(title)}-{random.randint(30000-40000)}'
										super().save()
				*models.Charfield() - pole typu CHAR 
					**max_length=100 - musisz dodać parametr ograniczający max długość (parametr wymagany)
								title = models.CharField(max_length=100)
				*models.TextField() - pole typu text (bez ograniczenia w max długości)
								content = models.TextField()
					**default='...' - parametr domyślnego tekstu
								content = models.TextField(default='This is cool')
				*models.DecimalField() - pole dla liczb
					**decimal_places=2 - miejsca po przecinku (paramter wymagany)
					**max_digits=10000  - maksymalna liczba cyfr (paramter wymagany)
								price = models.DecimalField(decimal_places=2, max_digits=1000)
				*models.BooleanField() - flaga True albo False
								flaga = models.BooleanField()
				*models.DateTimeField() - pole typu data i czas
					**auto_now=True - możesz dodać parametr który będzie generował automatycznie czas 
					    zawsze podczas edycji obiektu.
								date-posted = models.DateTimeField(auto_now=True)
					**auto_now_add= True - możesz dodać parametr który będzie generował automatycznie czas
						zawsze przy pierwszym tworzeniu obiektu. Nie daję to możliwości modyfikacji
								date-posted = models.DateTimeField(auto_now_add=True)
					**default=timezone.now - automatycznie generuję czas przy tworzeniu obiektu ORAZ daję
						możliwośc modyfikacji czasu. 
							from django.utils import timezone
								...
								date-posted = models.DateTimeField(default=timezone.now)	 
															#nie dajesz nawiasów na końcu metody now, gdyż 
															#nie chcesz jej wywoływać tylko jej referencje
		   C*METODY:
				*metoda __str__() - metoda magiczna która ma zwrócić tytuł posta w momencie gdy będzie 
				 wywoływany z bazy danych w shellu (python manage.py shell) poprzez:
							Post.objects.all()				#zwróci:  <QuerySet [<Post: Title1>]>
															#zamiast: <QuerySet [<Post: Post object (1)>]>
						#w models.py:
							def __str__(self):
								return self.title
				*metoda save() - wykorzystywana podczas zapisu obiektu (m.in przy formularzu tworzącym
				 obiekt). Mozna ją przesłonić:
					*autouzupełnianie pola SlugField (metoda slugify):
							from django.utils.text import slugify
							class MyClass(models.Model):
								title= models.CharField(max_length=120, unique=True)
								slug = models.SlugField(unique=True, null=True, blank=True)
								def save():
									slug = slugify(title)
									super().save()
				*metoda get_absolute_url() wykorzystująca reverse():
					*CELE:
						*służy do zwrócenia obiektu w tabeli/modelu przy dynamicznych linkach w HTMLu:
						 ZAMIAST: 		<a href = "{% url 'product-detail' another_object.id %}">...</a> 	
						 MOŻESZ UŻYĆ:	<a href = "{{ another_object.get_absolute_url }}">...</a>
						 Przydaję się to przede wszystkim przy przechodzeniu przez listę obiektów 
						 przekazanych w słowniku przez 3 arg. metody render wewnątrz pliku html: 
							{% for obj in my_objects %}
								<a href = "{{ obj.get_absolute_url }}">Link nr:{{ obj.id }}</a>
							{% endfor %}
						*służy do przekierowania na podstronę z nowo-utworzonym/zupdatowanym obiektem 
						 w class-based-view DetailView po stworzeniu/zupdatowaniu go w tabeli/modelu przy 
						 PRZESŁANIU FORMULARZA z class-based-views: CreateView lub UpdateView. Stosujesz 
						 to zamiast przesłaniać pole success_url w danym class-based-view ze zmienną w 
						 linku. (WIĘCEJ W CLASS-BASED-VIEWS CreateView lub UpdateView)
						*we views możesz stosować przy metodzie redirect():
							...
							return redirect(obj.get_absoulute_url())
					*BUDOWA:
						*możesz stworzyć ją by bezpośrednio podawała dynamiczną ścieżkę do modelu/tabeli:
							def get_absolute_url(self):
								return f"/products/{self.id}"
						*lub wykorzystać reverse() i podać 3arg metody path z urls.py (taka jest praktyka):
							def get_absolute_url(self):
								return reverse('product-detail', kwargs={'pk':self.pk})	
						*gdy linki masz w urls.py w danej app/funkc. zamiast w głównej app/funkc. to 
						 tworząc zmienną app_name = <app_name> w urls.py danej app/funkc. przy podawaniu
						 nazwy 3arg funkcji path w urls.py musisz podać jeszcze to app_name przed nazwą 
						 tej zmiennej: 
							def get_absolute_url(self):
								return reverse('products:product-detail', kwargs={'pk':self.pk})	
		   D*KLASA WEWNĘTRZNA META-  (przy zwracaniu danych przy konstrukcjach ORM-owych):
				*pole ordering = dla zwracanych danych ustala kolejność zwracania wg danego pola
					class MyModel(models.Model):
						updated = models.DateTimeField(auto_now=True)
						created = models.DateTimeField(auto_now_add = True)
						class Meta:
							ordering = ['-updated']					#'-' oznacza w koleścnosic malejącej 
		   E*ROZSZERZENIE:
				*Gdy do modelu dodasz nowe pole lub zmienisz wartość pola z 'null=True' na 'null=False' to
				 wystarczy że zrobisz komendy makemigrations i migrate. W przypadku zgrzytów django daje
				 ci możliwość uzupełnienia nieistniejących wcześniej pól w istniejących wcześniej obiektach. 
				*ZESTAW DANYCH WYCIĄGNIĘTY PRZEZ ORM DJANGO --> patrz we: 3.ORM DJANGO 
				*TWORZENIE OBIEKTÓW I ZAPISYWANIE ICH W BAZIE DANYCH przez ORM DJANGO --> 3.ORM DJANGO 
	*2*katalog MIGRATIONS 
		1*PODSTAWY:
			*w katalogu MIGRATIONS są przechowywane 'migracje' które są zrzutami historii wszystkich 
			 operacji tworzenia i modyfikacji klas reprezentujących tabele w bazie danych od ostatniego 
			 użycia komendy makemigrations. Klasy te znajdują się w pliku models.py.
			*Wewnątrz pliku migracji zobaczysz że dana migracja zależy od poprzedniej (zmienna dependencies)
			 dzięki czemu można zauważyć historyczne przejście do pierwszej migracji, widząc dokładnie co 
			 się działo po drodze.
		2*KOMENDY związane z katalogiem MIGRATIONS:
			*Migracja (która będzie wszystkimi zmianami na klasach w pliku models.py) tworzysz poprzez:
							python manage.py makemigrations
			*By podejrzeć jaka instrukcja sql zostaną wytworzone podczas komendy migrate w danej migracji 
			 możesz podejrzeć poprzez komendę sqlmigrate podając za nią argumenty w postaci nazwy 
			 aplikacji/funkcjonalnosci oraz numeru który jest na początku pliku danej migracji.
							python manage.py sqlmigrate blog 0001
			*By dokonać MIGRACJI z plików migracji (wszystkich plików migracji) do pliku danej bazy danych 
			 (domyślnie dla sqlite db.sqlite3) użyj instrukcji:
							python manage.py migrate 
		3*SKASOWANIE WSZYSTKICH MODELI:
			*sksauj te migracje których nie chcesz - nie wolno ci skasować migracji '__init__.py'
			*skasuj bazę danych - po następnych kroku zostanie utworzona nowa 
			*python manage.py makemigrations  +  python manage.py migrate
							
	*3*module URLS.PY (instrukcja w urls.py w głównej app/funkc.):
		*https://docs.djangoproject.com/en/4.0/intro/overview/#design-your-urls
		**URLS.PY TYLKO W GŁÓWNEJ APP/FUNKC.:
			*JEZELI WIESZ ŻE TWOJA STRONA BĘDZIE MIAŁA PODSTRONY DLA DANEJ APP/FUNKCJONALNOŚCI to tworzysz
 			 moduł urls.py w swojej app/funkcjonalności (moduł urls.py nie powstaje automatycznie przy 
			 tworzeniu nowej app/funkcjonalnośći - trzeba go stworzyć samemu)
			*musisz zaimportować module django.urls oraz module views(ten poniżej) 
			*możesz ale nie musisz stworzyć zmienną app_name. Taka zmienna ma za zadanie uporządkować 
			 bardziej nazwy zmiennych w ścieżkach tj 3cie argumenty funkcji path. Jeżeli stworzysz tę 
			 zmienną to będziesz musiał w templatesach w plikach html w linkach przed podaniem 3ciego arg
			 zmiennej path z urls.py wypisać nazwę tej zmiennej:	
			 ### w htmlu:		<a href="{% url 'products:product_detail' %}">LINK</a>
			*musisz stworzyć URLconf tworząc listę 'urlpatterns' (koniecznie tak nazwaną bo django będzie 
			 tego szukał) i wpisać w nią obiekty typu 'URLpattern' za pomocą funkcji path(), którą 
			 zaimportowałeś z django.urls:
					#aplikacja/funkcjonalonośc o nazwie blog
					from django.urls import path
					from . import views		#kropka oznacza: 'z folderu rodzica' 
											#(czyli tego samego w którym się znajduję) 
					#app_name='blog'		#możesz ale nie musisz tworzyć tej zmiennej. Jeżeli ją
											#stworzysz to w templates'ach w linkach wykorzystując 3ci 
											#argument zmiennej path(poniżej) będziesz musiał dodatkowo 
											#podać wartość tego app_name (patrz linki w HTMLu)   
					urlpatterns = [								#URLConf (URL configuration)
						path('hello/', views.says_hello, name='blog-hello')
					]			#path() zwraca obiekt typu URLpattern. Przyjmuję w argumencie ścieżkę 
								#względną pod którą będzie wyświetlać się funkcja podana w 2gim argumencie
								#pochodząca z katalogu views. Ścieżka ta nie ma zawierać nazwy 
								#folderu/aplikacji gdyż ten podamy w urlpatterns w urls.py w głównym
								#katalogu projektu.
										#trzeci argument (w postaci name) jest dodatkowy ale specjalnie go 
										#podajesz gdyż w templates w plikach html w linkach (<a href="...">)
										#zamiast podawania konkretnego linka podasz wartość tego argumentu
										#dzieki czemu gdybyś chiał zmienić tenże link to robisz to w 
										#pierwszym argumencie metody path zamiast w dwóch miejscach na raz
										#czyli w metodzie path i w pliku HTML. (-->patrz linki w templates)
					  ##path('', views.says_hello)	#say_hello z modułu views mógłbyś też wywołać dla 
													#pustej 2giej cześci linka tj wyświetlałoby się dla 
													#linka z nazwą app/funkcjonalności tj:
													#http://127.0.0.1:8000/blog zamiast powyższego 
													#http://127.0.0.1:8000/blog/hello
			*następnie musisz zaimportować cały ten moduł do głównego URLConf (URL configuration który 
			 znajduję się w głównym folderze projektu w module URLS.PY. Wenwnątrz tego moduły urls.py z 
			 głównego katalogu projektu musisz zaimportować metody include i path z django.urls ORAZ dodać 
			 do tamtejszej listy urlpatterns obiekt URLpattern poprzez funkcje path z 1wszym argumentem w 
			 postaci ścieżki/nazwy_folderu_projektu oraz drugim w postaci funkcji include z argumentem 
			 który będzie ścieżką do pliku urls.py w katalogu naszej funkcjonalnośći(aplikacji) nazwanym 
			 tak jakby to była funkcja w module: 'nazwa_katalogu.urls':
					from django.urls import include, path
					urlpatterns =[
						... ,
						path('blog/', include('blog.urls'))
					]
			*od teraz pod ścieżką: http://127.0.0.1:8000/blog/hello będzie wyświetlać się twoja podstrona.
		**URLS.PY W POZOSTAŁYCH APP/FUNKC.:
			*JEŻELI WIESZ ŻE TWOJA STRONA NIE BĘDZIE MIAŁA ŻADNYCH PODSTRON DLA DANEJ APP/FUNKCJONALNOŚCI 
			 to nie musisz tworzyć wewnątrz app/funkcjonalności modułu urls.py. (np strona do rejestracji 
			 (patrz formularz do rejestracji))
			*Całe przekierowanie na plik views.py app/funkcjonalności zrobisz w głównej app/funkcjonalności
			 w pliku urls.py w liście urlpatterns.
			*importujesz moduł views ze swojej app/funkcjonalności (blog) i w liście urlpatterns dodajesz 
			 ścieżkę ('hello/') która będzie wskazywać na moduł views w app/funkc. blog:
							#plik urls.py w app/funkcjonalności django-project
							from blog import views
							urlpatterns = [							
								...
								path('hello/', views.says_hello, name='blog-hello')
							]
			*ponieważ z innych app/funkcjonalnośći też możesz importować moduł views.py dlatego przypisz 
			 alias wg schematu: nazwaAppFunkcjonalności_views:
							from users import views as users_views
							urlpatterns = [					#poniżej odwołanie do metody register w 
								...							#module views w app/funkcjonalności users
								path('register/', users_views.register, name = 'register'),
							]
		**REDIRECTVIEW
			*RedirectView.as_view() - dla danej ścieżki przeniesienie na inną ścieżkę:
							from django.views.generic.base import RedirectView
							urlpatterns = [
								path('', RedirectView.as_view(url='/meetups')),
								path('meetups/', include('meetups.urls')),
							]
		**DYNAMIC URLS:
			*DYNAMIC URLS skrót - zmienne w linkach przekazujesz do views poprzez argumenty:
				*w urls.py:	 	path('articles/<int:year>/<int:month>/<int:pk>/', 
				*w views.py:	news.views.article_detail(request, year=2005, month=5, pk=39323)
			*PODSTAWY - DYNAMICZNE ŚCIEŻKI poprzez użycie ZMIENNYCH  w ścieżkach  '../product/1'
				*W URLS.PY - tworzysz ZMIENNE poprzez nawiasy trójkątne: '<...>', taka zmienna zazwyczaj 
				 to ID (lub to samo czyli: Primary Key) czyli: <id> lub <pk> LUB SLUG czyli napis z 
				 myślnikami: <my_slug> Możesz też określić typ tej zmiennej np że będzie tylko 
				 integer'em: <int:pk> lub slug: <slug:my_slug> oraz dać swoją nazwę tej zmiennej:
							from .views import product_detail_view
							...
							urlpatterns = [
								path('product/<int:my_pk>/', product_detail_view, name='product-detail')
								path('product/<str:my_name>/'...)
								path('product/<slug:my_slug>/'...)
							...
				*W VIEWS - w argumentach funkcji musisz podać nazwę tego parametru z nawiasów ostrych <>
			     z urls.py gdy zmienna z tych nawiasów ostrych będzie przekazana orzy wywołaniu funkcji 
				 z views. Wewnątrz funkcji możesz użyć tego argumentu w jako zmienna przy instrukcji 
				 ORM/bazodanowej. 
							from .models import Product
							from django.shortcuts import render redirect
							from django.urls import reverse
							def product_detail_view(request, my_pk):
								obj1 = Product.objects.get(id=my_pk)
								obj2 = Product.objects.get(id=my_pk+1)
								context = {'my_object'=obj1, 'another_object'=obj2}
								return render(request, "products/detail.html",context)
						#lub zamiast przekierowywać do pliku html możesz przekierować na inną ścieżkę URL 
						#przez co zostnie rozpoczęta cała operacja od początku (url->view->html):
								#return redirect(reverse("products:product_detail", kwargs=("my_id"=obj1.id)
						#lub bez użycia metody reverse:
								#return redirect("products:product_detail", my_id=obj1.id)
					*Przy otwarciu danego url jest wywoływana funkcja z views.py z arg. z nawiasów ostrych):
							#127.0.0.1:8000/product/34/
							#(product_detail(request=<HttpRequest object>, my_pk=34))
				*W TEMPLATES - w plikach HTML do linków do innych podstron dodajesz zmienną zaraz po 
				 3cim arg metody path w urls.py. Zmienna ta jest kluczem ze słownika podanego przy 
				 metodzie render we views: 
							<a href = "{% url 'product-detail' another_object.id %}">...</a> 	
				 DYNAMICZNE LINKI w HTMLu - zamiast powyższej konstrukcji linka ze zmienną możesz odwołać 
				 się do podstrony poprzez metodę get_absolute_url() :				 
							<a href ='{{ another_object.get_absolute_url }}'>...</a>
				 Wtedy w MODELS tworzysz metodę:
							def get_absolute_url(self):
								return reverse('product-detail', kwargs={'pk':self.pk})	
					#gdy linki masz w urls.py w danej app/funkc. zamiast w głównej app/funkc. to tworząc
					#zmienną app_name = <app_name> w urls.py danej app/funkc. przy podawania nazwy 3arg
					#funkcji path w urls.py musisz podać jeszcze to app_name przed nazwą tej zmiennej: 
							def get_absolute_url(self):
								return reverse('products:product-detail', kwargs={'pk':self.pk})	
				 Przydaję się to przy przechodzeniu przez listę obiektów przekazanych przez słownik W 3cim
				 argumencie metody render we views.py (WIĘCEJ --> get_absolute_url -> C)Funkcje -> MODELS)
			*PRZEKAZYWANIE PARAMETRÓW (DYNAMIC URL) Z URLS DO VIEW:
				*w URLS.PY:
						from .views import product_detail_view
							urlpatterns = [
								path('product/<int:my_pk>/', product_detail_view, name='product-detail')
							...
				*we VIEWS.PY - nazwa podawango argumentu musi być taka sama jak w ścieżce URL tzn: jeżeli 
				 nazywa się w urls.py masz <int:my_pk> to we views.py musisz używać my_pk
						def v1(response, my_pk):	
							return HttpResponse("%s" % my_pk)	
						from .models import myObject
						def v2(response, my_pk):	
							obj = myObject.objects.get(id=my_pk)
							return HttpResponse("%s" % obj.id)
			*ALTERNATYWA DO DYNAMIC URL:
				*gdy nie masz stworzonego linka ze zmienną który kierowałby do konkretnego obiektu 
				 (takiego detailView) to możesz stworzyć WYSZUKIWARKĘ gdzie:
				*W TEMPLATES - tworzysz formularz o methodzie GET:
						<form method="GET" action="{% url 'home' %}">
							<input type="text" name="q" placeholder="Search rooms..."/ >
							<input type="submit" value="search">
						</form>
				*W ŚCIEŻCE LINKU - przy wysłaniu tego formularza ALBO wpisaniu w link '?q=objAtribute'
						<a href="{% url 'home' %}?q={{topic.name}}"> MOJ_TOPIC </a>
				*WE VIEWS.PY na innej stronie tworzysz logikę wyszukiwania dla obiektu:
						q= request.GET.get('q') if request.GET.get('q') != None else ''
						topics = Topic.objects.filter(name__icontains=q)
			
	*4*module VIEWS.PY:
		1*PODSTAWY:
			*funkcje w views.py sa 'request handlerami' i przyjmują 'request' a zwracają 'response'
			*w innych frameworkach module view.py miałby imię ACTIONS
			*wewnątrz tych funkcji we views.py możesz:
				*wpisać logikę działania danej aplikacji czyli co ma się stac gdy użytkownik wejdzie w  
				 daną ścieżkę/link.
				*wysyłać dane z bazy danych do innej bazy danych 
				*przetwarzać dane i je modyfikować 
				*wysyłać maile, itp.
			*pierwszy argument w funkcjach we views.py jest wymagany i nazywa się request - dzięki niemu 
			 można uzyskać m.in usera:
							def first_func(request):
								print(request.user)
		2*ZWRÓCENIE OBIEKTU TYPU RESPONSE - METODY:
		   A*metoda HttpResponse z modułu django.http (zwraca podany tekst w obiekcie HttpResponse):
							from django.http import HttpResponse
							def say_hello(request):
								return HttpResponse('<h1>Hello World'</h1>)
				**użycie z funkcją render_to_string:
							from django.template.loader import render_to_string
							from django.http import HttpResponse
							def home(request):
								context={'article_obj':Article.objects.get(id=2)}
								HTML_String = render_to_string('home-view.html', context)
				**użycie wraz z obiektem loader na nim wywołanymi metodami get_template(), render():
							from .models import Question
							from django.http import HttpResponse
							from django.template import loader
							def index(request):
								t = loader.get_template('polls/index.html')			#zwróci template
								context = { 'list': Question.objects.all() }
								return HttpResponse(t.render(context, request))
		   B*metoda render() z django.shortcuts która jako argumenty przyjmuję:
				**requesta (pierwszy argument funkcji we views.py), 
				**ścieżkę wewnątrz katalogu templates składającą się na nazwę katalogu projektu wraz z 
				  nazwą pliku html (te pliki musżą znajdować się w katalogu templates)
				**mapping object np.: dictionary (którego później będziesz używał do przesłania danych 
				  (zazwyczaj danych wyciągnietych z ORM DJANGO) do dokumentu html'a znajdującego się w 
				  katalogu templates/my_app). Taki słownik zwyczajowo nazywany jest 'context':
							from django.shortcuts import render
							from django.contrib.auth.models import User
							def say_hello(request):
								context = {'name':'Mosh', 'user':User.objects.first()}
								return render(request, 'playground/helloHTML.html',context)
		   C*metoda redirect() z django shortcuts która jako argument przyjmuję zmienną name która jest 
			 3cim argumentem metody path() z urlpatterns z pliku URLS.PY zamiast ścieżki do pliku html z 
			 katalogu templates (jak ma to miejsce w metodzie render(). Ponadto funkcja redirect() nie 
			 przyjmuję argumentu w postaci słownika któym mógłbyś przekazać dane do kolejnej strony(jak w 
			 render):
							from django.shortcuts import redirect
							def say_hello(request):
								return redirect('blog-home')
				*z użyciem dynamic URL czyli zmiennej potrzebnej do linka - nazwa zmiennej musi być taka 
				 sama jak w linku:
							#dla urls.py: path("<int:id_link>/", views.detail, name='product_detail')
							from django shortcuts import redirect
							def detail(request, my_id):
								return redirect('product_detail', id_link=my_id})
				*z reverse() - możliwość przeniesienia na dynamic url:
							#dla urls.py: path("<int:id_link>/", views.detail, name='product_detail')
							from django.urls import reverse
							from django shortcuts import redirect
							def detail(request, my_id):
								return redirect(reverse('product_detail', kwargs={'id_link':my_id})
			D*HttpResponseRedirect() - do aktualnego linka dodaje to co wpisane w arg - (używaj opcji 
			  z możliwością użycia DYNAMIC URLS czyli z reverse()):
							#dla urls.py: path("<int:id_link>/", views.detail, name='product_detail') 
							from django.http import HttpResponseRedirect
							def detail(request, my_id):
								return HttpResponseRedirect('/{}'.format(my.id)
				*z reverse()  - DYNAMIC URLS (jedyna opcja gdzie przy cofaniu strony formularz się nie odtwarza)
							#dla urls.py: path("<int:id_link>/", views.detail, name='prod_detail') 
							from django.http import HttpResponseRedirect
							from djnago.urls import reverse
							def detail(request, my_id):
								return HttpResponseRedirect(reverse('prod_detail', kwargs={id_link:my_id}))
		3*ZESTAWY DANYCH POBRANE Z BAZY DANYCH:
		   *A*INSTRUKCJE ORM/SQL -> patrz na instrukcje 3. ORM DJANGO
		   *B*METODY (zamiast instrukcji ORM/SQL):
			   **get_object_or_404(model_nazwa, pole_nazwa) 
					*gdy obiekt nie istnieje to strona 404 zamiast error'u DoesNotExist
							get_object_or_404(Post, id=id)
					*używane zamiast ORM/SQL: <model>.objects.get(<pole>=<value>) np: Post.objects.get(id=1)
					 którą musiałbyś zawrzeć w try except'cie (wykorzystując wyjątek Http404):
							from django.http import Http404
							try:
								obj1 = Post.objects.get(id=my_id)
							except Post.DoesNotExist:
								raise Http404
								#albo podmiana block'u w html'u
			   **get_list_or_404(model_nazwa) 
							get_list_or_404(Post)
					*używane zamiast ORM/SQL: <model>.objects.all() np: Post.objects.all() którą musiałbyś 
					 zawrzeć w try except'cie (wykorzystując wyjątek Http404):
							from django.http import Http404
							try:
								objects = Post.objects.all()
							except Post.DoesNotExist:
								raise Http404
		4*TWORZENIE OBIEKTÓW we views.py, ZAPISYWANIE ICH W BAZIE DANYCH i USUWANIE ICH Z BAZY DANYCH:
			**UTWORZENIE oraz ZAPISANIE OBIEKTU(z models.py)/REKORDU dla DANEJ TABELI 		ORAZ
			  UTWORZENIE OBIEKTU poprzez ODWOŁANIE SIĘ DO OBIEKTU który jest KLUCZEM OBCYM DLA TWOJEJ 
			  TABELI --> patrz na pkt 3 ORM DJANGO --> 3*TWORZENIE OBIEKTU --> A i B i C
			**UTWORZENIE OBIEKTU USERa FORMULARZEM --> 5.ROZSZEZRZONE MODUŁY ->*2*FORMS ->2*FORM. REJESTR.
			**USUWANIE OBIEKTU:
				0*w URLS.PY, usuwanie jest związane z dynamicznymi ścieżkami. Podajesz który element usunąć:
								path('product/<int:my_id>/delete', products_views.product_delete_view, 
																					name='product_delete'),
				1*USUWANIE POPRZEZ GET REQUEST - usuwanie tylko poprzez ścieżkę lub link bez użycia 
				 potwierdzającej strony html:
							def product_delete_view(request, my_id)
								obj = get_object_or_404(Product, id=my_id)
								obj.delete()
								return redirect("home")
				2*USUWANIE poprzez POST REQUEST (z użyciem potwierdzającej strony HTML):
							def product_delete_view(request, my_id)
								obj = get_object_or_404(Product, id=my_id)
								if request.method != 'POST':
									context ={
										"object":obj
									}
									return render(request, "products/product_delete.html", context)
								else:   #if request.method == 'POST'
									obj.delete()
									return redirect("home")
				    *po wybraniu ścieżki/linka, przekierowanie na stronę potwierdzającą usunięcie. Wewnątrz
					 pliku HTML tworzysz formularz bez pól. Dołączasz csrf_token i przycisk potwierdzający.
							 <form action="." method="POST">
								{% csrf_token %}
								<h1>Do you want to delete the product {{object.title}}?</h1>
								<p>
									<input type ="submit" value='Yes'/>
									<a href="../">Cancel</a>
								</p>
							</form>
					*Jeżeli potwierdzisz usunięcie to zostaję wysłany request POST z usunięciem i masz
					 przeniesienie na stronę główną
	*5*katalog TEMPLATES (którego tworzymy sami (musi być tak nazwany))
	   A*PODSTAWY:
			*w innych frameworkach byłoby to nazwane views ale w Django views.py odpowiada za coś innego
			*są tam m.in dokumenty html które możesz przekazywać poprzez metodę render w module views.py
			*2 OPCJE przekazywania dokumentów html: 
				   A)tworzysz główny katalog templates w ścieżce bazowej (ale nie w głównej app/funkc.) 
				     i tam trzymasz wszystkie pliki html. W pliku settings.py głównej app/funkc. w skecji 
					 'TEMPLATES' w kluczu 'DIRS' podajesz ścieżkę do tego głónego katalogu templates 
					 (wykorzystując BASE_DIR):
							import os
							TEMPLATES{
								'DIRS':[  os.path.join(BASE_DIR, 'templates'),  ]
								...}
			       B)W danej app/funkc tworzysz folder templates, wewnątrz folder o nazwie app/funkc. i
				     tam trzymasz pliki html dotyczące danej app/funkc. Działa to dzięki ustawieniu 
					 'APP_DIRS'=True  w sekcji TEMPLATES w settings.py w głównej app/funkc. 
			 Django domyślnie szuka najpierw głównego katalogu templates a później katalogu templates 
			 dla każdej app/funkc. W app/funkc. w katalogu templates specjalnie tworzysz dodatkowy 
			 folder o nazwie app/funkc. gdyż gdyby pliki html miały taką samą nazwę w głównym katalogu 
			 templates i tych związanych z app/funkc. to pierszeństwo miałby główny katalog. 
			*w Visual Studio podstawowy szkielet html tworzysz wpisując '! + TAB'
	   B*MOŻLIWOŚC EDYTOWANIA PLIKÓW HTML (DJANGO TEMPLATING ENGINE - JINJA ):
		  *https://docs.djangoproject.com/en/4.0/topics/templates/
		  *PODSTAWY:
			*możesz edytować pliki HTML dla różnych zmiennych poprzez przekazanie w metodzie render 
			 (w pliku views.py) słownika(dictionary). 
			*do wartości tego słownika odwołujesz się poprzez wypisanie kluczy bez cudzysłowiów. Jeżeli 
			 wartości słownika odpowiadają listom albo innym słownikom to odwołujesz się do ich elementów
			 NIE poprzez NAWIASY KWADRATOWE (wypisanie numeru elementu (dla list) lub nazwy klucza (dla 
			 słownika)) tylko poprzez wypisanie kolejnych elementów PO KROPCE (numer elementu po kropce 
			 (dla list) lub nazwa klucza po kropce (dla słownika)).
		  *ROZSZERZENIE:
			*KONSTRUKCJE UZYSKANE POPRZEZ EDYTOWANIE HTMLA (NAWIASY WĄSOWE{}):
				*WSZYSTKIE KONSTRUKCJE: https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#
				*zmienna user - jeżeli jesteś zalogowany przy pomocy class-based-views LoginView to
				 możesz odwoływać się do user'a bez konieczności przesylania go w 3cim arg metody render():
						<h1>Hello {{ user }}</h1>
					###(w  urls.py) głównej app/funkc.: 
					###from django.contrib.auth impoty views as auth_views
					###path('login/', views.LoginView.as_view(template_name='users/login.html')),
				*zmienne - zawierasz w podwójnych nawiasach wąsowych:
						<h1>Hello {{name}}</h1>
					###(we views.py) dla danej funkcji zwracającej: 
					###render(request, 'playground/hello.html',{'name':'Mosh'}) 		
															#zwróci: <h1>Hello Mosh</h1>
					*NA ZMIENNYCH MOŻNA STOSOWAĆ FILTRY POZWALAJĄCE NA EDYCJĘ (poprzez znak pipe'a)
					 https://docs.djangoproject.com/en/4.0/ref/templates/builtins/#built-in-filter-reference
						{{zmienna_date|date:"F d, Y"}}				#edycja: Month, day, YEAR
						{{zmienna|add:22}}							#dla zmiennej= 55 zwróci: 77
						{{zm_date|timesince}}						#ile czasu mineło od obiektu datetime
						{{zm|safe}}									#dla context={'zm':'<h1>HELLO</h1>'}
																	#zamiast czystego tekstu renderuje html		
						{{zmienna|pluralize}}						#dostosuję końcówkę słowa do liczby
																	#pojedyńczej lub mnogiej 
				*konstrukcje IF - zawierasz w nawiasach wąsowych ze znakiem procenta wg składni:
						{% if zmienna == 'login' %}
							<h1>zaloguj się<h1>
						{% endif %}

						{% if name %}					#jeśli klucz 'name' istnieje
							<h1>Hello {{name.0}}</h1>	#zwróc pierwszy element listy
						{% elif sur name %}
							<h1>Hello {{surname}}</h1>		
						{% else %}
							<h1>Hello World</h1>
						{% endif %}
					###(we views.py) dla danej funkcji zwracającej rendera w którym przekazujesz słownik  
					###z kluczem któremu odpowiada wartość w postaci listy zawierającej imona). 
					###render(request, 'playground/hello.html',{'name':['Mosh','Gosh'}) 
															#zwróci: <h1>Hello Mosh</h1>
				*konstrukcje FOR - zawierasz w nawiasach wąsowych ze znakiem procenta wg składni:
						{% for p in posts %}	#przejdz przez liste ktora jest wartością dla klucza posts
							<h1>{{p.title}}</h1>
						{% endfor %}
					###(we views.py) dla danej funkcji zwracającej rendera w którym przekazujesz słownik 
					###z kluczem z odpowiadającą wartością w postaci listy zawierającej słowniki:
					###render(request, 'playground/hello.html',{'posts':'[{'title':'one'}{'title':'two'}]})
															#zwróci: <h1>one</h1>	  \n     <h1>two</h1>
					###{{ forloop.counter }} - jako licznik iteratora (liczy od 1):
						#dla return render(request, "about.html", {"list": [11,12,"abc"]})
						{% for i in list %}	#przejdz przez liste ktora jest wartością dla klucza posts
							<h1>{{ forloop.counter }} = {{i}}</h1>		#1 = 11 ; 2 = 12 ; 3 = "abc"
						{% endfor %}
					*gdy pobierasz listę która jest kluczem obcym dla innych pojedyńczych obiektów to chcąc 
					 po niej przejść musisz się odwołać do setu obiektów i wywołać metodę all BEZ NAWIASÓW
						#w models:
						class ToDoList(models.Model):
							name=models.CharField(max_length=200)							
						class Item(models.Model):
							todolist = models.ForeignKey(ToDoList, on_delete=models.CASCADE)
						#w templates:
						{% for it in list.item_set.all %}
							{{it}}
						{% endfor %}
				*SKRÓT -> szablony w HTMLu:
					#plik base.html -> szablon podstawowy dla innych plików html 
							<body>
								{% block blockName %}{% endblock %}	#w tym przypadku blockName = content
							</body>
					#w pliku rozszerzającym katalog plik base.html:
							{% extends  "blog/base.html" %}
								{% block content %}
									...	
								{% endblock content %}
				*SKRÓT -> linki w htmlu - (patrz katalog templates -> LINKI W HTMLU):
						...<a href={% url 'plaground-hello' %}>...</a>...
					DYNAMICZNE LINKI tj linki ze zmiennymi:
							<a href = "{% url 'product-detail' another_object.id %}">...</a> 	
							<a href = "{% url 'product-detail' another_object.slug %}">...</a> 	
					lub zamiast powyższej konstrukcji użycie get_absolute_url() z MODELS:				 
							<a href ='{{ another_object.get_absolute_url }}'>...</a>
					(WIĘCEJ PATRZ --> *3*module URLS.PY --> DYNAMICZNE ŚĆIEŻKI)
				*SKRÓT -> linki do podfolderów i ładowanie plików static (patrz: 5*Templates -> 6.STATIC
					*Załadowanie katalogu ze wszystkimi plikami:
						{% load static %}		
					*W sekcji head umieszczenie do nich linka css:
						<link rel="stylesheet" type="text/css" href="{% static 'blog/main.css' %}">
			*SZABLONY w HTMLu:
				*tworzysz gdy wiele stron ma powtarzające się fragmenty.Miejsca te zastąpisz 1 szablonem
				*możesz go uzyskać poprzez stworzenie szablonowego pliku htmla i umieszczenie w nim w 
				 odpowiednich miejscach bloków {block content} gdzie treśc w zależności od linku/plikuHTML 
				 będzie się zmieniać. Te bloki oznaczasz w sposób: {% block blockName %}{% endblock %}
				*pomiędzy możesz wpisać dane domyślne gdy plikach wykorzystujących szablon nie znajdzie dAiS6JXm
				 danego bloku np: {% block blockName %}My Default text{% endblock %}
					#plik base.html który jest szablonem podstawowym dla innych plików html
						<!DOCKTYPE html>
						<html>
							<head>
								<meta charset="utf-8">
								<meta name="viewport" content="width=device-width, initial-scale=1">
								<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
								<title>Hello, world!</title>
							</head>
							<body>
								{% block blockName %}{% endblock %}	#w tym przypadku blockName = content
							</body>
						</html>
				**w odpowiednich plikachHTML/linkach wykorzystujesz ten szablon (ładując go na początku 
				 pliku poprzez podanie w cudzysłowiu ścieżki do szablonu (pliku HTML) zaraz za słowem 
				 extends. Szablon ten znajduję się w katalogu templates {% extends "blog/base.html %}) 
				 i nastęnie tworzysz wnętrze bloku który ma być podmieniony w szablonie, okalając go wg 
				 schematu:  {% block blockName %}...{% block blokName %}:
						#plik home.html (który będzie wykorzystywał szablon base.html):
						{% extends  "blog/base.html" %}
						{% block content %}
							{% for p in posts %}
								<h1>{{p.title}}</h1>
							{% endfor %}
						{% endblock content %}
				**jeżeli chciałbyś użyć szablonu z innej app/funkcjonalności to dzięki temu że Django
				  w pierwszej kolejności przechodzi przez sekcję INSTALLED_APPS w settings.py w której 
				  zapisujesz wszystkie aplikację/funkcjonalności i dzięki temu że w strukturze katalogu 
				  templates oprócz szablonu HTML dodajesz (pomiędzy) jescze katalog o nazwie aplikacji/
				  funkcjonalności to wystarczy że w swoim pliku html chcącym wykorzystać szablon z innej
				  app/funkcjonalności podasz: nazwa_aplikacji/nazwe_szablonu.html
						{% extends  "blog/base.html" %}		#plik register.html z app/funkcjonalności
															#users będzie wykorzystywał szablon base.html
															#z app/funkcjonalności blog 
											#nie musisz wpisywać specjalnej ścieżki żaby iśc w górę by 
											#przejś do katalogu innej app/funkcjonalności.
			*ZAINKLUDOWANIE WSTAWKI HTML do PLIKU HTML:
				**zainkludowanie navbar.html w base.html - poniżej plik base.html:
						<body>
							{% include "navbar.html" %}
							...
						<body>
				**gdybyś we wstawce HTML używał jakiś zmiennych to wystarczy że stworzysz je w podwójnych 
				  nawiasach {{ first }} a w pliku w którym wstawkę HTML zainkludujesz dodasz konstrukcje 
				  'with' i podasz te zmienne wg schematu 'klucz=wartość' (jako wartosć możesz podać też 
				  zmienne ze słownika (context_variable)):
						<body>
							{% include "navbar.html" with first='My title' second=context_variable %}
							...
						<body>
			*LINKI W HTMLU: 
				*zamiast wpisywać ścieżki w linkach to podawaj zmienne których nazwy będą odwoływać się do 
				 3ciego argumentu name w pliku urls.py w zmiennej urlpatterns w tej samej app/funkc.
				*dzięki temu gdybyś chciał zmienić link to będziesz mógł to zrobić w jednym miejscu czyli
				 w liście urlpatterns w metodzie path w pliku urls.py w naszej app/funkcjonalności
				 zamiast w dwóch miejscach czyli w metodzie path oraz pliku html.
					#w pliku urls.py w naszej głównej app/funkcjonalności:
						#app_name = 'blog'					# możesz ale nie musisz jej tworzyć
						urlpattrens =[
							path('home/', views.say_hello, name='blog-hello')
							path('product/<int:pk>', products.product_detail_view, name='product-detail')
							]	
					#od teraz w plikach html zamiast używać /home wpisujesz {% url 'blog-hello' %}
						...<a href={% url 'blog-hello' %}>...</a>...
				*jeżeli stworzysz zmienną app_name w pliku urls.py to w linkach przed podaniem 3ciego arg 
				 zmiennej path (tj: name) z urls.py będziesz musiał wypisać wartość tej zmiennej:	
						...<a href="{% url 'blog:blog-hello' %}">LINK</a>
				*DYNAMICZNE LINKI tj linki ze zmiennymi:
						...<a href = "{% url 'product-detail' another_object.id %}">...</a> 	#lub				 
						...<a href = '{{ another_object.get_absolute_url }}'>...</a>
				 (WIĘCEJ PATRZ --> *3*module URLS.PY --> DYNAMICZNE ŚĆIEŻKI)
			*FORMULARZ REJSETRACYJNY W HTMU:
						{% extends "blog/base.html" %}	   # ładujesz szablon
						{% block content %}				   # wpisujesz swoją wersję miejsca podmienianego
							<form method ='POST'>		   # dla tagu form dodajesz argument POST który
														   ##przesyła dane w formularzu
								{% csrf_token %}		   # bez csrf_token formularz nie zadziała
									{{ form|crispy }}	   # podajesz zmienną form wyrenderowaną CSSowo
														   ##względem pobranych stylów crispy
								 <button type="submit">Sign Up</button>
														   #button o typie 'submit' żeby móc wysłać form
							</form>
						{% endblock content %}				
				**możesz dodatkowo wyrenderować formularz poprzez funkcjonalność CSSową CRISPY_FORMS 
				  JEST TO DOKŁADNIE OMÓWIONE W OPCJI ROZSZERZONEJ FORMLARZA REJESTRACYJNEGO PKT2GIM
				  w DZIALE IIgim CZYLI PRZYKŁADY RÓŻNYCH APLIKACJI WYTWORZONYCH WE VIEWS.PY
				  
	*6*FOLDER STATIC dla danej app/funkc:
		*PRZECHOWYWANIE:
			*pozwala przechowywać PLIKI CSS, javascript, MEDIA
			*w katalogu 'static' tworzysz folder o nazwie danej app/funkc. (dodatkowo możesz ale nie 
			 musisz stworzyć inne podfoldery jak np: styles albo scripts). Trzymasz tam pliki css/js/itp
			*możesz też stworzyć plik static w głównym korzeniu drzewa plików jak jakąs app/funkc. Wtedy w 
			 settings.py w głównej app/funkc. musisz stworzyć zmienną STATICFILES_DIR i przypisać jej 
			 listę ścieżek przechowania plików static:
					#w settings.py
					import os
					STATIC_URL = 'static/'
					STATICFILES_DIRS=[
						os.path.join(BASE_DIR,'static'),
					]
		*ZAŁADOWANIE 
			*na samej górze (przed DOCKTYPE) umieść załadowanie:
					{% load static %}
			 oraz w sekcji head umieść ścieżkę folderów do danego pliku poprzez:
					<link rel="stylesheet" type="text/css" href="{% static 'blog/main.css' %}">
			*jeżeli używasz szablonu np: base.html to załadowanie i zalinkowanie robisz tylko w nim
			*pamiętaj żeby zrestartować stronę żeby załadowały się pliki z folderu static
			
3. ORM DJANGO:
   0*PODSTAWY:
		*Stary sposób poruszania się w SHELLu --> dataclass:
				from dataclasses import dataclass
				@dataclass
				class BlogPost:
					title: str
					content: str
				obj =BlogPost(title="Hello World", content="This is cool")
				obj.content
		*Poniższych komend możesz użyć w konsoli shella w DJANGO-PYTHON oraz wynik tych komend przypisać 
		 do jakieś zmiennej i następnie zwróci ją w 3 argumencie metody 'render' we views.py
		*PAMIĘTEJ żeby najpierw zaimportować bazy danych (znajdującą się w module models.py) oraz bazę 
		 użytkownikow która jest wbudowana w django:
				from blog.models import Post
				from django.contrib.auth.models import User				#baza uzytkowników
		*we views.py instrukcje trzeba zawrzeć w try except'cie (wykorzystując wyjątek Http404) inaczej 
		 gdy obiekt nie istnieje to wyskoczy błąd DoesNotExist:
				from django.http import Http404
				try:
					obj1 = Post.objects.get(id=my_id)
				except Post.DoesNotExist:
					raise Http404
   1*INSTRUKCJE które zwracają zestaw danych w postaci obiektów których możesz uzyć jako 
	 KLUCZ SŁOWNIKA (na przykładzie tabeli User pobranej z django.contrib.auth.models)
		*wszystkie obiekty z danej tabeli:	
				User.objects.all()	#zwróci: <QuerySet [<User: marek>, <User: testUser>]>
						#  w render 3ci argument:{'users': User.objects.all()}
			**zamiast tej instrukcji, to we views.py lepiej użyć get_list_or_404(<model>)
		*żadny obiekt z danej listy - zwraca postą liste zamiast None(co mogłoby powodować błąd):
				User.objects.none()							#zwróci: []
		*pierwszy/ostatni obiekt z danej tabeli:
				User.objects.first()						#zwróci: <User: marek>
				User.objects.last()							#zwróci: <User: testUser>					
						#  w render 3ci argument:{'user': User.objects.first()}
						#  w render 3ci argument:{'user': User.objects.last()}
		*zwrócenie użytkownika na bazie jakiegoś pola np id:
				from django.contrib.auth.models import User
				User.objects.get(id=1)								#zwróci:  <User: marek>
						#  w render 3ci argument:{'user': User.objects.get(id=1)}
			**zamiast tej instrukcji, to we views.py lepiej użyć get_object_or_404(<model>,<pole>=<value>)
			**nie stosować filtracji jak poniżej!!! ponieważ metoda get() zwraca tylko eden obiekt. Gdy
			  będzie pasować więcej to będą wyskakiwać błędy:
				current_year = timezone.now().year
				Question.objects.get(pub_date__year=current_year)
		*zwrócenie pola konkretnego rekordu odbywa się po kropce:
			**Primary KEY / id
				User.objects.filter(username='marek').first().pk   /LUB   
				User.objects.filter(username='marek').first().id			
						#  w render 3ci argument:
						#  {'pk': User.objects.filter(username='marek').first().pk}
						#  {'id': User.objects.filter(username='marek').first().id}
		*zwrócenie listy wartości danych pól w danym obiekcie:
				My_model.objects.all().values_list('my_attribute',flat=True) 
															#'flat = True' zwróci listę zamiast QuerySet'u
		*zwrócenie obiektów upporządkowanych wg danego pola 'order_by()':
				Question.objects.order_by('-pub_date')		#zwróci Question uporz. wg. pub_date malejąco
		*wybrany zbior obiektów ODFILTROWANY przez filter np: username:
				User.objects.filter(username='marek')	#zwróci: <QuerySet [<User: marek>]>
				User.objects.filter(username='marek').first()	    #zwróci:  <User: marek>
						#  w render 3ci argument:
						#  {'users': User.objects.filter(username='marek')}
						#  {'user': User.objects.filter(username='marek').first}
			**filter(<model_attrbitute>__startswith='my_text') 
				User.objects.filter(name__startswith='Mar')
						#  w render 3ci argument:
						#  {'users': User.objects.filter(name__startswith='Mar')}
			**filter(<model_attrbitute>__startswith='my_text') 
				User.objects.filter(name__startswith='Mar')
			**filter(<model_attrbitute>__contains='my_text'
				User.objects.filter(name__contains='are')
			**filter(<model_attrbitute>__icontains='my_text')
				User.objects.filter(name__icontains='are')
			**filter(<model_attrbitute>__iexact='my_exact_text') - dokładny tekst case sensitive
				User.objects.filter(name__iexact='my exact title')
			**filter(<model_attrbitute>	 __lte ; __gte ; __le ; __ge   - (greater/less then or equal):
				Question.objects.filter(pub_date__lte=timezone.now())
			**filtrowanie na polach obiektu:
				Question.objects.filter(pub_date__year=current_year)
			**filtrowanie na obiekcie klucza obcego i jego polach oraz wykorzystywanie funkcji na nich:
				Choice.objects.filter(question__pub_date__year=current_year)
				Room.objects.filter(topic__name__contains = 'my_word')
			**filtrowanie na obiektach klucza obcego dla klucza obecgo (coraz niższe poziomy):
				u1=User.objects.get(id=1)
				IngredientImage.objects.filter('ingredient__recipe__user=user')
		*filtrowanie z użyciem order_by('attribute'):
				Question.objects.filter(pub_date__lte=timezone.now()).order_by('-pub_date')
		*filtrowanie z WYŁĄCZENIEM - '.exclude()':
				Question.objects.filter(content__iconatains='my_text').exclude(id=1)
		*filtrowanie na bazie listy jednego z pól obiektów klucza obcego (values_list)(( pole__in))
		 WIELOPOZIOMOWE SZUKANIE:
				u1=User.objects.get(id=1)
				ingredientsIds = user.recipe_set.all().values_list('ingredients__id', flat=True)
			#!	Ingrediens.objects.filter(id__in=ingredientsIds)						#LUB
				recipeIds = user.recipe_set.all().values_list('id', flat=True)
			#!	Ingredients.objects.filter(recipe__id__in=recipeIds)
		*filtrowanie przy użyciu WIELU WARUNKÓW - klasą 'Q' z django.db.models okalasz dane warunki w 
		 nawiasy i wykorzystujesz '&','|' jako 'and','or':
			#dla linka (w templates):
				<a href="{% url 'home' %}?q={{topic.name}}">{{topic.name}}</a>
			#logika działania we views:
				from django.db.models import Q						#poniżej parametr pobrany z linka
				my_q= request.GET.get('q') if request.GET.get('q') != None else ''	 
				rooms = Room.objects.filter(
					Q(topic__name__icontains= my_q) |
					Q(name__icontains=my_q) |
					Q(description__icontains=my_q) |
					Q(host__username__icontains=q))	
   2*INSTRUKCJE zwracające zestawy danych ZWIĄZANE Z KLUCZEM OBCYM:
		*zwrócenie pól z tabeli klucza obcego w naszej tabeli (w models.py w klasie Post:
		 {author=models.ForeignKey(User, on_delete=models.CASCADE)	}):
				p1 = Post.objects.get(id=1)
				p1.author.id		/		p1.author_id		#zwróci: 1
				p1.author.email									#zwróci: 'marek@gmail.com'
						#  w render 3ci argument:
						#  {'authorId': Post.objects.get(id=1).author.id}
						#  {'authorEmail': Post.objects.get(id=1).author.email}
		*zwrócenie pól z tabeli powiązanej relacją OneToOneField (musisz wywołać nazwę powiązanej 
		 klasy/tabeli z małej litery) (w models.py w kl. Profile
		 {user = models.OneToOneField(User, on_delete=models.CASCADE)  })
				u1 = User.objects.filter(username='CoreyMs').first()
				u1.profile 					#zwróci referencje do profilu powiązanego z userem
				u1.profile.user.username	#zwróci pola z atrybutami profilu powiązanego z userem
				u1.profile.image.url		#nazwa zdjęcia	
				u1.profile.image.size			
				u1.profile.image.height
				u1.profile.image.width
						#  w render 3ci argument:
						#  {'imageURL': User.objects.filter(username='CoreyMs').first().profile.image.url}
		*zwrócenie pól z tabeli połączonych ForeignKey oraz relacją OneToOneField 
		 #w blog models Post: {author=models.ForeignKey(User, on_delete=models.CASCADE)  		}
		 #w users models Profile: {user = models.OneToOneField(User, on_delete=models.CASCADE)	}:
				from blog.models import Post
				from django.contrib.auth.models import User
				post = Post.objects.create(title='Blog 1', content='First Post Content'
								,author=User.objects.filter(username='marek').first())
				post.save()
				post.author.profile.image.url
		*( '_set'.all() ) - jeżeli odwołujesz się do obiektu w tabeli który jest KLUCZEM OBCYM DLA INNEJ 
		 TABELI to możesz zobaczyc zbiór wszystkich wystąpień tego obiektu w tej tabeli dla której jest 
		 kluczem obcym. Odwołując się do tabeli DLA KTÓREJ JEST KLUCZEM OBCYM (nazwa tabeli/klasy małą 
		 literą wraz z '_set'.all().
			#(w models.py w klasie Post: {author=models.ForeignKey(User, on_delete=models.CASCADE)	})
				u1=User.objects.filter(username='marek').first()
				u1.post_set.all()			#zwróci wszystkie posty danego usera
											#zwróci <QuerySet [<Post: Blog 1>, <Post: Blog 2>]>
						#  w render 3ci argument:
						#  {'posts': User.objects.get(id=1).post_set.all()}
		*'count()' - zwrócenie liczby ilości obiektów w kluczu obcym:
				Question.objects.get(id=1).choice_set.count()
				Question.objects.get(id=1).choice_set.all()count()
		*( values_list('nazwaPola',flat=True) ) zwrócenie listy pola obiektów klucza obcego (z możliwością 
		 filtrowania po tej liście pola obiektów klucza obcego) :
				u1=User.objects.filter(username='marek').first()
			#zwraca wszystkie 'id' przepisów(Recipe) usera 'marek' z dod arg 'None': <QuerySet [1, None]>
			#dlatego później robisz filtrację na obiektach klucza obcego dla Recipe w postaci Ingredient
				recipeIds = u1.recipe_set.all().values_list('id', flat=True) 	#<QuerySet [1, None]>
				Ingredient.objects.filter(recipe__id__in=recipeIds)				
			#LUB
				ingredientsIds = u1.recipe_set.all().values_list('ingredient__id', flat=True)
				Ingredient.objects.filter(id__in=ingredientsIds)				
   3*UTWORZENIE OBIEKTU - INSTRUKCJE TWORZĄCE I ZAPISUJĄCE DANE W TABELI:				
	   A*UTWORZENIE oraz ZAPISANIE OBIEKTU(z models.py)/REKORDU dla DANEJ TABELI (Z OPCJĄ MODYFIKACJI):
				**tworzenie:
					*musisz wcześniej pobrać dany obiekt(z models.py)/tabelę
					*tworzysz rekord w tabeli poprzez utworzenie obiektu przez konstruktor:
								from blog.models import Post
								from django.contrib.auth.models import User
								post_1 = Post(title='Blog 1', content='First Post Content'/
											  ,author=User.objects.filter(username='marek').first())
													#w kluczu obcym nie podajesz tylko id klucza obcego ale 
													#podajesz cały obiekt. Gdybyś chciał przypisać id to w
													#argumencie obieku tabeli obcej dodajesz podkreślnik
													#a w przypisywanym obiekcie dodajesz kropkę:
											##,author_id=User.objects.filter(username='marek').first().id)
				**zapisywanie:
								#post1.title='B1'	#(Z OPCJĄ MODYFIKACJI):
								post_1.save()		#teraz mozesz zobaczyć że masz post_1 zapisany we 
													#wszystkich Postach: Post.objects.all()
													#które zwróci: <QuerySet [<Post: Post object (1)>]>
	   B*UTWORZENIE OBIEKTU poprzez METODE CREATE() wywołaną na WSZYSTKICH OBIEKTACH DANEJ KLASY:
								#1
								from users.models import Profile 
								Profile.objects.create(user=instance)
								#2
								from blog.models import Post
								from django.contrib.auth.models import User
								Post.objects.create(title='Blog 1', content='First Post Content'/
											  ,author=User.objects.filter(username='marek').first())
		
	   C*UTWORZENIE OBIEKTU w tabeli i ZWRÓCENIE GO LUB jeżeli istnieje SAMO ZWRÓCENIE GO (get_or_create())
	     Get_or_create() zwraca krotkę: (obiekt, flaga_CzyUtworzono). używana przede wszystkim zamiast 
		 metody save() przy formularzach które są kluczem obcym dla innego modelu w relacjach 'jeden do 
		 wiele' / 'wiele do wiele, patrz: ROSZERZONE ELEMENTY --> 2.FORMULARZE -> 1 FORMULARZE Z KLUCZEM 
		 OBCYM:
								from .models import Participant
								participant, was_created = Participant.objects.get_or_create(
																		name='Marek', email=user_email)
		
	   D*UTWORZENIE OBIEKTU poprzez ODWOŁANIE SIĘ DO OBIEKTU który jest KLUCZEM OBCYM DLA TWOJEJ TABELI:
				**możesz utworzyć obiekt na bazie obiektu klucza obcego - poprzez odwołanie się do jego 
				  wszystkich wystąpień (_set) i na tym WYWOŁAĆ METODĘ CREATE()):
								#from django.contrib.auth.models import User
								u1=User.objects.filter(username='marek').first()
								u1.post_set.create(title='Blog 3', content='Blog content 3')
													#autorowi tworzysz dany post, nie musisz w tymże 
													#konstruktorze dodawać autora na samym końcu 
	   E*DODANIE OBIEKTU KTÓRY JEST KLUCZEM OBCYM DLA INNEGO MODELU - METODA ADD
		 Używane przy formularzach tworzących obiekt będący kluczem obcym. patrz: ROSZERZONE ELEMENTY --> 
		 2.FORMULARZE -> 1 FORMULARZE Z KLUCZEM OBCYM:
								from .models import Participant, Meetup
								participant = Participant.objects.create(name='Marek', email=user_email)	
								Meetup.objects.get(id=1).participants.add(participant)
								
   4*USUWANIE OBIEKTU Z TABELI:
				from blog.models import Post 
				obj = Post.objects.get(id=1)
				obj.delete()
2. KOMENDY które warto opisać do 'django-admin' a raczej do 'python manage.py' który jest wrapperem do 
     django-admin (specjalnie używamy python manage.py _____ zamiast django-admin _______ gdyz ta pierwsza 
	 komenda bierze pod uwage plik settings.py a druga już nie):
		*runserver - URUCHOMIENIE SERWERA gdzie domyślnym portem jest 8000 ale można podać swój port jak
			kolejny argument - w tym przypadku jest to 8000.
					python manage.py runserver    ||   python manage.py runserver 9000  
				*Po tej komendzie pokażę się adres strony który będzie działał na lokalnym serwerze i 
				 będzie odzwierciedleniem tego co zrobiłeś. Wklej go do przeglądarki.
				*jeżeli pojawi się Tobie błąd invalid syntax to oznacza to że nie została aktywowana 
				 wirtualka (pipenv shell) 
				*żeby zakończyć wciśnij CTRL + C
		*startapp - tworzy nową pojedyńczą funkcjonalność zwaną aplikacją. 
					python manage.py startapp nameapp
		*createsuperuser - tworzy użytkownika (administratora) w celu pierwszego uruchomienia/zalogowania
			do strony administrowania gdzie możesz zarządzać bazami danych oraz użytkownikami o różnych 
			polach dostępu. Żeby móc stworzyć pierwszego administratora (który pozwoli ci się zalogować
			do strony administratora musisz najpierw stworzyć domyślne bazy danych poprzez migrate):
					python manage.py migrate
					python manage.py createsuperuser
		*makemigrations - tworzy 'migracje' czyli na podstawie utworzenia bądz zmiany klasy w pliku 
			models.py tworzy plik migracji w katalogu migrations. Taki plik zawiera wszystkie zmiany jakie 
			były dokonane od ostatniego użycia komendy makemigrations. 
					python manage.py makemigrations
		*sqlmigrate nameAplications numberOfMigration - daję możliwość podejrzenia jakie instrukcje sql
			zostaną wytworzone na podstawie konkretnej 'migracji'
					python manage.py sqlmigrate blog 0001
		*migrate - wykonuję instrukcje sql które są automatycznie wytworzone przez ORM na podstawie 
			wszystkich migracji. Wynik tych instrukcji zostanie zapisany w plikach bazy danych (domyślnie 
			dla sqlite db.sqlite3):
					python manage.py migrate
		*shell - pozwala na interaktywne działanie na modelach (klasach reprezentujących tabele w bazie
			danych). Otwiera django-pythonową konsole shella (basha). Wewnątrz konsoli możesz odwoływać się 
			do obiektów które są zestawami danych zwróconymi z tabel przez odpowiednie metody - metody te 
			są wykorzystwane w module view.py jako wartośc do klucza słownika podawanego jako 3ci argument 
			w metodzie render (patrz module view.py)
					python manage.py shell
					
1. INSTALACJA, URUCHOMIENIE oraz STRUKTURA PROJEKTU:
	1) Stworzenie WIRTUALKI i pobranie django:
		*najważniejsze jest to że zanim stworzysz wirtualkę to najpierw zadbaj o to żeby być WEWNĄTRZ 
		 głównego katalogu projetku a nie folder wyżej:
			pip3 install pipenv 	#jeżeli nie masz pipenv'a zainstalowanego globalnie u siebie. Jest to 
									#wirtualka żeby nie instalować wszystkich modułów w jednym miejscu  
									#będąc w folderze projektu:
			pipenv install django	#kopiujesz link do virtualenv location i przechodzisz do miejsca gdzie
									#zosała zapisan wirtualka a w niej zainstalowane Django
		*lub 
			pip install virtualenv
			virtualenv .
				#dla windowsa:
			Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force 	#wystarczy raz
			Scripts\activate.ps1	#bez komendy 'cd'
			pip install django==2.0.7
				#dla linuxa:
			source path_project_ven/Scripts/activate
			pip install django==2.0.7
	2) START PROJEKTu w terminalu: 
			*musisz aktywować wirtualkę tak żeby interpreter pythona mógł działać dlatego będąc w folderze 
			 projektu wpisujesz komendę:
						pipenv shell 		#LINUX:		source path_project_ven/Scripts/activate 
											#WINDOWS:	Scripts\activate.ps1	#bez komendy 'cd'
			*żeby wyświetlić wszystkie funkcje którymi można się posługiwać w Django użyj:
						django-admin	/	python -m django
			*następnie rozpocznij start nowego projektu:
						django-admin startproject nameproject .	
									#dodaj kropkę na samym końcu żeby projekt został stworzony w aktualnym
									# folderze zmiast tworzyć dodatkowy pośredni folder
			*zrób pierwszą migrację w celu uruchomienia wszystkich ustawięn w pliku settings.py
						python manage.py migrate 
	3) URUCHOMIENIE PROJEKTU W TERMINALU:
				pipenv shell
				python manage.py runserver	-->  http://127.0.0.1:8000   /  http://localhost/8000   
												 CTRL + C (żeby przerwać)
												 exit ( żeby wyjść z pipenva)
		*uruchomienie na innym porcie
				#python manage.py runserver	5050 -->  http://127.0.0.1:5050   /  http://localhost/5050  
	4) STRUKTURA Twojego PROJEKTU (powstała ona poprzez komende django-admin startproject nameproject) a 
	   wewnątrz jej znajdują się pliki:
		A* folder 'nameproject' (którego nazwę można zmienić np: na 'config' > wtedy we wszystkich plikach 
		   (settings.py, asgi.py, wsgi.py i manage.py) trzeba podmienić 'nameproject' na np:'config':
			*__init__.py - mówi interpreterowi Pythona że jest to paczka Pythonowa
			*settings.py - odpowiada za ustawienia naszej aplikacji - składa się z sekcji:
				**BASE_DIR - ścieżka do głównego katalogu Django
				**INSTALLED_APPS składa sie z:
						*wbudowanych aplikacji w Django zaczynających się od django.contrib:
							*.admin - admin interface to manage data,
							*.auth - authenticating app to authentication users
							*.contenttypes
							*.session - (no longer use this)
							*.messages - display user a one-time notifications
							*.staticfiles - for serving files (images, css files, itp)
						*z wpisanych przez nas nazwy app/funckjonalności po wcześniejszym jej utworzeniu
						 (python manage.py startsapp nameapp), (nazwę wpisujesz w cudzysłowiu)
						 Wewnątrz będziesz wpisywał stworzone przez Cb apps jak i te pobrane z zewnątrz
				**DEBUG=True - przy deploymencie zmieniasz na False
				**ROOT_URLCONF = "mainProject.urls" - wskazuję na plik urls.py w głównej app/funkc.
				**TEMPLATES - gdzie przechowywane są templates, jak są renderowane i jak działają
				**WSGI_APPLICATION - dotyczy działania serwerów
				**DATABASES - wskazanie bazy danych, domyślnie sqlite3
				**AUTH_PASSWORD_VALIDATORS - standardy dla wpisywanych haseł
				**STATIC_URL='/static/' - ścieżka do miejsca przechowywania zdjęć ,plików CSS i JS
			*urls.py - tutaj definiujemy linki url naszej aplikacji
			*asgi.py oraz wsgi.py - odpowiadają za deployment
		B* manage.py - to jest wrapper naszej komendy django-admin, który powinniśmy uruchamiać z komendami 
		    django-admin (zamiast djagno-admin + komenda). Wszystko dlatego że manage.py bierzesz pod uwagę 
			również plik settings.py a komenda django-admin już nie.
					*zamiast używać: django-admin runserver 	
							#spowoduję Tobie to błąd django.core.excpetionsImproperlyConfigured
					*dlatego użyj: 
							  python manage.py runserver  
		C* FOLDERY Z POJEDYŃCZYMI APP/FUNKCJONALNOŚCIAMI:
			*(pojedyńczą app/funkcjonalnością a nie całym projektem)
			*pojedyńczy folder/APLIKACJA tworzy się w terminalu poprzez: 	  
							python manage.py startapp nameApp
			 możesz wszystkie takie app/funkc. umieścić w jednym folderze -> wtedy najpierw tworzysz
			 wewnątrz tego folderu folder app/funkc. a póżniej tworzysz app/funkc. komendą startapp.
			 Ponadto w tym folderze dla wszystkich app/funkc. tworzysz pusty plik __init__.py
							mkdir apps
							mkdir apps/my_app
							python manage.py startapp my_app apps/my_app
							cd apps
							touch __init__.py	/  type nul >  __init__.py	
			*następnie trzeba go zarejestrować poprzez wpisanie jego nazwy w apostrofach w:
							folderZprojektem --> settings.py --> INSTALLED_APPS
			 dodajesz wg schematu:'<nameapp>.apps.<Nameapp>Config' (nazwa klasy, dziedzicząca po AppConfig 
			 z pliku apps.py danej app/funkc). Przykład dla app users:
							'users.apps.UsersConfig'
			 (ex: 'blog.apps.BlogConfig' ) (ALBO tylko nazwę app/funkc np 'blog')
			 W przypadku gdy app/funkc. masz w jednym folderze musisz dodatkowo podać nazwę tego folderu:
							'apps.blog.apps.BlogConfig'
			 a w tejże app/funkcjonalności w pliku apps.py w polu name musisz zmienić ściężkę dodając 
			 folder apps czyli zamiast: name = 'blog' musisz zmienic na:
							name = 'apps.blog'
			*STRUKTURA APLIKACJI/pojedyńczego folderu:	
						*folder migrations - do generowania baz danych 
						*admin module - wygląd admin interface dla tej aplikacji 
						*app module - miejsce do konfigurowania aplikacji 
						*models module - miejsce do definiowania modeli klas - służy do przechowywania i 
						    pobierania danych; służy do wyciągania danych z bazy danych i przedstawiania 
							ich użytkownikowi.
						*tests module - miejsce do unittestów do aplikacji 
						*views module - request handler, używa się przy wymianie danych między użytkownikiem
						    (który wysyła rządanie (request)) a serwerem który odsyła odpowiedź (response).
		D* SETTING DATABASE
			https://docs.djangoproject.com/en/4.0/intro/tutorial02/#database-setup
		    https://docs.djangoproject.com/en/4.0/ref/settings/#std:setting-DATABASES
	5)DZIAŁANIE:
		*wywołujesz ścieżę z urls w głównej app/funkc. -> ona prowadzi do podścieżek w urls danej appfunkc.
		*metoda path dla danej scieżki wywołuję daną funkcję we views.py 
		*funkcja z views.py wywołuję dany plik html z katalogu templates (i wewnątrznego katalogu o nazwie 
		 app/funkc) (+ew. przekazuję dane do tej strony html poprzez słownik)
	*) Aktywując wirtualkę (pipenv shell) automatycznie zostanie wybrany interpreter pythona z wirtualki ale
 	   możesz to zrboić ręcznie Visual Studio wybierz View --> Command Palette --> Select Intepreter
	   i tam wklej ścieżkę do wirtualki (będąc wcześniej w terminalu w ścieżce projektu uzyskasz ścieżkę 
	   do interpretera poprzez komendę pipenv --venv oraz dodając do uzyskanej ścieżki '\bin\python' ALBO 
	   '\Scripts\python') lub względem ścieżki którą udało ci się uzyskać poprzez komendę pipenv --venv 
	   możesz samemu wybrać interpreter Pythona klikając w opcję FIND.
	   
0. PODSTAWY:
	*Backend in Webdevelopment - "how you're going to respond to clients":
		*by generating requested page using HTML on the server and respond client by sending it 
		*by returning only the data needed on the requested page ---> Server is the gateway to the data 
		 ---> Server provides an API to the clients
		*MVC (MVT) - MODEL-VIEW-CONTROLLER (MODEL-VIEW-TEMPLATE):
			MODEL - DATA ACCESS LAYER
			VIEW - BUSINESS LOGIC 
			TEMPLATE - PRESENTATION LAYER
	*Frameworki:
		*SERVER-SIDE FRAMEWORK:
			*Django
			*Node.js / Express
		*CLIENT-SIDE FRAMWORKS:
			*React
			*Angular
			*Vue
	*DJANGO:	
		*Advantages:
				*LESS TIME & LESS CODE with huge community
				*it's slower but can take more data
				*youtube, instagram, spotify, dropbox
		*Django is a collection of various apps each providing certain functionality - some examples of 
		 created builtins features:
				*admin site
				*Object-relational-mapper
				*authentication
				*caching
	*ANOTHER: Flaks, Cherry Pie, Web2py, Pyramid
		
